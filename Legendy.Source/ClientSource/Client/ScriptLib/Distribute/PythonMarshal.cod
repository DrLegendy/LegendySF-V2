; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile
PUBLIC	?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadLastObjectFromFile
PUBLIC	?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z	; _PyMarshal_ReadLongFromFile
PUBLIC	?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z	; _PyMarshal_ReadShortFromFile
PUBLIC	?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ; _PyMarshal_ReadObjectFromString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ ; `string'
PUBLIC	??_C@_0BB@DCKILJJE@bad?5marshal?5data@		; `string'
PUBLIC	??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ ; `string'
PUBLIC	??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ ; `string'
PUBLIC	??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_atof:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	__fileno:PROC
EXTRN	_fread:PROC
EXTRN	_getc:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__fstat64i32:PROC
EXTRN	__imp__PyUnicodeUCS2_DecodeUTF8:PROC
EXTRN	__imp__PyInt_FromLong:PROC
EXTRN	__imp___PyLong_FromByteArray:PROC
EXTRN	__imp__PyFloat_FromDouble:PROC
EXTRN	__imp__PyComplex_FromCComplex:PROC
EXTRN	__imp__PyString_FromStringAndSize:PROC
EXTRN	__imp__PyTuple_New:PROC
EXTRN	__imp__PyList_New:PROC
EXTRN	__imp__PyList_SetItem:PROC
EXTRN	__imp__PyDict_New:PROC
EXTRN	__imp__PyDict_SetItem:PROC
EXTRN	__imp__PyErr_SetString:PROC
EXTRN	__imp__PyErr_Occurred:PROC
EXTRN	__imp__PyErr_NoMemory:PROC
EXTRN	__imp__PyEval_GetRestricted:PROC
EXTRN	__imp__PyCode_New:PROC
EXTRN	__imp__PyMarshal_ReadObjectFromString:PROC
EXTRN	__imp___PyLong_New:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp___Py_NoneStruct:QWORD
EXTRN	__imp___Py_EllipsisObject:QWORD
EXTRN	__imp__PyExc_StopIteration:DWORD
EXTRN	__imp__PyExc_EOFError:DWORD
EXTRN	__imp__PyExc_RuntimeError:DWORD
EXTRN	__imp__PyExc_ValueError:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
CONST	SEGMENT
??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ DB 'XXX rds_objec'
	DB	't called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
CONST	SEGMENT
??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ DB 'XXX rd_object '
	DB	'called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@
CONST	SEGMENT
??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ DB 'cannot unmars'
	DB	'hal code objects in restricted execution mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
CONST	SEGMENT
??_C@_0BB@DCKILJJE@bad?5marshal?5data@ DB 'bad marshal data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
CONST	SEGMENT
??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ DB 'EOF read where'
	DB	' object expected', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z PROC ; _PyMarshal_ReadObjectFromString, COMDAT

; 467  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 468  : 	RFILE rf;
; 469  : 	if (PyErr_Occurred()) {

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN2@PyMarshal_

; 470  : 		fprintf(stderr, "XXX rds_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	83 c4 04	 add	 esp, 4
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 08	 add	 esp, 8

; 471  : 		return NULL;

  00028	33 c0		 xor	 eax, eax

; 478  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@PyMarshal_:

; 472  : 	}
; 473  : 	rf.fp = NULL;
; 474  : 	rf.str = NULL;
; 475  : 	rf.ptr = str;

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]

; 476  : 	rf.end = str + len;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00034	03 c1		 add	 eax, ecx
  00036	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp], 0
  0003d	89 45 fc	 mov	 DWORD PTR _rf$[ebp+20], eax

; 477  : 	return r_object(&rf);

  00040	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00043	50		 push	 eax
  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp+12], 0
  0004b	89 4d f8	 mov	 DWORD PTR _rf$[ebp+16], ecx
  0004e	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00053	83 c4 04	 add	 esp, 4

; 478  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ENDP ; _PyMarshal_ReadObjectFromString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?getfilesize@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_st$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?getfilesize@@YAJPAU_iobuf@@@Z PROC			; getfilesize, COMDAT

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 __fileno
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h

; 237  :             return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);

  00019	8d 4d cc	 lea	 ecx, DWORD PTR _st$[ebp]
  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 __fstat64i32
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  00023	8b 4d e0	 mov	 ecx, DWORD PTR _st$[ebp+20]
  00026	83 ca ff	 or	 edx, -1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h

; 237  :             return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);

  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  0002c	85 c0		 test	 eax, eax
  0002e	0f 45 ca	 cmovne	 ecx, edx
  00031	8b c1		 mov	 eax, ecx

; 401  : 		return -1;
; 402  : 	else
; 403  : 		return st.st_size;
; 404  : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?getfilesize@@YAJPAU_iobuf@@@Z ENDP			; getfilesize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z PROC	; _PyMarshal_ReadShortFromFile, COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 384  : 	RFILE rf;
; 385  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 386  : 	return r_short(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00015	83 c4 04	 add	 esp, 4

; 387  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadShortFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_object@@YAPAU_object@@PAUWFILE@@@Z
_TEXT	SEGMENT
_c$1 = -320						; size = 16
_dx$2 = -312						; size = 8
_argcount$1$ = -308					; size = 4
_nlocals$1$ = -304					; size = 4
_stacksize$1$ = -300					; size = 4
_flags$1$ = -296					; size = 4
_code$1$ = -292						; size = 4
_varnames$1$ = -288					; size = 4
_names$1$ = -284					; size = 4
_consts$1$ = -280					; size = 4
_cellvars$1$ = -276					; size = 4
_firstlineno$1$ = -272					; size = 4
_v$6$ = -272						; size = 4
_lnotab$1$ = -268					; size = 4
_ob$1$ = -268						; size = 4
_n$7$ = -268						; size = 4
_freevars$1$ = -264					; size = 4
_v$5$ = -264						; size = 4
_v$3$ = -264						; size = 4
_n$8$ = -264						; size = 4
_buf$3 = -260						; size = 256
_buf$4 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?r_object@@YAPAU_object@@PAUWFILE@@@Z PROC		; r_object, COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00018	57		 push	 edi

; 124  : 	PyObject *v, *v2;
; 125  : 	long i, n;
; 126  : 	int type = r_byte(p);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	85 c0		 test	 eax, eax
  0001d	74 0d		 je	 SHORT $LN187@r_object
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _getc
  00025	83 c4 04	 add	 esp, 4
  00028	8b c8		 mov	 ecx, eax
  0002a	eb 13		 jmp	 SHORT $LN186@r_object
$LN187@r_object:
  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  00032	0f 84 32 08 00
	00		 je	 $LN88@r_object
  00038	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0003b	40		 inc	 eax
  0003c	89 46 10	 mov	 DWORD PTR [esi+16], eax
$LN186@r_object:

; 127  : 
; 128  : 	switch (type) {

  0003f	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00042	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00045	0f 87 99 02 00
	00		 ja	 $LN246@r_object
  0004b	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN232@r_object[eax]
  00052	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN233@r_object[eax*4]
$LN90@r_object:

; 129  : 
; 130  : 	case EOF:
; 131  : 		PyErr_SetString(PyExc_EOFError,
; 132  : 				"EOF read where object expected");
; 133  : 		return NULL;
; 134  : 
; 135  : 	case TYPE_NULL:
; 136  : 		return NULL;
; 137  : 
; 138  : 	case TYPE_NONE:
; 139  : 		Py_INCREF(Py_None);

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  0005e	ff 00		 inc	 DWORD PTR [eax]

; 140  : 		return Py_None;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	33 cd		 xor	 ecx, ebp
  0006d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
$LN91@r_object:

; 141  : 
; 142  : 	case TYPE_STOPITER:
; 143  : 		Py_INCREF(PyExc_StopIteration);

  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	ff 00		 inc	 DWORD PTR [eax]

; 144  : 		return PyExc_StopIteration;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  00084	8b 00		 mov	 eax, DWORD PTR [eax]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	33 cd		 xor	 ecx, ebp
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
$LN92@r_object:

; 145  : 
; 146  : 	case TYPE_ELLIPSIS:
; 147  : 		Py_INCREF(Py_Ellipsis);

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject
  0009c	ff 00		 inc	 DWORD PTR [eax]

; 148  : 		return Py_Ellipsis;

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	33 cd		 xor	 ecx, ebp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN93@r_object:

; 149  : 
; 150  : 	case TYPE_INT:
; 151  : 		return PyInt_FromLong(r_long(p));

  000b4	56		 push	 esi
  000b5	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyInt_FromLong
  000c1	83 c4 08	 add	 esp, 8

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	33 cd		 xor	 ecx, ebp
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
$LN94@r_object:

; 152  : 
; 153  : 	case TYPE_INT64:
; 154  : 		return r_long64(p);

  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 ?r_long64@@YAPAU_object@@PAUWFILE@@@Z ; r_long64
  000db	83 c4 04	 add	 esp, 4

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e4	33 cd		 xor	 ecx, ebp
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN95@r_object:

; 155  : 
; 156  : 	case TYPE_LONG:
; 157  : 		{
; 158  : 			int size;
; 159  : 			PyLongObject* ob;
; 160  : 			n = r_long(p);

  000ef	56		 push	 esi
  000f0	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  000f5	8b d8		 mov	 ebx, eax

; 161  : 			size = n<0 ? -n : n;

  000f7	99		 cdq
  000f8	8b f8		 mov	 edi, eax
  000fa	33 fa		 xor	 edi, edx
  000fc	2b fa		 sub	 edi, edx

; 162  : 			ob = _PyLong_New(size);

  000fe	57		 push	 edi
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_New
  00105	83 c4 08	 add	 esp, 8
  00108	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ob$1$[ebp], eax

; 163  : 			if (ob == NULL)

  0010e	85 c0		 test	 eax, eax
  00110	0f 84 69 07 00
	00		 je	 $LN244@r_object

; 164  : 				return NULL;
; 165  : 			ob->ob_size = n;

  00116	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 166  : 			for (i = 0; i < size; i++)

  00119	85 ff		 test	 edi, edi
  0011b	0f 8e 60 07 00
	00		 jle	 $LN1@r_object

; 164  : 				return NULL;
; 165  : 			ob->ob_size = n;

  00121	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]
$LL6@r_object:

; 167  : 				ob->ob_digit[i] = (short) r_short(p);

  00124	56		 push	 esi
  00125	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  0012a	83 c4 04	 add	 esp, 4
  0012d	66 89 03	 mov	 WORD PTR [ebx], ax
  00130	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  00133	83 ef 01	 sub	 edi, 1
  00136	75 ec		 jne	 SHORT $LL6@r_object
  00138	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ob$1$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  0013e	5f		 pop	 edi
  0013f	5e		 pop	 esi
  00140	5b		 pop	 ebx
  00141	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00144	33 cd		 xor	 ecx, ebp
  00146	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
$LN97@r_object:

; 168  : 			return (PyObject *) ob;
; 169  : 		}
; 170  : 
; 171  : 	case TYPE_FLOAT:
; 172  : 		{
; 173  : 			char buf[256];
; 174  : 			double dx;
; 175  : 			n = r_byte(p);

  0014f	8b 06		 mov	 eax, DWORD PTR [esi]
  00151	85 c0		 test	 eax, eax
  00153	74 0d		 je	 SHORT $LN191@r_object
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _getc
  0015b	83 c4 04	 add	 esp, 4
  0015e	8b f8		 mov	 edi, eax
  00160	eb 14		 jmp	 SHORT $LN190@r_object
$LN191@r_object:
  00162	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00165	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  00168	74 09		 je	 SHORT $LN189@r_object
  0016a	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  0016d	40		 inc	 eax
  0016e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00171	eb 03		 jmp	 SHORT $LN190@r_object
$LN189@r_object:
  00173	83 cf ff	 or	 edi, -1
$LN190@r_object:

; 176  : 			if (r_string(buf, (int)n, p) != n) {

  00176	56		 push	 esi
  00177	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  0017d	57		 push	 edi
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
  00187	3b c7		 cmp	 eax, edi
  00189	0f 85 db 06 00
	00		 jne	 $LN88@r_object

; 177  : 				PyErr_SetString(PyExc_EOFError,
; 178  : 					"EOF read where object expected");
; 179  : 				return NULL;
; 180  : 			}
; 181  : 			buf[n] = '\0';

  0018f	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  00195	0f 83 f7 06 00
	00		 jae	 $LN193@r_object

; 182  : 			PyFPE_START_PROTECT("atof", return 0)
; 183  : 			dx = atof(buf);

  0019b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  001a1	c6 84 3d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$4[ebp+edi], 0
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _atof
  001af	dd 9d c8 fe ff
	ff		 fstp	 QWORD PTR _dx$2[ebp]

; 184  : 			PyFPE_END_PROTECT(dx)
; 185  : 			return PyFloat_FromDouble(dx);

  001b5	f2 0f 10 85 c8
	fe ff ff	 movsd	 xmm0, QWORD PTR _dx$2[ebp]
  001bd	51		 push	 ecx
  001be	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyFloat_FromDouble
  001c9	83 c4 08	 add	 esp, 8

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  001cc	5f		 pop	 edi
  001cd	5e		 pop	 esi
  001ce	5b		 pop	 ebx
  001cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d2	33 cd		 xor	 ecx, ebp
  001d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c3		 ret	 0
$LN99@r_object:

; 186  : 		}
; 187  : 
; 188  : #ifndef WITHOUT_COMPLEX
; 189  : 	case TYPE_COMPLEX:
; 190  : 		{
; 191  : 			char buf[256];
; 192  : 			Py_complex c;
; 193  : 			n = r_byte(p);

  001dd	8b 06		 mov	 eax, DWORD PTR [esi]
  001df	85 c0		 test	 eax, eax
  001e1	74 0d		 je	 SHORT $LN197@r_object
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 _getc
  001e9	83 c4 04	 add	 esp, 4
  001ec	8b f8		 mov	 edi, eax
  001ee	eb 14		 jmp	 SHORT $LN196@r_object
$LN197@r_object:
  001f0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001f3	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  001f6	74 09		 je	 SHORT $LN195@r_object
  001f8	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  001fb	40		 inc	 eax
  001fc	89 46 10	 mov	 DWORD PTR [esi+16], eax
  001ff	eb 03		 jmp	 SHORT $LN196@r_object
$LN195@r_object:
  00201	83 cf ff	 or	 edi, -1
$LN196@r_object:

; 194  : 			if (r_string(buf, (int)n, p) != n) {

  00204	56		 push	 esi
  00205	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$3[ebp]
  0020b	57		 push	 edi
  0020c	50		 push	 eax
  0020d	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH
  00215	3b c7		 cmp	 eax, edi
  00217	0f 85 4d 06 00
	00		 jne	 $LN88@r_object

; 195  : 				PyErr_SetString(PyExc_EOFError,
; 196  : 					"EOF read where object expected");
; 197  : 				return NULL;
; 198  : 			}
; 199  : 			buf[n] = '\0';

  0021d	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  00223	0f 83 69 06 00
	00		 jae	 $LN193@r_object

; 200  : 			PyFPE_START_PROTECT("atof", return 0)
; 201  : 			c.real = atof(buf);

  00229	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$3[ebp]
  0022f	c6 84 3d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$3[ebp+edi], 0
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _atof

; 202  : 			PyFPE_END_PROTECT(c)
; 203  : 			n = r_byte(p);

  0023d	8b 06		 mov	 eax, DWORD PTR [esi]
  0023f	83 c4 04	 add	 esp, 4
  00242	dd 9d c0 fe ff
	ff		 fstp	 QWORD PTR _c$1[ebp]
  00248	85 c0		 test	 eax, eax
  0024a	74 0d		 je	 SHORT $LN203@r_object
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 _getc
  00252	83 c4 04	 add	 esp, 4
  00255	8b f8		 mov	 edi, eax
  00257	eb 14		 jmp	 SHORT $LN202@r_object
$LN203@r_object:
  00259	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0025c	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0025f	74 09		 je	 SHORT $LN201@r_object
  00261	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  00264	40		 inc	 eax
  00265	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00268	eb 03		 jmp	 SHORT $LN202@r_object
$LN201@r_object:
  0026a	83 cf ff	 or	 edi, -1
$LN202@r_object:

; 204  : 			if (r_string(buf, (int)n, p) != n) {

  0026d	56		 push	 esi
  0026e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$3[ebp]
  00274	57		 push	 edi
  00275	50		 push	 eax
  00276	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  0027b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027e	3b c7		 cmp	 eax, edi
  00280	0f 85 e4 05 00
	00		 jne	 $LN88@r_object

; 205  : 				PyErr_SetString(PyExc_EOFError,
; 206  : 					"EOF read where object expected");
; 207  : 				return NULL;
; 208  : 			}
; 209  : 			buf[n] = '\0';

  00286	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  0028c	0f 83 00 06 00
	00		 jae	 $LN193@r_object

; 210  : 			PyFPE_START_PROTECT("atof", return 0)
; 211  : 			c.imag = atof(buf);

  00292	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$3[ebp]
  00298	c6 84 3d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$3[ebp+edi], 0
  002a0	50		 push	 eax
  002a1	e8 00 00 00 00	 call	 _atof

; 212  : 			PyFPE_END_PROTECT(c)
; 213  : 			return PyComplex_FromCComplex(c);

  002a6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002a9	8b c4		 mov	 eax, esp
  002ab	dd 9d c8 fe ff
	ff		 fstp	 QWORD PTR _c$1[ebp+8]
  002b1	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _c$1[ebp]
  002b8	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  002bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyComplex_FromCComplex
  002c1	83 c4 10	 add	 esp, 16			; 00000010H

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  002c4	5f		 pop	 edi
  002c5	5e		 pop	 esi
  002c6	5b		 pop	 ebx
  002c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ca	33 cd		 xor	 ecx, ebp
  002cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c3		 ret	 0
$LN102@r_object:

; 214  : 		}
; 215  : #endif
; 216  : 
; 217  : 	case TYPE_STRING:
; 218  : 		n = r_long(p);

  002d5	56		 push	 esi
  002d6	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  002db	8b d8		 mov	 ebx, eax
  002dd	83 c4 04	 add	 esp, 4

; 219  : 		if (n < 0) {

  002e0	85 db		 test	 ebx, ebx
  002e2	79 0f		 jns	 SHORT $LN103@r_object
$LN246@r_object:

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  002e4	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  002e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  002ee	e9 81 05 00 00	 jmp	 $LN243@r_object
$LN103@r_object:

; 220  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 221  : 			return NULL;
; 222  : 		}
; 223  : 		v = PyString_FromStringAndSize((char *)NULL, n);

  002f3	53		 push	 ebx
  002f4	6a 00		 push	 0
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyString_FromStringAndSize
  002fc	8b f8		 mov	 edi, eax
  002fe	83 c4 08	 add	 esp, 8

; 224  : 		if (v != NULL) {

  00301	85 ff		 test	 edi, edi
  00303	74 3a		 je	 SHORT $LN105@r_object

; 225  : 			if (r_string(PyString_AS_STRING(v), (int)n, p) != n) {

  00305	56		 push	 esi
  00306	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00309	53		 push	 ebx
  0030a	51		 push	 ecx
  0030b	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  00310	83 c4 0c	 add	 esp, 12			; 0000000cH
  00313	3b c3		 cmp	 eax, ebx
  00315	74 28		 je	 SHORT $LN105@r_object

; 226  : 				Py_DECREF(v);

  00317	83 07 ff	 add	 DWORD PTR [edi], -1
  0031a	75 0c		 jne	 SHORT $LN7@r_object
  0031c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0031f	57		 push	 edi
  00320	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00323	ff d0		 call	 eax
  00325	83 c4 04	 add	 esp, 4
$LN7@r_object:

; 227  : 				v = NULL;
; 228  : 				PyErr_SetString(PyExc_EOFError,

  00328	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  0032d	33 ff		 xor	 edi, edi
  0032f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  00334	ff 30		 push	 DWORD PTR [eax]
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  0033c	83 c4 08	 add	 esp, 8
$LN105@r_object:

; 229  : 					"EOF read where object expected");
; 230  : 			}
; 231  : 		}
; 232  : 		return v;

  0033f	8b c7		 mov	 eax, edi

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
$LN108@r_object:

; 233  : 
; 234  : #ifdef Py_USING_UNICODE
; 235  : 	case TYPE_UNICODE:
; 236  : 	    {
; 237  : 		char *buffer;
; 238  : 
; 239  : 		n = r_long(p);

  00352	56		 push	 esi
  00353	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00358	8b f8		 mov	 edi, eax
  0035a	83 c4 04	 add	 esp, 4

; 240  : 		if (n < 0) {

  0035d	85 ff		 test	 edi, edi
  0035f	78 83		 js	 SHORT $LN246@r_object

; 241  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 242  : 			return NULL;
; 243  : 		}
; 244  : 		buffer = PyMem_NEW(char, n);

  00361	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00367	77 7e		 ja	 SHORT $LN229@r_object
  00369	85 ff		 test	 edi, edi
  0036b	b8 01 00 00 00	 mov	 eax, 1
  00370	0f 45 c7	 cmovne	 eax, edi
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 _malloc
  00379	8b d8		 mov	 ebx, eax
  0037b	83 c4 04	 add	 esp, 4

; 245  : 		if (buffer == NULL)

  0037e	85 db		 test	 ebx, ebx
  00380	74 65		 je	 SHORT $LN229@r_object

; 247  : 		if (r_string(buffer, (int)n, p) != n) {

  00382	56		 push	 esi
  00383	57		 push	 edi
  00384	53		 push	 ebx
  00385	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  0038a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0038d	3b c7		 cmp	 eax, edi
  0038f	74 2e		 je	 SHORT $LN111@r_object

; 248  : 			PyMem_DEL(buffer);

  00391	53		 push	 ebx
  00392	e8 00 00 00 00	 call	 _free

; 249  : 			PyErr_SetString(PyExc_EOFError,

  00397	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  0039c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  003a1	ff 30		 push	 DWORD PTR [eax]
  003a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  003a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  003ac	33 c0		 xor	 eax, eax
  003ae	5f		 pop	 edi
  003af	5e		 pop	 esi
  003b0	5b		 pop	 ebx
  003b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b4	33 cd		 xor	 ecx, ebp
  003b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bb	8b e5		 mov	 esp, ebp
  003bd	5d		 pop	 ebp
  003be	c3		 ret	 0
$LN111@r_object:

; 250  : 				"EOF read where object expected");
; 251  : 			return NULL;
; 252  : 		}
; 253  : 		v = PyUnicode_DecodeUTF8(buffer, n, NULL);

  003bf	6a 00		 push	 0
  003c1	57		 push	 edi
  003c2	53		 push	 ebx
  003c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyUnicodeUCS2_DecodeUTF8

; 254  : 		PyMem_DEL(buffer);

  003c9	53		 push	 ebx
  003ca	8b f0		 mov	 esi, eax
  003cc	e8 00 00 00 00	 call	 _free
  003d1	83 c4 10	 add	 esp, 16			; 00000010H

; 255  : 		return v;

  003d4	8b c6		 mov	 eax, esi

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  003d6	5f		 pop	 edi
  003d7	5e		 pop	 esi
  003d8	5b		 pop	 ebx
  003d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003dc	33 cd		 xor	 ecx, ebp
  003de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e3	8b e5		 mov	 esp, ebp
  003e5	5d		 pop	 ebp
  003e6	c3		 ret	 0
$LN229@r_object:

; 246  : 			return PyErr_NoMemory();

  003e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_NoMemory

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  003ed	5f		 pop	 edi
  003ee	5e		 pop	 esi
  003ef	5b		 pop	 ebx
  003f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f3	33 cd		 xor	 ecx, ebp
  003f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fa	8b e5		 mov	 esp, ebp
  003fc	5d		 pop	 ebp
  003fd	c3		 ret	 0
$LN112@r_object:

; 256  : 	    }
; 257  : #endif
; 258  : 
; 259  : 	case TYPE_TUPLE:
; 260  : 		n = r_long(p);

  003fe	56		 push	 esi
  003ff	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00404	8b d8		 mov	 ebx, eax
  00406	83 c4 04	 add	 esp, 4
  00409	89 9d f4 fe ff
	ff		 mov	 DWORD PTR _n$7$[ebp], ebx

; 261  : 		if (n < 0) {

  0040f	85 db		 test	 ebx, ebx
  00411	0f 88 cd fe ff
	ff		 js	 $LN246@r_object

; 262  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 263  : 			return NULL;
; 264  : 		}
; 265  : 		v = PyTuple_New((int)n);

  00417	53		 push	 ebx
  00418	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_New
  0041e	83 c4 04	 add	 esp, 4
  00421	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _v$3$[ebp], eax

; 266  : 		if (v == NULL)

  00427	85 c0		 test	 eax, eax
  00429	0f 84 50 04 00
	00		 je	 $LN244@r_object

; 267  : 			return v;
; 268  : 		for (i = 0; i < n; i++) {

  0042f	33 ff		 xor	 edi, edi
  00431	85 db		 test	 ebx, ebx
  00433	0f 8e 48 04 00
	00		 jle	 $LN1@r_object
  00439	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]
  0043c	0f 1f 40 00	 npad	 4
$LL12@r_object:

; 269  : 			v2 = r_object(p);

  00440	56		 push	 esi
  00441	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00446	83 c4 04	 add	 esp, 4

; 270  : 			if ( v2 == NULL ) {

  00449	85 c0		 test	 eax, eax
  0044b	74 25		 je	 SHORT $LN215@r_object

; 272  : 				v = NULL;
; 273  : 				break;
; 274  : 			}
; 275  : 			PyTuple_SET_ITEM(v, (int)i, v2);

  0044d	89 03		 mov	 DWORD PTR [ebx], eax
  0044f	47		 inc	 edi
  00450	83 c3 04	 add	 ebx, 4
  00453	3b bd f4 fe ff
	ff		 cmp	 edi, DWORD PTR _n$7$[ebp]
  00459	7c e5		 jl	 SHORT $LL12@r_object

; 306  : 			if (key == NULL)

  0045b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _v$3$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00461	5f		 pop	 edi
  00462	5e		 pop	 esi
  00463	5b		 pop	 ebx
  00464	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00467	33 cd		 xor	 ecx, ebp
  00469	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046e	8b e5		 mov	 esp, ebp
  00470	5d		 pop	 ebp
  00471	c3		 ret	 0
$LN215@r_object:

; 271  : 				Py_DECREF(v);

  00472	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _v$3$[ebp]
  00478	83 01 ff	 add	 DWORD PTR [ecx], -1
  0047b	0f 85 fe 03 00
	00		 jne	 $LN244@r_object
  00481	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00484	51		 push	 ecx
  00485	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00488	ff d0		 call	 eax
  0048a	83 c4 04	 add	 esp, 4

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  0048d	33 c0		 xor	 eax, eax
  0048f	5f		 pop	 edi
  00490	5e		 pop	 esi
  00491	5b		 pop	 ebx
  00492	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00495	33 cd		 xor	 ecx, ebp
  00497	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0049c	8b e5		 mov	 esp, ebp
  0049e	5d		 pop	 ebp
  0049f	c3		 ret	 0
$LN118@r_object:

; 276  : 		}
; 277  : 		return v;
; 278  : 
; 279  : 	case TYPE_LIST:
; 280  : 		n = r_long(p);

  004a0	56		 push	 esi
  004a1	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  004a6	83 c4 04	 add	 esp, 4
  004a9	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _n$8$[ebp], eax

; 281  : 		if (n < 0) {

  004af	85 c0		 test	 eax, eax
  004b1	0f 88 2d fe ff
	ff		 js	 $LN246@r_object

; 282  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 283  : 			return NULL;
; 284  : 		}
; 285  : 		v = PyList_New((int)n);

  004b7	50		 push	 eax
  004b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_New
  004be	8b d8		 mov	 ebx, eax
  004c0	83 c4 04	 add	 esp, 4

; 286  : 		if (v == NULL)

  004c3	85 db		 test	 ebx, ebx
  004c5	0f 84 b4 03 00
	00		 je	 $LN244@r_object

; 287  : 			return v;
; 288  : 		for (i = 0; i < n; i++) {

  004cb	33 ff		 xor	 edi, edi
  004cd	39 bd f8 fe ff
	ff		 cmp	 DWORD PTR _n$8$[ebp], edi
  004d3	7e 48		 jle	 SHORT $LN17@r_object
$LL18@r_object:

; 289  : 			v2 = r_object(p);

  004d5	56		 push	 esi
  004d6	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  004db	83 c4 04	 add	 esp, 4

; 290  : 			if ( v2 == NULL ) {

  004de	85 c0		 test	 eax, eax
  004e0	74 28		 je	 SHORT $LN216@r_object

; 293  : 				break;
; 294  : 			}
; 295  : 			PyList_SetItem(v, (int)i, v2);

  004e2	50		 push	 eax
  004e3	57		 push	 edi
  004e4	53		 push	 ebx
  004e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_SetItem
  004eb	47		 inc	 edi
  004ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ef	3b bd f8 fe ff
	ff		 cmp	 edi, DWORD PTR _n$8$[ebp]
  004f5	7c de		 jl	 SHORT $LL18@r_object

; 296  : 		}
; 297  : 		return v;

  004f7	8b c3		 mov	 eax, ebx

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  004f9	5f		 pop	 edi
  004fa	5e		 pop	 esi
  004fb	5b		 pop	 ebx
  004fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ff	33 cd		 xor	 ecx, ebp
  00501	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00506	8b e5		 mov	 esp, ebp
  00508	5d		 pop	 ebp
  00509	c3		 ret	 0
$LN216@r_object:

; 291  : 				Py_DECREF(v);

  0050a	83 03 ff	 add	 DWORD PTR [ebx], -1
  0050d	75 0c		 jne	 SHORT $LN19@r_object
  0050f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00512	53		 push	 ebx
  00513	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00516	ff d0		 call	 eax
  00518	83 c4 04	 add	 esp, 4
$LN19@r_object:

; 292  : 				v = NULL;

  0051b	33 db		 xor	 ebx, ebx
$LN17@r_object:

; 296  : 		}
; 297  : 		return v;

  0051d	8b c3		 mov	 eax, ebx

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  0051f	5f		 pop	 edi
  00520	5e		 pop	 esi
  00521	5b		 pop	 ebx
  00522	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00525	33 cd		 xor	 ecx, ebp
  00527	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0052c	8b e5		 mov	 esp, ebp
  0052e	5d		 pop	 ebp
  0052f	c3		 ret	 0
$LN124@r_object:

; 298  : 
; 299  : 	case TYPE_DICT:
; 300  : 		v = PyDict_New();

  00530	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_New
  00536	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _v$5$[ebp], eax

; 301  : 		if (v == NULL)

  0053c	85 c0		 test	 eax, eax
  0053e	0f 84 3b 03 00
	00		 je	 $LN244@r_object

; 302  : 			return NULL;
; 303  : 		for (;;) {
; 304  : 			PyObject *key, *val;
; 305  : 			key = r_object(p);

  00544	56		 push	 esi
  00545	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0054a	8b d8		 mov	 ebx, eax
  0054c	83 c4 04	 add	 esp, 4

; 306  : 			if (key == NULL)

  0054f	85 db		 test	 ebx, ebx
  00551	74 55		 je	 SHORT $LN217@r_object
$LL22@r_object:

; 307  : 				break; /* XXX Assume TYPE_NULL, not an error */
; 308  : 			val = r_object(p);

  00553	56		 push	 esi
  00554	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00559	8b f8		 mov	 edi, eax
  0055b	83 c4 04	 add	 esp, 4

; 309  : 			if (val != NULL)

  0055e	85 ff		 test	 edi, edi
  00560	74 11		 je	 SHORT $LN27@r_object

; 310  : 				PyDict_SetItem(v, key, val);

  00562	57		 push	 edi
  00563	53		 push	 ebx
  00564	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _v$5$[ebp]
  0056a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_SetItem
  00570	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@r_object:

; 311  : 			Py_DECREF(key);

  00573	83 03 ff	 add	 DWORD PTR [ebx], -1
  00576	75 0c		 jne	 SHORT $LN25@r_object
  00578	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0057b	53		 push	 ebx
  0057c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0057f	ff d0		 call	 eax
  00581	83 c4 04	 add	 esp, 4
$LN25@r_object:

; 312  : 			Py_XDECREF(val);

  00584	85 ff		 test	 edi, edi
  00586	74 11		 je	 SHORT $LN32@r_object
  00588	83 07 ff	 add	 DWORD PTR [edi], -1
  0058b	75 0c		 jne	 SHORT $LN32@r_object
  0058d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00590	57		 push	 edi
  00591	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00594	ff d0		 call	 eax
  00596	83 c4 04	 add	 esp, 4
$LN32@r_object:

; 302  : 			return NULL;
; 303  : 		for (;;) {
; 304  : 			PyObject *key, *val;
; 305  : 			key = r_object(p);

  00599	56		 push	 esi
  0059a	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0059f	8b d8		 mov	 ebx, eax
  005a1	83 c4 04	 add	 esp, 4

; 306  : 			if (key == NULL)

  005a4	85 db		 test	 ebx, ebx
  005a6	75 ab		 jne	 SHORT $LL22@r_object
$LN217@r_object:

; 313  : 		}
; 314  : 		return v;

  005a8	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _v$5$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  005ae	5f		 pop	 edi
  005af	5e		 pop	 esi
  005b0	5b		 pop	 ebx
  005b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b4	33 cd		 xor	 ecx, ebp
  005b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005bb	8b e5		 mov	 esp, ebp
  005bd	5d		 pop	 ebp
  005be	c3		 ret	 0
$LN134@r_object:

; 315  : 
; 316  : 	case TYPE_CODE:
; 317  : 		if (PyEval_GetRestricted()) {

  005bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyEval_GetRestricted
  005c5	85 c0		 test	 eax, eax
  005c7	74 0f		 je	 SHORT $LN135@r_object

; 318  : 			PyErr_SetString(PyExc_RuntimeError,

  005c9	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  005ce	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@

; 319  : 				"cannot unmarshal code objects in "
; 320  : 				"restricted execution mode");
; 321  : 			return NULL;

  005d3	e9 9c 02 00 00	 jmp	 $LN243@r_object
$LN135@r_object:

; 322  : 		}
; 323  : 		else {
; 324  : 			int argcount = r_short(p);

  005d8	56		 push	 esi
  005d9	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 325  : 			int nlocals = r_short(p);

  005de	56		 push	 esi
  005df	89 85 cc fe ff
	ff		 mov	 DWORD PTR _argcount$1$[ebp], eax
  005e5	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 326  : 			int stacksize = r_short(p);

  005ea	56		 push	 esi
  005eb	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _nlocals$1$[ebp], eax
  005f1	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 327  : 			int flags = r_short(p);

  005f6	56		 push	 esi
  005f7	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _stacksize$1$[ebp], eax
  005fd	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00602	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _flags$1$[ebp], eax

; 328  : 			PyObject *code = NULL;
; 329  : 			PyObject *consts = NULL;
; 330  : 			PyObject *names = NULL;
; 331  : 			PyObject *varnames = NULL;
; 332  : 			PyObject *freevars = NULL;
; 333  : 			PyObject *cellvars = NULL;
; 334  : 			PyObject *filename = NULL;

  00608	33 db		 xor	 ebx, ebx
  0060a	33 c0		 xor	 eax, eax
  0060c	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _consts$1$[ebp], 0

; 335  : 			PyObject *name = NULL;
; 336  : 			int firstlineno = 0;
; 337  : 			PyObject *lnotab = NULL;
; 338  : 
; 339  : 			code = r_object(p);

  00616	56		 push	 esi
  00617	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _names$1$[ebp], 0
  00621	33 ff		 xor	 edi, edi
  00623	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _varnames$1$[ebp], 0
  0062d	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _freevars$1$[ebp], 0
  00637	89 85 ec fe ff
	ff		 mov	 DWORD PTR _cellvars$1$[ebp], eax
  0063d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _firstlineno$1$[ebp], eax
  00643	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lnotab$1$[ebp], eax
  00649	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0064e	83 c4 14	 add	 esp, 20			; 00000014H
  00651	89 85 dc fe ff
	ff		 mov	 DWORD PTR _code$1$[ebp], eax

; 340  : 			if (code) consts = r_object(p);

  00657	85 c0		 test	 eax, eax
  00659	0f 84 a0 00 00
	00		 je	 $LN241@r_object
  0065f	56		 push	 esi
  00660	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00665	83 c4 04	 add	 esp, 4
  00668	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _consts$1$[ebp], eax

; 341  : 			if (consts) names = r_object(p);

  0066e	85 c0		 test	 eax, eax
  00670	0f 84 89 00 00
	00		 je	 $LN241@r_object
  00676	56		 push	 esi
  00677	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0067c	83 c4 04	 add	 esp, 4
  0067f	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _names$1$[ebp], eax

; 342  : 			if (names) varnames = r_object(p);

  00685	85 c0		 test	 eax, eax
  00687	74 76		 je	 SHORT $LN241@r_object
  00689	56		 push	 esi
  0068a	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0068f	83 c4 04	 add	 esp, 4
  00692	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _varnames$1$[ebp], eax

; 343  : 			if (varnames) freevars = r_object(p);

  00698	85 c0		 test	 eax, eax
  0069a	74 63		 je	 SHORT $LN241@r_object
  0069c	56		 push	 esi
  0069d	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006a2	83 c4 04	 add	 esp, 4
  006a5	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _freevars$1$[ebp], eax

; 344  : 			if (freevars) cellvars = r_object(p);

  006ab	85 c0		 test	 eax, eax
  006ad	74 50		 je	 SHORT $LN241@r_object
  006af	56		 push	 esi
  006b0	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006b5	83 c4 04	 add	 esp, 4
  006b8	89 85 ec fe ff
	ff		 mov	 DWORD PTR _cellvars$1$[ebp], eax

; 345  : 			if (cellvars) filename = r_object(p);

  006be	85 c0		 test	 eax, eax
  006c0	74 3d		 je	 SHORT $LN241@r_object
  006c2	56		 push	 esi
  006c3	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006c8	8b d8		 mov	 ebx, eax
  006ca	83 c4 04	 add	 esp, 4

; 346  : 			if (filename) name = r_object(p);

  006cd	85 db		 test	 ebx, ebx
  006cf	74 2e		 je	 SHORT $LN241@r_object
  006d1	56		 push	 esi
  006d2	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006d7	8b f8		 mov	 edi, eax
  006d9	83 c4 04	 add	 esp, 4

; 347  : 			if (name) {

  006dc	85 ff		 test	 edi, edi
  006de	74 1f		 je	 SHORT $LN241@r_object

; 348  : 				firstlineno = r_short(p);

  006e0	56		 push	 esi
  006e1	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 349  : 				lnotab = r_object(p);

  006e6	56		 push	 esi
  006e7	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _firstlineno$1$[ebp], eax
  006ed	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006f2	8b f0		 mov	 esi, eax
  006f4	83 c4 08	 add	 esp, 8
  006f7	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _lnotab$1$[ebp], esi
  006fd	eb 02		 jmp	 SHORT $LN144@r_object
$LN241@r_object:

; 350  : 			}
; 351  : 
; 352  : 			if (!PyErr_Occurred()) {

  006ff	33 f6		 xor	 esi, esi
$LN144@r_object:
  00701	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  00707	85 c0		 test	 eax, eax
  00709	75 57		 jne	 SHORT $LN145@r_object

; 353  : 				v = (PyObject *) PyCode_New(

  0070b	56		 push	 esi
  0070c	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _firstlineno$1$[ebp]
  00712	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _cellvars$1$[ebp]
  00718	57		 push	 edi
  00719	53		 push	 ebx
  0071a	56		 push	 esi
  0071b	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _freevars$1$[ebp]
  00721	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _varnames$1$[ebp]
  00727	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _names$1$[ebp]
  0072d	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _consts$1$[ebp]
  00733	ff b5 dc fe ff
	ff		 push	 DWORD PTR _code$1$[ebp]
  00739	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _flags$1$[ebp]
  0073f	ff b5 d4 fe ff
	ff		 push	 DWORD PTR _stacksize$1$[ebp]
  00745	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _nlocals$1$[ebp]
  0074b	ff b5 cc fe ff
	ff		 push	 DWORD PTR _argcount$1$[ebp]
  00751	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCode_New
  00757	83 c4 38	 add	 esp, 56			; 00000038H
  0075a	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _v$6$[ebp], eax

; 354  : 					argcount, nlocals, stacksize, flags,
; 355  : 					code, consts, names, varnames,
; 356  : 					freevars, cellvars, filename, name,
; 357  : 					firstlineno, lnotab);
; 358  : 			}

  00760	eb 10		 jmp	 SHORT $LN36@r_object
$LN145@r_object:
  00762	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _cellvars$1$[ebp]

; 359  : 			else
; 360  : 				v = NULL;

  00768	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$6$[ebp], 0
$LN36@r_object:

; 361  : 			Py_XDECREF(code);

  00772	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _code$1$[ebp]
  00778	85 c9		 test	 ecx, ecx
  0077a	74 11		 je	 SHORT $LN38@r_object
  0077c	83 01 ff	 add	 DWORD PTR [ecx], -1
  0077f	75 0c		 jne	 SHORT $LN38@r_object
  00781	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00784	51		 push	 ecx
  00785	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00788	ff d0		 call	 eax
  0078a	83 c4 04	 add	 esp, 4
$LN38@r_object:

; 362  : 			Py_XDECREF(consts);

  0078d	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _consts$1$[ebp]
  00793	85 c9		 test	 ecx, ecx
  00795	74 11		 je	 SHORT $LN44@r_object
  00797	83 01 ff	 add	 DWORD PTR [ecx], -1
  0079a	75 0c		 jne	 SHORT $LN44@r_object
  0079c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0079f	51		 push	 ecx
  007a0	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007a3	ff d0		 call	 eax
  007a5	83 c4 04	 add	 esp, 4
$LN44@r_object:

; 363  : 			Py_XDECREF(names);

  007a8	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _names$1$[ebp]
  007ae	85 c9		 test	 ecx, ecx
  007b0	74 11		 je	 SHORT $LN50@r_object
  007b2	83 01 ff	 add	 DWORD PTR [ecx], -1
  007b5	75 0c		 jne	 SHORT $LN50@r_object
  007b7	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007ba	51		 push	 ecx
  007bb	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007be	ff d0		 call	 eax
  007c0	83 c4 04	 add	 esp, 4
$LN50@r_object:

; 364  : 			Py_XDECREF(varnames);

  007c3	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _varnames$1$[ebp]
  007c9	85 c9		 test	 ecx, ecx
  007cb	74 11		 je	 SHORT $LN56@r_object
  007cd	83 01 ff	 add	 DWORD PTR [ecx], -1
  007d0	75 0c		 jne	 SHORT $LN56@r_object
  007d2	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007d5	51		 push	 ecx
  007d6	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007d9	ff d0		 call	 eax
  007db	83 c4 04	 add	 esp, 4
$LN56@r_object:

; 365  : 			Py_XDECREF(freevars);

  007de	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _freevars$1$[ebp]
  007e4	85 c9		 test	 ecx, ecx
  007e6	74 11		 je	 SHORT $LN62@r_object
  007e8	83 01 ff	 add	 DWORD PTR [ecx], -1
  007eb	75 0c		 jne	 SHORT $LN62@r_object
  007ed	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007f0	51		 push	 ecx
  007f1	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007f4	ff d0		 call	 eax
  007f6	83 c4 04	 add	 esp, 4
$LN62@r_object:

; 366  : 			Py_XDECREF(cellvars);

  007f9	85 f6		 test	 esi, esi
  007fb	74 11		 je	 SHORT $LN68@r_object
  007fd	83 06 ff	 add	 DWORD PTR [esi], -1
  00800	75 0c		 jne	 SHORT $LN68@r_object
  00802	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00805	56		 push	 esi
  00806	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00809	ff d0		 call	 eax
  0080b	83 c4 04	 add	 esp, 4
$LN68@r_object:

; 367  : 			Py_XDECREF(filename);

  0080e	85 db		 test	 ebx, ebx
  00810	74 11		 je	 SHORT $LN74@r_object
  00812	83 03 ff	 add	 DWORD PTR [ebx], -1
  00815	75 0c		 jne	 SHORT $LN74@r_object
  00817	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0081a	53		 push	 ebx
  0081b	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0081e	ff d0		 call	 eax
  00820	83 c4 04	 add	 esp, 4
$LN74@r_object:

; 368  : 			Py_XDECREF(name);

  00823	85 ff		 test	 edi, edi
  00825	74 11		 je	 SHORT $LN80@r_object
  00827	83 07 ff	 add	 DWORD PTR [edi], -1
  0082a	75 0c		 jne	 SHORT $LN80@r_object
  0082c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0082f	57		 push	 edi
  00830	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00833	ff d0		 call	 eax
  00835	83 c4 04	 add	 esp, 4
$LN80@r_object:

; 369  : 			Py_XDECREF(lnotab);

  00838	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lnotab$1$[ebp]
  0083e	85 c9		 test	 ecx, ecx
  00840	74 11		 je	 SHORT $LN86@r_object
  00842	83 01 ff	 add	 DWORD PTR [ecx], -1
  00845	75 0c		 jne	 SHORT $LN86@r_object
  00847	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0084a	51		 push	 ecx
  0084b	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0084e	ff d0		 call	 eax
  00850	83 c4 04	 add	 esp, 4
$LN86@r_object:

; 370  : 
; 371  : 		}
; 372  : 		return v;

  00853	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _v$6$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00859	5f		 pop	 edi
  0085a	5e		 pop	 esi
  0085b	5b		 pop	 ebx
  0085c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0085f	33 cd		 xor	 ecx, ebp
  00861	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00866	8b e5		 mov	 esp, ebp
  00868	5d		 pop	 ebp
  00869	c3		 ret	 0
$LN88@r_object:
  0086a	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  0086f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
$LN243@r_object:
  00874	ff 30		 push	 DWORD PTR [eax]
  00876	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  0087c	83 c4 08	 add	 esp, 8
$LN244@r_object:
  0087f	33 c0		 xor	 eax, eax
$LN1@r_object:
  00881	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00884	5f		 pop	 edi
  00885	5e		 pop	 esi
  00886	33 cd		 xor	 ecx, ebp
  00888	5b		 pop	 ebx
  00889	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0088e	8b e5		 mov	 esp, ebp
  00890	5d		 pop	 ebp
  00891	c3		 ret	 0
$LN193@r_object:
  00892	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN242@r_object:
  00897	90		 npad	 1
$LN233@r_object:
  00898	00 00 00 00	 DD	 $LN88@r_object
  0089c	00 00 00 00	 DD	 $LN112@r_object
  008a0	00 00 00 00	 DD	 $LN92@r_object
  008a4	00 00 00 00	 DD	 $LN244@r_object
  008a8	00 00 00 00	 DD	 $LN94@r_object
  008ac	00 00 00 00	 DD	 $LN90@r_object
  008b0	00 00 00 00	 DD	 $LN91@r_object
  008b4	00 00 00 00	 DD	 $LN118@r_object
  008b8	00 00 00 00	 DD	 $LN134@r_object
  008bc	00 00 00 00	 DD	 $LN97@r_object
  008c0	00 00 00 00	 DD	 $LN93@r_object
  008c4	00 00 00 00	 DD	 $LN95@r_object
  008c8	00 00 00 00	 DD	 $LN102@r_object
  008cc	00 00 00 00	 DD	 $LN108@r_object
  008d0	00 00 00 00	 DD	 $LN99@r_object
  008d4	00 00 00 00	 DD	 $LN124@r_object
  008d8	00 00 00 00	 DD	 $LN246@r_object
$LN232@r_object:
  008dc	00		 DB	 0
  008dd	10		 DB	 16			; 00000010H
  008de	10		 DB	 16			; 00000010H
  008df	10		 DB	 16			; 00000010H
  008e0	10		 DB	 16			; 00000010H
  008e1	10		 DB	 16			; 00000010H
  008e2	10		 DB	 16			; 00000010H
  008e3	10		 DB	 16			; 00000010H
  008e4	10		 DB	 16			; 00000010H
  008e5	10		 DB	 16			; 00000010H
  008e6	10		 DB	 16			; 00000010H
  008e7	10		 DB	 16			; 00000010H
  008e8	10		 DB	 16			; 00000010H
  008e9	10		 DB	 16			; 00000010H
  008ea	10		 DB	 16			; 00000010H
  008eb	10		 DB	 16			; 00000010H
  008ec	10		 DB	 16			; 00000010H
  008ed	10		 DB	 16			; 00000010H
  008ee	10		 DB	 16			; 00000010H
  008ef	10		 DB	 16			; 00000010H
  008f0	10		 DB	 16			; 00000010H
  008f1	10		 DB	 16			; 00000010H
  008f2	10		 DB	 16			; 00000010H
  008f3	10		 DB	 16			; 00000010H
  008f4	10		 DB	 16			; 00000010H
  008f5	10		 DB	 16			; 00000010H
  008f6	10		 DB	 16			; 00000010H
  008f7	10		 DB	 16			; 00000010H
  008f8	10		 DB	 16			; 00000010H
  008f9	10		 DB	 16			; 00000010H
  008fa	10		 DB	 16			; 00000010H
  008fb	10		 DB	 16			; 00000010H
  008fc	10		 DB	 16			; 00000010H
  008fd	10		 DB	 16			; 00000010H
  008fe	10		 DB	 16			; 00000010H
  008ff	10		 DB	 16			; 00000010H
  00900	10		 DB	 16			; 00000010H
  00901	10		 DB	 16			; 00000010H
  00902	10		 DB	 16			; 00000010H
  00903	10		 DB	 16			; 00000010H
  00904	10		 DB	 16			; 00000010H
  00905	01		 DB	 1
  00906	10		 DB	 16			; 00000010H
  00907	10		 DB	 16			; 00000010H
  00908	10		 DB	 16			; 00000010H
  00909	10		 DB	 16			; 00000010H
  0090a	10		 DB	 16			; 00000010H
  0090b	02		 DB	 2
  0090c	10		 DB	 16			; 00000010H
  0090d	03		 DB	 3
  0090e	10		 DB	 16			; 00000010H
  0090f	10		 DB	 16			; 00000010H
  00910	10		 DB	 16			; 00000010H
  00911	10		 DB	 16			; 00000010H
  00912	10		 DB	 16			; 00000010H
  00913	10		 DB	 16			; 00000010H
  00914	10		 DB	 16			; 00000010H
  00915	10		 DB	 16			; 00000010H
  00916	10		 DB	 16			; 00000010H
  00917	10		 DB	 16			; 00000010H
  00918	10		 DB	 16			; 00000010H
  00919	10		 DB	 16			; 00000010H
  0091a	10		 DB	 16			; 00000010H
  0091b	10		 DB	 16			; 00000010H
  0091c	10		 DB	 16			; 00000010H
  0091d	10		 DB	 16			; 00000010H
  0091e	10		 DB	 16			; 00000010H
  0091f	10		 DB	 16			; 00000010H
  00920	10		 DB	 16			; 00000010H
  00921	10		 DB	 16			; 00000010H
  00922	10		 DB	 16			; 00000010H
  00923	10		 DB	 16			; 00000010H
  00924	10		 DB	 16			; 00000010H
  00925	10		 DB	 16			; 00000010H
  00926	04		 DB	 4
  00927	10		 DB	 16			; 00000010H
  00928	10		 DB	 16			; 00000010H
  00929	10		 DB	 16			; 00000010H
  0092a	10		 DB	 16			; 00000010H
  0092b	05		 DB	 5
  0092c	10		 DB	 16			; 00000010H
  0092d	10		 DB	 16			; 00000010H
  0092e	10		 DB	 16			; 00000010H
  0092f	10		 DB	 16			; 00000010H
  00930	06		 DB	 6
  00931	10		 DB	 16			; 00000010H
  00932	10		 DB	 16			; 00000010H
  00933	10		 DB	 16			; 00000010H
  00934	10		 DB	 16			; 00000010H
  00935	10		 DB	 16			; 00000010H
  00936	10		 DB	 16			; 00000010H
  00937	10		 DB	 16			; 00000010H
  00938	07		 DB	 7
  00939	10		 DB	 16			; 00000010H
  0093a	10		 DB	 16			; 00000010H
  0093b	10		 DB	 16			; 00000010H
  0093c	10		 DB	 16			; 00000010H
  0093d	10		 DB	 16			; 00000010H
  0093e	10		 DB	 16			; 00000010H
  0093f	10		 DB	 16			; 00000010H
  00940	08		 DB	 8
  00941	10		 DB	 16			; 00000010H
  00942	10		 DB	 16			; 00000010H
  00943	09		 DB	 9
  00944	10		 DB	 16			; 00000010H
  00945	10		 DB	 16			; 00000010H
  00946	0a		 DB	 10			; 0000000aH
  00947	10		 DB	 16			; 00000010H
  00948	10		 DB	 16			; 00000010H
  00949	0b		 DB	 11			; 0000000bH
  0094a	10		 DB	 16			; 00000010H
  0094b	10		 DB	 16			; 00000010H
  0094c	10		 DB	 16			; 00000010H
  0094d	10		 DB	 16			; 00000010H
  0094e	10		 DB	 16			; 00000010H
  0094f	10		 DB	 16			; 00000010H
  00950	0c		 DB	 12			; 0000000cH
  00951	10		 DB	 16			; 00000010H
  00952	0d		 DB	 13			; 0000000dH
  00953	10		 DB	 16			; 00000010H
  00954	10		 DB	 16			; 00000010H
  00955	0e		 DB	 14			; 0000000eH
  00956	10		 DB	 16			; 00000010H
  00957	10		 DB	 16			; 00000010H
  00958	0f		 DB	 15			; 0000000fH
?r_object@@YAPAU_object@@PAUWFILE@@@Z ENDP		; r_object
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long64@@YAPAU_object@@PAUWFILE@@@Z
_TEXT	SEGMENT
_buf$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?r_long64@@YAPAU_object@@PAUWFILE@@@Z PROC		; r_long64, COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _p$[ebp]

; 101  : 	long lo4 = r_long(p);

  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long

; 102  : 	long hi4 = r_long(p);

  0001b	57		 push	 edi
  0001c	8b f0		 mov	 esi, eax
  0001e	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long

; 103  : #if SIZEOF_LONG > 4
; 104  : 	long x = (hi4 << 32) | (lo4 & 0xFFFFFFFFL);
; 105  : 	return PyInt_FromLong(x);
; 106  : #else
; 107  : 	unsigned char buf[8];
; 108  : 	int one = 1;
; 109  : 	int is_little_endian = (int)*(char*)&one;
; 110  : 	if (is_little_endian) {
; 111  : 		memcpy(buf, &lo4, 4);
; 112  : 		memcpy(buf+4, &hi4, 4);
; 113  : 	}
; 114  : 	else {
; 115  : 		memcpy(buf, &hi4, 4);
; 116  : 		memcpy(buf+4, &lo4, 4);
; 117  : 	}
; 118  : 	return _PyLong_FromByteArray(buf, 8, is_little_endian, 1);

  00023	6a 01		 push	 1
  00025	6a 01		 push	 1
  00027	89 45 f8	 mov	 DWORD PTR _buf$[ebp+4], eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR _buf$[ebp]
  0002d	6a 08		 push	 8
  0002f	50		 push	 eax
  00030	89 75 f4	 mov	 DWORD PTR _buf$[ebp], esi
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_FromByteArray

; 119  : #endif
; 120  : }

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	83 c4 18	 add	 esp, 24			; 00000018H
  0003f	33 cd		 xor	 ecx, ebp
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?r_long64@@YAPAU_object@@PAUWFILE@@@Z ENDP		; r_long64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long@@YAJPAUWFILE@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?r_long@@YAJPAUWFILE@@@Z PROC				; r_long, COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 	register long x;
; 72   : 	register FILE *fp = p->fp;

  00003	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 3a		 mov	 edi, DWORD PTR [edx]

; 73   : 	if (fp) {

  0000a	85 ff		 test	 edi, edi
  0000c	74 30		 je	 SHORT $LN2@r_long

; 74   : 		x = getc(fp);

  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _getc

; 75   : 		x |= (long)getc(fp) << 8;

  00014	57		 push	 edi
  00015	8b f0		 mov	 esi, eax
  00017	e8 00 00 00 00	 call	 _getc
  0001c	c1 e0 08	 shl	 eax, 8

; 76   : 		x |= (long)getc(fp) << 16;

  0001f	57		 push	 edi
  00020	0b f0		 or	 esi, eax
  00022	e8 00 00 00 00	 call	 _getc
  00027	c1 e0 10	 shl	 eax, 16			; 00000010H

; 77   : 		x |= (long)getc(fp) << 24;

  0002a	57		 push	 edi
  0002b	0b f0		 or	 esi, eax
  0002d	e8 00 00 00 00	 call	 _getc
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	c1 e0 18	 shl	 eax, 24			; 00000018H
  00038	0b c6		 or	 eax, esi
  0003a	5f		 pop	 edi

; 90   : }

  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN2@r_long:

; 78   : 	}
; 79   : 	else {
; 80   : 		x = rs_byte(p);

  0003e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00041	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00044	3b ce		 cmp	 ecx, esi
  00046	74 41		 je	 SHORT $LN5@r_long
  00048	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0004b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0004e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 81   : 		x |= (long)rs_byte(p) << 8;

  00051	3b fe		 cmp	 edi, esi
  00053	74 37		 je	 SHORT $LN7@r_long
  00055	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00058	47		 inc	 edi
  00059	c1 e1 08	 shl	 ecx, 8
  0005c	0b c8		 or	 ecx, eax
  0005e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 82   : 		x |= (long)rs_byte(p) << 16;

  00061	3b fe		 cmp	 edi, esi
  00063	74 2e		 je	 SHORT $LN9@r_long
  00065	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00068	47		 inc	 edi
  00069	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006c	0b c8		 or	 ecx, eax
  0006e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 83   : 		x |= (long)rs_byte(p) << 24;

  00071	3b fe		 cmp	 edi, esi
  00073	74 24		 je	 SHORT $LN11@r_long
  00075	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00078	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0007b	c1 e6 18	 shl	 esi, 24			; 00000018H
  0007e	0b ce		 or	 ecx, esi
  00080	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00083	5f		 pop	 edi

; 84   : 	}
; 85   : #if SIZEOF_LONG > 4
; 86   : 	/* Sign extension for 64-bit machines */
; 87   : 	x |= -(x & 0x80000000L);
; 88   : #endif
; 89   : 	return x;

  00084	8b c1		 mov	 eax, ecx

; 90   : }

  00086	5e		 pop	 esi
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN5@r_long:

; 78   : 	}
; 79   : 	else {
; 80   : 		x = rs_byte(p);

  00089	83 c8 ff	 or	 eax, -1
$LN7@r_long:

; 81   : 		x |= (long)rs_byte(p) << 8;

  0008c	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00091	8b c8		 mov	 ecx, eax
$LN9@r_long:

; 82   : 		x |= (long)rs_byte(p) << 16;

  00093	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN11@r_long:

; 83   : 		x |= (long)rs_byte(p) << 24;

  00099	83 ce ff	 or	 esi, -1
  0009c	c1 e6 18	 shl	 esi, 24			; 00000018H
  0009f	0b ce		 or	 ecx, esi
  000a1	5f		 pop	 edi

; 84   : 	}
; 85   : #if SIZEOF_LONG > 4
; 86   : 	/* Sign extension for 64-bit machines */
; 87   : 	x |= -(x & 0x80000000L);
; 88   : #endif
; 89   : 	return x;

  000a2	8b c1		 mov	 eax, ecx

; 90   : }

  000a4	5e		 pop	 esi
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?r_long@@YAJPAUWFILE@@@Z ENDP				; r_long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_short@@YAHPAUWFILE@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?r_short@@YAHPAUWFILE@@@Z PROC				; r_short, COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 61   : 	register short x;
; 62   : 	x = (short) r_byte(p);

  00004	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00007	57		 push	 edi
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 1f		 je	 SHORT $LN5@r_short
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _getc
  00014	0f b7 f8	 movzx	 edi, ax
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]

; 63   : 	x |= (short) r_byte(p) << 8;

  0001c	85 c0		 test	 eax, eax
  0001e	74 23		 je	 SHORT $LN11@r_short
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _getc
  00026	83 c4 04	 add	 esp, 4
  00029	8b c8		 mov	 ecx, eax
  0002b	eb 2a		 jmp	 SHORT $LN8@r_short
$LN5@r_short:

; 61   : 	register short x;
; 62   : 	x = (short) r_byte(p);

  0002d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00030	3b 4e 14	 cmp	 ecx, DWORD PTR [esi+20]
  00033	74 0b		 je	 SHORT $LN3@r_short
  00035	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  00038	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0003b	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0003e	eb 03		 jmp	 SHORT $LN11@r_short
$LN3@r_short:
  00040	83 cf ff	 or	 edi, -1
$LN11@r_short:

; 63   : 	x |= (short) r_byte(p) << 8;

  00043	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00046	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  00049	74 09		 je	 SHORT $LN7@r_short
  0004b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0004e	40		 inc	 eax
  0004f	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00052	eb 03		 jmp	 SHORT $LN8@r_short
$LN7@r_short:
  00054	83 c9 ff	 or	 ecx, -1
$LN8@r_short:
  00057	c1 e1 08	 shl	 ecx, 8
  0005a	0b f9		 or	 edi, ecx

; 64   : 	/* Sign-extension, in case short greater than 16 bits */
; 65   : 	x |= -(x & 0x8000);

  0005c	8b c7		 mov	 eax, edi
  0005e	0f bf cf	 movsx	 ecx, di
  00061	25 00 80 ff ff	 and	 eax, -32768		; ffff8000H
  00066	f7 d8		 neg	 eax
  00068	98		 cwde

; 66   : 	return x;

  00069	5f		 pop	 edi
  0006a	0b c1		 or	 eax, ecx
  0006c	5e		 pop	 esi

; 67   : }

  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?r_short@@YAHPAUWFILE@@@Z ENDP				; r_short
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_string@@YAHPADHPAUWFILE@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_p$ = 16						; size = 4
?r_string@@YAHPADHPAUWFILE@@@Z PROC			; r_string, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 50   : 	if (p->fp != NULL)

  00004	8b 7d 10	 mov	 edi, DWORD PTR _p$[ebp]
  00007	8b 07		 mov	 eax, DWORD PTR [edi]
  00009	85 c0		 test	 eax, eax
  0000b	74 14		 je	 SHORT $LN2@r_string

; 51   : 		return fread(s, 1, n, p->fp);

  0000d	50		 push	 eax
  0000e	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00011	6a 01		 push	 1
  00013	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00016	e8 00 00 00 00	 call	 _fread
  0001b	83 c4 10	 add	 esp, 16			; 00000010H
  0001e	5f		 pop	 edi

; 57   : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN2@r_string:

; 52   : 	if (p->end - p->ptr < n)

  00021	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00024	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00027	56		 push	 esi
  00028	8b 75 0c	 mov	 esi, DWORD PTR _n$[ebp]
  0002b	2b ca		 sub	 ecx, edx
  0002d	3b ce		 cmp	 ecx, esi
  0002f	0f 4c f1	 cmovl	 esi, ecx

; 53   : 		n = p->end - p->ptr;
; 54   : 	memcpy(s, p->ptr, n);

  00032	56		 push	 esi
  00033	52		 push	 edx
  00034	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 	p->ptr += n;
; 56   : 	return n;

  0003f	8b c6		 mov	 eax, esi
  00041	01 77 10	 add	 DWORD PTR [edi+16], esi
  00044	5e		 pop	 esi
  00045	5f		 pop	 edi

; 57   : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?r_string@@YAHPADHPAUWFILE@@@Z ENDP			; r_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z PROC	; _PyMarshal_ReadLongFromFile, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 391  : 	RFILE rf;
; 392  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 393  : 	return r_long(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00015	83 c4 04	 add	 esp, 4

; 394  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadLongFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_buf$1 = -16388						; size = 16384
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadLastObjectFromFile, COMDAT

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 40 00 00	 mov	 eax, 16388		; 00004004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _fp$[ebp]

; 414  : 	/* 75% of 2.1's .pyc files can exploit SMALL_FILE_LIMIT.
; 415  : 	 * REASONABLE_FILE_LIMIT is by defn something big enough for Tkinter.pyc.
; 416  : 	 */
; 417  : #define SMALL_FILE_LIMIT (1L << 14)
; 418  : #define REASONABLE_FILE_LIMIT (1L << 18)
; 419  : 
; 420  : 	off_t filesize;
; 421  : 
; 422  : 	if (PyErr_Occurred())

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  00021	85 c0		 test	 eax, eax
  00023	74 29		 je	 SHORT $LN2@PyMarshal_

; 423  : 	{
; 424  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  0002a	6a 02		 push	 2
  0002c	e8 00 00 00 00	 call	 ___acrt_iob_func
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _fprintf
  0003a	83 c4 08	 add	 esp, 8

; 425  : 		return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	5b		 pop	 ebx

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN2@PyMarshal_:
  0004e	56		 push	 esi
  0004f	57		 push	 edi

; 426  : 	}
; 427  : 
; 428  : 	filesize = getfilesize(fp);

  00050	53		 push	 ebx
  00051	e8 00 00 00 00	 call	 ?getfilesize@@YAJPAU_iobuf@@@Z ; getfilesize
  00056	8b f0		 mov	 esi, eax
  00058	83 c4 04	 add	 esp, 4

; 429  : 	if (filesize > 0) {

  0005b	85 f6		 test	 esi, esi
  0005d	0f 8e 92 00 00
	00		 jle	 $LN7@PyMarshal_

; 430  : 		char buf[SMALL_FILE_LIMIT];
; 431  : 		char* pBuf = NULL;
; 432  : 		if (filesize <= SMALL_FILE_LIMIT)

  00063	81 fe 00 40 00
	00		 cmp	 esi, 16384		; 00004000H
  00069	7f 2e		 jg	 SHORT $LN4@PyMarshal_

; 433  : 			pBuf = buf;

  0006b	53		 push	 ebx
  0006c	56		 push	 esi
  0006d	8d bd fc bf ff
	ff		 lea	 edi, DWORD PTR _buf$1[ebp]
  00073	6a 01		 push	 1
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 _fread
  0007b	50		 push	 eax
  0007c	57		 push	 edi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyMarshal_ReadObjectFromString
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	8b f0		 mov	 esi, eax
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN4@PyMarshal_:

; 434  : 		else if (filesize <= REASONABLE_FILE_LIMIT)

  00099	81 fe 00 00 04
	00		 cmp	 esi, 262144		; 00040000H
  0009f	7f 54		 jg	 SHORT $LN7@PyMarshal_

; 435  : 			pBuf = (char *)PyMem_MALLOC(filesize);

  000a1	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  000a7	77 4c		 ja	 SHORT $LN7@PyMarshal_
  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 _malloc
  000af	8b f8		 mov	 edi, eax
  000b1	83 c4 04	 add	 esp, 4

; 436  : 		if (pBuf != NULL) {

  000b4	85 ff		 test	 edi, edi
  000b6	74 3d		 je	 SHORT $LN7@PyMarshal_

; 437  : 			PyObject* v;
; 438  : 			size_t n = fread(pBuf, 1, filesize, fp);

  000b8	53		 push	 ebx
  000b9	56		 push	 esi
  000ba	6a 01		 push	 1
  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 _fread

; 439  : 			v = PyMarshal_ReadObjectFromString(pBuf, n);

  000c2	50		 push	 eax
  000c3	57		 push	 edi
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyMarshal_ReadObjectFromString
  000ca	8b f0		 mov	 esi, eax
  000cc	83 c4 18	 add	 esp, 24			; 00000018H

; 440  : 			if (pBuf != buf)

  000cf	8d 85 fc bf ff
	ff		 lea	 eax, DWORD PTR _buf$1[ebp]
  000d5	3b f8		 cmp	 edi, eax
  000d7	74 09		 je	 SHORT $LN8@PyMarshal_

; 441  : 				PyMem_FREE(pBuf);

  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 _free
  000df	83 c4 04	 add	 esp, 4
$LN8@PyMarshal_:

; 442  : 			return v;

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN7@PyMarshal_:

; 443  : 		}
; 444  : 
; 445  : 	}
; 446  : 
; 447  : 	/* We don't have fstat, or we do but the file is larger than
; 448  : 	 * REASONABLE_FILE_LIMIT or malloc failed -- read a byte at a time.
; 449  : 	 */
; 450  : 	return _PyMarshal_ReadObjectFromFile(fp);

  000f5	53		 push	 ebx
  000f6	e8 00 00 00 00	 call	 ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	83 c4 04	 add	 esp, 4
  00101	33 cd		 xor	 ecx, ebp
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadLastObjectFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadObjectFromFile, COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 457  : 	RFILE rf;
; 458  : 	if (PyErr_Occurred()) {

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN2@PyMarshal_

; 459  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	83 c4 04	 add	 esp, 4
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 08	 add	 esp, 8

; 460  : 		return NULL;

  00028	33 c0		 xor	 eax, eax

; 464  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@PyMarshal_:

; 461  : 	}
; 462  : 	rf.fp = fp;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 463  : 	return r_object(&rf);

  00034	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0003d	83 c4 04	 add	 esp, 4

; 464  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadObjectFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;
; 842  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
