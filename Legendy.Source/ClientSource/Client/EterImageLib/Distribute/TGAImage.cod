; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_printf
PUBLIC	??0CTGAImage@@QAE@XZ				; CTGAImage::CTGAImage
PUBLIC	??0CTGAImage@@QAE@AAVCImage@@@Z			; CTGAImage::CTGAImage
PUBLIC	??1CTGAImage@@UAE@XZ				; CTGAImage::~CTGAImage
PUBLIC	?Create@CTGAImage@@UAEXHH@Z			; CTGAImage::Create
PUBLIC	?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z		; CTGAImage::LoadFromMemory
PUBLIC	?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z		; CTGAImage::LoadFromDiskFile
PUBLIC	?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z		; CTGAImage::SaveToDiskFile
PUBLIC	?SetCompressed@CTGAImage@@QAEX_N@Z		; CTGAImage::SetCompressed
PUBLIC	?SetAlphaChannel@CTGAImage@@QAEX_N@Z		; CTGAImage::SetAlphaChannel
PUBLIC	?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ	; CTGAImage::GetHeader
PUBLIC	?GetRawPixelCount@CTGAImage@@IAEHPBK@Z		; CTGAImage::GetRawPixelCount
PUBLIC	?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z		; CTGAImage::GetRLEPixelCount
PUBLIC	??_GCTGAImage@@UAEPAXI@Z			; CTGAImage::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7CTGAImage@@6B@				; CTGAImage::`vftable'
PUBLIC	??_C@_0N@HGIAMHNL@RLE?5overflow@		; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_R4CTGAImage@@6B@				; CTGAImage::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTGAImage@@@8				; CTGAImage `RTTI Type Descriptor'
PUBLIC	??_R3CTGAImage@@8				; CTGAImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTGAImage@@8				; CTGAImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTGAImage@@8			; CTGAImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CImage@@8				; CImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCImage@@@8				; CImage `RTTI Type Descriptor'
PUBLIC	??_R3CImage@@8					; CImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CImage@@8					; CImage::`RTTI Base Class Array'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fputc:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	??0CImage@@QAE@XZ:PROC				; CImage::CImage
EXTRN	??1CImage@@UAE@XZ:PROC				; CImage::~CImage
EXTRN	?Create@CImage@@QAEXHH@Z:PROC			; CImage::Create
EXTRN	?GetWidth@CImage@@QBEHXZ:PROC			; CImage::GetWidth
EXTRN	?GetHeight@CImage@@QBEHXZ:PROC			; CImage::GetHeight
EXTRN	?GetBasePointer@CImage@@QAEPAKXZ:PROC		; CImage::GetBasePointer
EXTRN	?FlipTopToBottom@CImage@@QAEXXZ:PROC		; CImage::FlipTopToBottom
EXTRN	??_ECTGAImage@@UAEPAXI@Z:PROC			; CTGAImage::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R2CImage@@8
rdata$r	SEGMENT
??_R2CImage@@8 DD FLAT:??_R1A@?0A@EA@CImage@@8		; CImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CImage@@8
rdata$r	SEGMENT
??_R3CImage@@8 DD 00H					; CImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCImage@@@8
data$r	SEGMENT
??_R0?AVCImage@@@8 DD FLAT:??_7type_info@@6B@		; CImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCImage@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CImage@@8 DD FLAT:??_R0?AVCImage@@@8	; CImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTGAImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTGAImage@@8 DD FLAT:??_R0?AVCTGAImage@@@8 ; CTGAImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTGAImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CTGAImage@@8
rdata$r	SEGMENT
??_R2CTGAImage@@8 DD FLAT:??_R1A@?0A@EA@CTGAImage@@8	; CTGAImage::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CImage@@8
rdata$r	ENDS
;	COMDAT ??_R3CTGAImage@@8
rdata$r	SEGMENT
??_R3CTGAImage@@8 DD 00H				; CTGAImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CTGAImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTGAImage@@@8
data$r	SEGMENT
??_R0?AVCTGAImage@@@8 DD FLAT:??_7type_info@@6B@	; CTGAImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTGAImage@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTGAImage@@6B@
rdata$r	SEGMENT
??_R4CTGAImage@@6B@ DD 00H				; CTGAImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTGAImage@@@8
	DD	FLAT:??_R3CTGAImage@@8
rdata$r	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGIAMHNL@RLE?5overflow@
CONST	SEGMENT
??_C@_0N@HGIAMHNL@RLE?5overflow@ DB 'RLE overflow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CTGAImage@@6B@
CONST	SEGMENT
??_7CTGAImage@@6B@ DD FLAT:??_R4CTGAImage@@6B@		; CTGAImage::`vftable'
	DD	FLAT:??_ECTGAImage@@UAEPAXI@Z
	DD	FLAT:?Create@CTGAImage@@UAEXHH@Z
	DD	FLAT:?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z
	DD	FLAT:?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
	DD	FLAT:?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z$0
__ehfuncinfo$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTGAImage@@QAE@AAVCImage@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTGAImage@@QAE@AAVCImage@@@Z$0
__ehfuncinfo$??0CTGAImage@@QAE@AAVCImage@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CTGAImage@@QAE@AAVCImage@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCTGAImage@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTGAImage@@UAEPAXI@Z PROC				; CTGAImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CTGAImage@@UAE@XZ	; CTGAImage::~CTGAImage
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCTGAImage@@UAEPAXI@Z ENDP				; CTGAImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z PROC		; CTGAImage::GetRLEPixelCount, COMDAT
; _this$ = ecx

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 250  :     int r = 0;
; 251  : 	DWORD pixel;
; 252  : 
; 253  :     r = 1;
; 254  : 
; 255  :     if (data >= m_pdwEndPtr)

  00003	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0000e	3b c1		 cmp	 eax, ecx
  00010	72 06		 jb	 SHORT $LN4@GetRLEPixe

; 256  :         return 0;

  00012	33 c0		 xor	 eax, eax

; 269  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN4@GetRLEPixe:
  00018	56		 push	 esi

; 257  : 
; 258  : 	pixel = *data;

  00019	8b 30		 mov	 esi, DWORD PTR [eax]
  0001b	0f 1f 44 00 00	 npad	 5
$LL2@GetRLEPixe:

; 259  : 
; 260  :     while ((r < 127) && (data < m_pdwEndPtr))

  00020	3b c1		 cmp	 eax, ecx
  00022	73 0d		 jae	 SHORT $LN3@GetRLEPixe

; 261  :     {
; 262  : 		if (pixel != *(++data))

  00024	83 c0 04	 add	 eax, 4
  00027	3b 30		 cmp	 esi, DWORD PTR [eax]
  00029	75 06		 jne	 SHORT $LN3@GetRLEPixe

; 263  : 			return r;
; 264  : 
; 265  :         r++;

  0002b	42		 inc	 edx
  0002c	83 fa 7f	 cmp	 edx, 127		; 0000007fH
  0002f	7c ef		 jl	 SHORT $LL2@GetRLEPixe
$LN3@GetRLEPixe:

; 266  :     }
; 267  : 
; 268  : 	return r;

  00031	8b c2		 mov	 eax, edx
  00033	5e		 pop	 esi

; 269  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z ENDP		; CTGAImage::GetRLEPixelCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?GetRawPixelCount@CTGAImage@@IAEHPBK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_data$ = 8						; size = 4
?GetRawPixelCount@CTGAImage@@IAEHPBK@Z PROC		; CTGAImage::GetRawPixelCount, COMDAT
; _this$ = ecx

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b c1		 mov	 eax, ecx
  00007	56		 push	 esi

; 273  :     int i = 0;
; 274  : 
; 275  :     if (data >= m_pdwEndPtr)

  00008	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  0000b	57		 push	 edi
  0000c	8b 58 40	 mov	 ebx, DWORD PTR [eax+64]
  0000f	33 ff		 xor	 edi, edi
  00011	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  00014	3b f3		 cmp	 esi, ebx
  00016	72 0b		 jb	 SHORT $LL2@GetRawPixe

; 290  : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	33 c0		 xor	 eax, eax
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LL2@GetRawPixe:

; 276  :         return 0;
; 277  : 
; 278  :     while ((data < m_pdwEndPtr) && (i < 127))

  00023	83 ff 7f	 cmp	 edi, 127		; 0000007fH
  00026	7d 18		 jge	 SHORT $LN8@GetRawPixe

; 279  :     {
; 280  : 		int rle = GetRLEPixelCount(data);

  00028	56		 push	 esi
  00029	8b c8		 mov	 ecx, eax
  0002b	e8 00 00 00 00	 call	 ?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z ; CTGAImage::GetRLEPixelCount

; 281  : 
; 282  : 		if (rle >= 4)

  00030	83 f8 04	 cmp	 eax, 4
  00033	7d 0b		 jge	 SHORT $LN8@GetRawPixe

; 283  : 			break;
; 284  : 
; 285  :         data++;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00038	83 c6 04	 add	 esi, 4

; 286  :         i++;

  0003b	47		 inc	 edi
  0003c	3b f3		 cmp	 esi, ebx
  0003e	72 e3		 jb	 SHORT $LL2@GetRawPixe
$LN8@GetRawPixe:

; 287  :     }
; 288  : 
; 289  :     return i;

  00040	8b c7		 mov	 eax, edi
  00042	5f		 pop	 edi

; 290  : }

  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?GetRawPixelCount@CTGAImage@@IAEHPBK@Z ENDP		; CTGAImage::GetRawPixelCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ
_TEXT	SEGMENT
?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ PROC		; CTGAImage::GetHeader, COMDAT
; _this$ = ecx

; 362  : 	return m_Header;

  00000	8d 41 28	 lea	 eax, DWORD PTR [ecx+40]

; 363  : }

  00003	c3		 ret	 0
?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ ENDP		; CTGAImage::GetHeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?SetAlphaChannel@CTGAImage@@QAEX_N@Z
_TEXT	SEGMENT
_isExist$ = 8						; size = 1
?SetAlphaChannel@CTGAImage@@QAEX_N@Z PROC		; CTGAImage::SetAlphaChannel, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 51 39	 mov	 dl, BYTE PTR [ecx+57]

; 302  : 	if (isExist)
; 303  : 		m_Header.desc |= 0x08;
; 304  : 	else
; 305  : 		m_Header.desc &= ~0x08;
; 306  : }

  00006	8a c2		 mov	 al, dl
  00008	80 ca 08	 or	 dl, 8
  0000b	24 f7		 and	 al, -9			; fffffff7H
  0000d	0f b6 d2	 movzx	 edx, dl
  00010	80 7d 08 00	 cmp	 BYTE PTR _isExist$[ebp], 0
  00014	0f b6 c0	 movzx	 eax, al
  00017	0f 44 d0	 cmove	 edx, eax
  0001a	88 51 39	 mov	 BYTE PTR [ecx+57], dl
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetAlphaChannel@CTGAImage@@QAEX_N@Z ENDP		; CTGAImage::SetAlphaChannel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?SetCompressed@CTGAImage@@QAEX_N@Z
_TEXT	SEGMENT
_isCompress$ = 8					; size = 1
?SetCompressed@CTGAImage@@QAEX_N@Z PROC			; CTGAImage::SetCompressed, COMDAT
; _this$ = ecx

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  : 	if (isCompress)
; 295  : 		m_Header.imgType = 10;
; 296  : 	else
; 297  : 		m_Header.imgType = 2;
; 298  : }

  00003	8a 45 08	 mov	 al, BYTE PTR _isCompress$[ebp]
  00006	c0 e0 03	 shl	 al, 3
  00009	04 02		 add	 al, 2
  0000b	88 41 2a	 mov	 BYTE PTR [ecx+42], al
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?SetCompressed@CTGAImage@@QAEX_N@Z ENDP			; CTGAImage::SetCompressed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_rle$1$ = 8						; size = 4
_c_szFileName$ = 8					; size = 4
?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z PROC		; CTGAImage::SaveToDiskFile, COMDAT
; _this$ = ecx

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 310  : 	FILE * fp = fopen(c_szFileName, "wb");

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0000b	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0000e	8b f9		 mov	 edi, ecx
  00010	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi
  00013	e8 00 00 00 00	 call	 _fopen
  00018	8b d8		 mov	 ebx, eax
  0001a	83 c4 08	 add	 esp, 8

; 311  : 
; 312  : 	if (!fp)

  0001d	85 db		 test	 ebx, ebx
  0001f	75 0a		 jne	 SHORT $LN6@SaveToDisk

; 313  : 		return false;

  00021	5f		 pop	 edi
  00022	32 c0		 xor	 al, al

; 358  : }

  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN6@SaveToDisk:
  0002b	56		 push	 esi

; 314  : 
; 315  : 	fwrite(&m_Header, 18, 1, fp);

  0002c	53		 push	 ebx
  0002d	6a 01		 push	 1
  0002f	8d 47 28	 lea	 eax, DWORD PTR [edi+40]
  00032	6a 12		 push	 18			; 00000012H
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _fwrite
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 316  : 
; 317  : 	if (m_Header.imgType == 10)

  0003d	8b cf		 mov	 ecx, edi
  0003f	80 7f 2a 0a	 cmp	 BYTE PTR [edi+42], 10	; 0000000aH
  00043	0f 85 9c 00 00
	00		 jne	 $LN7@SaveToDisk

; 318  : 	{
; 319  : 		DWORD * data = GetBasePointer();

  00049	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  0004e	8b f0		 mov	 esi, eax

; 320  : 
; 321  : 		while (data < m_pdwEndPtr)

  00050	3b 77 40	 cmp	 esi, DWORD PTR [edi+64]
  00053	0f 83 b4 00 00
	00		 jae	 $LN8@SaveToDisk
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@SaveToDisk:

; 322  : 		{
; 323  : 			int rle = GetRLEPixelCount(data);

  00060	56		 push	 esi
  00061	8b cf		 mov	 ecx, edi
  00063	e8 00 00 00 00	 call	 ?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z ; CTGAImage::GetRLEPixelCount
  00068	89 45 08	 mov	 DWORD PTR _rle$1$[ebp], eax

; 324  : 
; 325  : 			if (rle < 4)

  0006b	83 f8 04	 cmp	 eax, 4
  0006e	7d 3b		 jge	 SHORT $LN9@SaveToDisk

; 326  : 			{
; 327  : 				int raw = GetRawPixelCount(data);

  00070	56		 push	 esi
  00071	8b cf		 mov	 ecx, edi
  00073	e8 00 00 00 00	 call	 ?GetRawPixelCount@CTGAImage@@IAEHPBK@Z ; CTGAImage::GetRawPixelCount
  00078	8b f8		 mov	 edi, eax

; 328  : 
; 329  : 				if (raw == 0)

  0007a	85 ff		 test	 edi, edi
  0007c	0f 84 8b 00 00
	00		 je	 $LN8@SaveToDisk

; 330  : 					break;
; 331  : 
; 332  : 				fputc(raw - 1, fp);

  00082	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  00085	53		 push	 ebx
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 _fputc
  0008c	83 c4 08	 add	 esp, 8
  0008f	90		 npad	 1
$LL4@SaveToDisk:

; 333  : 
; 334  : 				while (raw)
; 335  : 				{
; 336  : 					fwrite(data, sizeof(DWORD), 1, fp);

  00090	53		 push	 ebx
  00091	6a 01		 push	 1
  00093	6a 04		 push	 4
  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 _fwrite
  0009b	83 c4 10	 add	 esp, 16			; 00000010H

; 337  : 					data++;

  0009e	83 c6 04	 add	 esi, 4

; 338  : 					raw--;

  000a1	83 ef 01	 sub	 edi, 1
  000a4	75 ea		 jne	 SHORT $LL4@SaveToDisk

; 339  : 				}
; 340  : 			}

  000a6	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  000a9	eb 21		 jmp	 SHORT $LN10@SaveToDisk
$LN9@SaveToDisk:

; 341  : 			else
; 342  : 			{
; 343  : 				fputc((rle - 1) | 0x80, fp);

  000ab	48		 dec	 eax
  000ac	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  000b1	53		 push	 ebx
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _fputc

; 344  : 				fwrite(data, sizeof(DWORD), 1, fp);

  000b8	53		 push	 ebx
  000b9	6a 01		 push	 1
  000bb	6a 04		 push	 4
  000bd	56		 push	 esi
  000be	e8 00 00 00 00	 call	 _fwrite

; 345  : 				data += rle;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _rle$1$[ebp]
  000c6	83 c4 18	 add	 esp, 24			; 00000018H
  000c9	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
$LN10@SaveToDisk:

; 320  : 
; 321  : 		while (data < m_pdwEndPtr)

  000cc	3b 77 40	 cmp	 esi, DWORD PTR [edi+64]
  000cf	72 8f		 jb	 SHORT $LL2@SaveToDisk

; 354  : 	}
; 355  : 
; 356  : 	fclose(fp);

  000d1	53		 push	 ebx
  000d2	e8 00 00 00 00	 call	 _fclose
  000d7	83 c4 04	 add	 esp, 4

; 357  : 	return true;

  000da	b0 01		 mov	 al, 1
  000dc	5e		 pop	 esi
  000dd	5f		 pop	 edi

; 358  : }

  000de	5b		 pop	 ebx
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c2 04 00	 ret	 4
$LN7@SaveToDisk:

; 346  : 			}
; 347  : 		}
; 348  : 	}
; 349  : 	else
; 350  : 	{
; 351  : 		int size = GetWidth();

  000e5	e8 00 00 00 00	 call	 ?GetWidth@CImage@@QBEHXZ ; CImage::GetWidth

; 352  : 		size *= GetHeight() * 4;

  000ea	8b cf		 mov	 ecx, edi
  000ec	8b f0		 mov	 esi, eax
  000ee	e8 00 00 00 00	 call	 ?GetHeight@CImage@@QBEHXZ ; CImage::GetHeight
  000f3	0f af c6	 imul	 eax, esi

; 353  : 		fwrite(GetBasePointer(), size, 1, fp);

  000f6	8b cf		 mov	 ecx, edi
  000f8	53		 push	 ebx
  000f9	6a 01		 push	 1
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _fwrite
  0010a	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@SaveToDisk:

; 354  : 	}
; 355  : 
; 356  : 	fclose(fp);

  0010d	53		 push	 ebx
  0010e	e8 00 00 00 00	 call	 _fclose
  00113	83 c4 04	 add	 esp, 4

; 357  : 	return true;

  00116	b0 01		 mov	 al, 1
  00118	5e		 pop	 esi
  00119	5f		 pop	 edi

; 358  : }

  0011a	5b		 pop	 ebx
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 04 00	 ret	 4
?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z ENDP		; CTGAImage::SaveToDiskFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
_TEXT	SEGMENT
_c_pbMap$ = -344					; size = 4
_file$ = -340						; size = 324
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z PROC		; CTGAImage::LoadFromDiskFile, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f9		 mov	 edi, ecx
  00030	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]

; 238  : 	CMappedFile file;

  00033	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00039	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 239  : 
; 240  : 	const BYTE * c_pbMap;
; 241  : 
; 242  : 	if (!file.Create(c_szFileName, (const void **) &c_pbMap, 0, 0))

  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _c_pbMap$[ebp]
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	50		 push	 eax
  00050	56		 push	 esi
  00051	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00057	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  0005c	85 c0		 test	 eax, eax
  0005e	75 04		 jne	 SHORT $LN2@LoadFromDi
  00060	32 db		 xor	 bl, bl
  00062	eb 1d		 jmp	 SHORT $LN5@LoadFromDi
$LN2@LoadFromDi:

; 243  : 		return false;
; 244  : 
; 245  : 	return LoadFromMemory(file.Size(), c_pbMap);

  00064	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _c_pbMap$[ebp]
  0006a	8b 37		 mov	 esi, DWORD PTR [edi]
  0006c	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00072	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  00077	50		 push	 eax
  00078	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007b	8b cf		 mov	 ecx, edi
  0007d	ff d0		 call	 eax
  0007f	8a d8		 mov	 bl, al
$LN5@LoadFromDi:
  00081	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00087	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0008c	8a c3		 mov	 al, bl

; 246  : }

  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00091	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00098	59		 pop	 ecx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z$0:
  00000	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z ENDP		; CTGAImage::LoadFromDiskFile
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_pdwDest$1$ = -12					; size = 4
_hxw$1$ = -8						; size = 4
tv796 = -4						; size = 4
_i$5$ = 8						; size = 4
_i$4$ = 8						; size = 4
_iSize$ = 8						; size = 4
_r$4$ = 11						; size = 1
_g$2$ = 11						; size = 1
tv798 = 12						; size = 4
_c_pbMem$ = 12						; size = 4
_g$4$ = 15						; size = 1
?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z PROC		; CTGAImage::LoadFromMemory, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 43   : 	memcpy(&m_Header, c_pbMem, 18);
; 44   : 	c_pbMem += 18;
; 45   : 	iSize -= 18;

  00006	83 6d 08 12	 sub	 DWORD PTR _iSize$[ebp], 18 ; 00000012H
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _c_pbMem$[ebp]
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	89 7d f0	 mov	 DWORD PTR _this$1$[ebp], edi
  00015	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00018	0f 11 47 28	 movups	 XMMWORD PTR [edi+40], xmm0
  0001c	66 8b 46 10	 mov	 ax, WORD PTR [esi+16]
  00020	83 c6 12	 add	 esi, 18			; 00000012H
  00023	66 89 47 38	 mov	 WORD PTR [edi+56], ax

; 46   : 
; 47   : 	CImage::Create(m_Header.width, m_Header.height);

  00027	0f b7 47 36	 movzx	 eax, WORD PTR [edi+54]
  0002b	50		 push	 eax
  0002c	0f b7 47 34	 movzx	 eax, WORD PTR [edi+52]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?Create@CImage@@QAEXHH@Z ; CImage::Create

; 48   : 
; 49   : 	UINT hxw = m_Header.width * m_Header.height;

  00036	0f b7 5f 36	 movzx	 ebx, WORD PTR [edi+54]

; 50   : 	BYTE r, g, b, a;
; 51   : 	DWORD i;
; 52   : 
; 53   : 	DWORD * pdwDest = GetBasePointer();

  0003a	8b cf		 mov	 ecx, edi
  0003c	0f b7 47 34	 movzx	 eax, WORD PTR [edi+52]
  00040	0f af d8	 imul	 ebx, eax
  00043	89 5d f8	 mov	 DWORD PTR _hxw$1$[ebp], ebx
  00046	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer

; 54   : 
; 55   : 	switch (m_Header.imgType)

  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0004e	8b f8		 mov	 edi, eax
  00050	89 7d f4	 mov	 DWORD PTR _pdwDest$1$[ebp], edi
  00053	0f be 41 2a	 movsx	 eax, BYTE PTR [ecx+42]
  00057	83 e8 02	 sub	 eax, 2
  0005a	0f 84 09 02 00
	00		 je	 $LN26@LoadFromMe
  00060	83 e8 01	 sub	 eax, 1
  00063	0f 84 d0 01 00
	00		 je	 $LN25@LoadFromMe
  00069	83 e8 07	 sub	 eax, 7
  0006c	0f 85 be 02 00
	00		 jne	 $LN31@LoadFromMe

; 109  : 					c_pbMem += size;
; 110  : 					iSize -= size;
; 111  : 				}
; 112  : 			}
; 113  : 			break;
; 114  : 
; 115  : 		case 10:
; 116  : 			{
; 117  : 				BYTE rle;
; 118  : 
; 119  : 				if (m_Header.colorBits == 24)

  00072	8a 41 38	 mov	 al, BYTE PTR [ecx+56]
  00075	3c 18		 cmp	 al, 24			; 00000018H
  00077	0f 85 cb 00 00
	00		 jne	 $LN33@LoadFromMe

; 120  : 				{
; 121  : 					i = 0;

  0007d	33 ff		 xor	 edi, edi

; 122  : 					while (i < hxw)

  0007f	85 db		 test	 ebx, ebx
  00081	0f 84 a9 02 00
	00		 je	 $LN31@LoadFromMe
  00087	8b 55 08	 mov	 edx, DWORD PTR _iSize$[ebp]
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL13@LoadFromMe:

; 123  : 					{
; 124  : 						rle = (BYTE) *(c_pbMem++); --iSize;

  00090	8a 2e		 mov	 ch, BYTE PTR [esi]
  00092	8b c6		 mov	 eax, esi
  00094	46		 inc	 esi
  00095	4a		 dec	 edx

; 125  : 
; 126  : 						if (rle < 0x80)

  00096	80 fd 80	 cmp	 ch, 128			; 00000080H
  00099	73 4f		 jae	 SHORT $LN35@LoadFromMe

; 127  : 						{
; 128  : 							rle++;

  0009b	80 c5 01	 add	 ch, 1

; 129  : 
; 130  : 							while (rle)

  0009e	0f 84 97 00 00
	00		 je	 $LN18@LoadFromMe
$LL15@LoadFromMe:

; 131  : 							{
; 132  : 								b = (BYTE) *(c_pbMem++); --iSize;
; 133  : 								g = (BYTE) *(c_pbMem++); --iSize;
; 134  : 								r = (BYTE) *(c_pbMem++); --iSize;

  000a4	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000a7	83 ea 03	 sub	 edx, 3
  000aa	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  000ad	8a 1e		 mov	 bl, BYTE PTR [esi]
  000af	83 c6 03	 add	 esi, 3
  000b2	89 55 08	 mov	 DWORD PTR _iSize$[ebp], edx

; 135  : 								a = 0xff;
; 136  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  000b5	0f b6 d0	 movzx	 edx, al
  000b8	81 ca 00 ff ff
	ff		 or	 edx, -256		; ffffff00H
  000be	0f b6 c1	 movzx	 eax, cl
  000c1	c1 e2 08	 shl	 edx, 8
  000c4	0b d0		 or	 edx, eax
  000c6	0f b6 c3	 movzx	 eax, bl

; 137  : 
; 138  : 								if (i > hxw)

  000c9	8b 5d f8	 mov	 ebx, DWORD PTR _hxw$1$[ebp]
  000cc	c1 e2 08	 shl	 edx, 8
  000cf	0b d0		 or	 edx, eax
  000d1	8b 45 f4	 mov	 eax, DWORD PTR _pdwDest$1$[ebp]
  000d4	89 14 b8	 mov	 DWORD PTR [eax+edi*4], edx
  000d7	47		 inc	 edi
  000d8	3b fb		 cmp	 edi, ebx
  000da	0f 87 41 01 00
	00		 ja	 $LN58@LoadFromMe

; 139  : 								{
; 140  : 									assert(!"RLE overflow");
; 141  : 									printf("RLE overflow");
; 142  : 									return false;
; 143  : 								}
; 144  : 								--rle;

  000e0	8b 55 08	 mov	 edx, DWORD PTR _iSize$[ebp]
  000e3	80 c5 ff	 add	 ch, 255			; 000000ffH
  000e6	75 bc		 jne	 SHORT $LL15@LoadFromMe

; 145  : 							}
; 146  : 						}

  000e8	eb 51		 jmp	 SHORT $LN18@LoadFromMe
$LN35@LoadFromMe:

; 147  : 						else
; 148  : 						{
; 149  : 							rle -= 127;
; 150  : 
; 151  : 							b = (BYTE) *(c_pbMem++); --iSize;

  000ea	8a 0e		 mov	 cl, BYTE PTR [esi]

; 152  : 							g = (BYTE) *(c_pbMem++); --iSize;
; 153  : 							r = (BYTE) *(c_pbMem++); --iSize;

  000ec	83 ea 03	 sub	 edx, 3
  000ef	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  000f2	8a 06		 mov	 al, BYTE PTR [esi]
  000f4	88 45 0b	 mov	 BYTE PTR _g$2$[ebp], al
  000f7	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  000fa	83 c6 02	 add	 esi, 2
  000fd	80 c5 81	 add	 ch, 129			; 00000081H

; 154  : 							a = 0xff;
; 155  : 
; 156  : 							while (rle)

  00100	74 39		 je	 SHORT $LN18@LoadFromMe
  00102	0f b6 c0	 movzx	 eax, al
  00105	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0010a	c1 e0 08	 shl	 eax, 8
  0010d	89 45 0c	 mov	 DWORD PTR tv798[ebp], eax
  00110	0f b6 45 0b	 movzx	 eax, BYTE PTR _g$2$[ebp]
  00114	09 45 0c	 or	 DWORD PTR tv798[ebp], eax
  00117	c1 65 0c 08	 shl	 DWORD PTR tv798[ebp], 8
  0011b	0f b6 c1	 movzx	 eax, cl
  0011e	09 45 0c	 or	 DWORD PTR tv798[ebp], eax
  00121	8b 45 f4	 mov	 eax, DWORD PTR _pdwDest$1$[ebp]
$LL17@LoadFromMe:

; 157  : 							{
; 158  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  00124	8b 5d 0c	 mov	 ebx, DWORD PTR tv798[ebp]
  00127	89 1c b8	 mov	 DWORD PTR [eax+edi*4], ebx
  0012a	47		 inc	 edi

; 159  : 
; 160  : 								if (i > hxw)

  0012b	8b 5d f8	 mov	 ebx, DWORD PTR _hxw$1$[ebp]
  0012e	3b fb		 cmp	 edi, ebx
  00130	0f 87 eb 00 00
	00		 ja	 $LN58@LoadFromMe

; 161  : 								{
; 162  : 									assert(!"RLE overflow");
; 163  : 									printf("RLE overflow");
; 164  : 									return false;
; 165  : 								}
; 166  : 								--rle;

  00136	80 c5 ff	 add	 ch, 255			; 000000ffH
  00139	75 e9		 jne	 SHORT $LL17@LoadFromMe
$LN18@LoadFromMe:

; 122  : 					while (i < hxw)

  0013b	3b fb		 cmp	 edi, ebx
  0013d	0f 82 4d ff ff
	ff		 jb	 $LL13@LoadFromMe

; 211  : 
; 212  : 								if (i > hxw)

  00143	e9 e8 01 00 00	 jmp	 $LN31@LoadFromMe
$LN33@LoadFromMe:

; 167  : 							}
; 168  : 						}
; 169  : 					}
; 170  : 				}
; 171  : 				else if (m_Header.colorBits == 32)

  00148	3c 20		 cmp	 al, 32			; 00000020H
  0014a	0f 85 e0 01 00
	00		 jne	 $LN31@LoadFromMe

; 172  : 				{
; 173  : 					i = 0;

  00150	33 ff		 xor	 edi, edi

; 174  : 					while (i < hxw)

  00152	85 db		 test	 ebx, ebx
  00154	0f 84 d6 01 00
	00		 je	 $LN31@LoadFromMe
  0015a	8b 55 08	 mov	 edx, DWORD PTR _iSize$[ebp]
  0015d	8b cb		 mov	 ecx, ebx
  0015f	90		 npad	 1
$LL19@LoadFromMe:

; 175  : 					{
; 176  : 						rle = (BYTE) *(c_pbMem++); --iSize;

  00160	8a 3e		 mov	 bh, BYTE PTR [esi]
  00162	8b c6		 mov	 eax, esi
  00164	46		 inc	 esi
  00165	4a		 dec	 edx

; 177  : 
; 178  : 						if (rle < 0x80)

  00166	80 ff 80	 cmp	 bh, 128			; 00000080H
  00169	73 50		 jae	 SHORT $LN40@LoadFromMe

; 179  : 						{
; 180  : 							rle++;

  0016b	80 c7 01	 add	 bh, 1

; 181  : 
; 182  : 							while (rle)

  0016e	0f 84 a0 00 00
	00		 je	 $LN24@LoadFromMe
$LL21@LoadFromMe:

; 183  : 							{
; 184  : 								b = (BYTE) *(c_pbMem++); --iSize;
; 185  : 								g = (BYTE) *(c_pbMem++); --iSize;
; 186  : 								r = (BYTE) *(c_pbMem++); --iSize;
; 187  : 								a = (BYTE) *(c_pbMem++); --iSize;

  00174	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00177	83 ea 04	 sub	 edx, 4
  0017a	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  0017d	8a 5e 01	 mov	 bl, BYTE PTR [esi+1]
  00180	8a 2e		 mov	 ch, BYTE PTR [esi]
  00182	83 c6 04	 add	 esi, 4
  00185	89 55 08	 mov	 DWORD PTR _iSize$[ebp], edx

; 188  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  00188	0f b6 d0	 movzx	 edx, al
  0018b	c1 e2 08	 shl	 edx, 8
  0018e	0f b6 c1	 movzx	 eax, cl
  00191	0b d0		 or	 edx, eax
  00193	0f b6 c3	 movzx	 eax, bl
  00196	c1 e2 08	 shl	 edx, 8
  00199	0b d0		 or	 edx, eax
  0019b	0f b6 c5	 movzx	 eax, ch

; 189  : 
; 190  : 								if (i > hxw)

  0019e	8b 4d f8	 mov	 ecx, DWORD PTR _hxw$1$[ebp]
  001a1	c1 e2 08	 shl	 edx, 8
  001a4	0b d0		 or	 edx, eax
  001a6	8b 45 f4	 mov	 eax, DWORD PTR _pdwDest$1$[ebp]
  001a9	89 14 b8	 mov	 DWORD PTR [eax+edi*4], edx
  001ac	47		 inc	 edi
  001ad	3b f9		 cmp	 edi, ecx
  001af	77 70		 ja	 SHORT $LN58@LoadFromMe

; 191  : 								{
; 192  : 									assert(!"RLE overflow");
; 193  : 									printf("RLE overflow");
; 194  : 									return false;
; 195  : 								}
; 196  : 								--rle;

  001b1	8b 55 08	 mov	 edx, DWORD PTR _iSize$[ebp]
  001b4	80 c7 ff	 add	 bh, 255			; 000000ffH
  001b7	75 bb		 jne	 SHORT $LL21@LoadFromMe

; 197  : 							}
; 198  : 						}

  001b9	eb 59		 jmp	 SHORT $LN24@LoadFromMe
$LN40@LoadFromMe:

; 199  : 						else
; 200  : 						{
; 201  : 							rle -= 127;
; 202  : 
; 203  : 							b = (BYTE) *(c_pbMem++); --iSize;

  001bb	8a 1e		 mov	 bl, BYTE PTR [esi]

; 204  : 							g = (BYTE) *(c_pbMem++); --iSize;
; 205  : 							r = (BYTE) *(c_pbMem++); --iSize;
; 206  : 							a = (BYTE) *(c_pbMem++); --iSize;

  001bd	83 ea 04	 sub	 edx, 4
  001c0	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  001c3	8a 06		 mov	 al, BYTE PTR [esi]
  001c5	88 45 0f	 mov	 BYTE PTR _g$4$[ebp], al
  001c8	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  001cb	88 45 0b	 mov	 BYTE PTR _r$4$[ebp], al
  001ce	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  001d1	83 c6 03	 add	 esi, 3
  001d4	80 c7 81	 add	 bh, 129			; 00000081H

; 207  : 
; 208  : 							while (rle)

  001d7	74 3b		 je	 SHORT $LN24@LoadFromMe
  001d9	0f b6 c0	 movzx	 eax, al
  001dc	c1 e0 08	 shl	 eax, 8
  001df	89 45 fc	 mov	 DWORD PTR tv796[ebp], eax
  001e2	0f b6 45 0b	 movzx	 eax, BYTE PTR _r$4$[ebp]
  001e6	09 45 fc	 or	 DWORD PTR tv796[ebp], eax
  001e9	c1 65 fc 08	 shl	 DWORD PTR tv796[ebp], 8
  001ed	0f b6 45 0f	 movzx	 eax, BYTE PTR _g$4$[ebp]
  001f1	09 45 fc	 or	 DWORD PTR tv796[ebp], eax
  001f4	c1 65 fc 08	 shl	 DWORD PTR tv796[ebp], 8
  001f8	0f b6 c3	 movzx	 eax, bl
  001fb	09 45 fc	 or	 DWORD PTR tv796[ebp], eax
  001fe	8b 45 f4	 mov	 eax, DWORD PTR _pdwDest$1$[ebp]
$LL23@LoadFromMe:

; 209  : 							{
; 210  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  00201	8b 4d fc	 mov	 ecx, DWORD PTR tv796[ebp]
  00204	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
  00207	47		 inc	 edi

; 211  : 
; 212  : 								if (i > hxw)

  00208	8b 4d f8	 mov	 ecx, DWORD PTR _hxw$1$[ebp]
  0020b	3b f9		 cmp	 edi, ecx
  0020d	77 12		 ja	 SHORT $LN58@LoadFromMe

; 217  : 								}
; 218  : 
; 219  : 								--rle;

  0020f	80 c7 ff	 add	 bh, 255			; 000000ffH
  00212	75 ed		 jne	 SHORT $LL23@LoadFromMe
$LN24@LoadFromMe:

; 174  : 					while (i < hxw)

  00214	3b f9		 cmp	 edi, ecx
  00216	0f 82 44 ff ff
	ff		 jb	 $LL19@LoadFromMe
  0021c	e9 0f 01 00 00	 jmp	 $LN31@LoadFromMe
$LN58@LoadFromMe:

; 213  : 								{
; 214  : 									assert(!"RLE overflow");
; 215  : 									printf("RLE overflow");

  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HGIAMHNL@RLE?5overflow@
  00226	e8 00 00 00 00	 call	 _printf
  0022b	83 c4 04	 add	 esp, 4

; 216  : 									return false;

  0022e	32 c0		 xor	 al, al
  00230	5f		 pop	 edi

; 231  : 	}
; 232  : 
; 233  : 	return true;
; 234  : }

  00231	5e		 pop	 esi
  00232	5b		 pop	 ebx
  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	c2 08 00	 ret	 8
$LN25@LoadFromMe:

; 56   : 	{
; 57   : 		case 3:
; 58   : 			{
; 59   : 				for (i = 0; i < hxw; ++i)

  00239	33 d2		 xor	 edx, edx
  0023b	85 db		 test	 ebx, ebx
  0023d	0f 84 ed 00 00
	00		 je	 $LN31@LoadFromMe
$LL6@LoadFromMe:

; 60   : 				{
; 61   : 					a = (char) *(c_pbMem++);

  00243	8a 06		 mov	 al, BYTE PTR [esi]
  00245	8d 76 01	 lea	 esi, DWORD PTR [esi+1]

; 62   : 					pdwDest[i] = (a << 24) | (a << 16) | (a << 8) | a;

  00248	0f b6 c0	 movzx	 eax, al
  0024b	8b c8		 mov	 ecx, eax
  0024d	c1 e1 08	 shl	 ecx, 8
  00250	0b c8		 or	 ecx, eax
  00252	c1 e1 08	 shl	 ecx, 8
  00255	0b c8		 or	 ecx, eax
  00257	c1 e1 08	 shl	 ecx, 8
  0025a	0b c8		 or	 ecx, eax
  0025c	89 0c 97	 mov	 DWORD PTR [edi+edx*4], ecx
  0025f	42		 inc	 edx
  00260	3b d3		 cmp	 edx, ebx
  00262	72 df		 jb	 SHORT $LL6@LoadFromMe

; 63   : 				}
; 64   : 			}
; 65   : 			break;

  00264	e9 c7 00 00 00	 jmp	 $LN31@LoadFromMe
$LN26@LoadFromMe:

; 66   : 
; 67   : 		case 2:
; 68   : 			{
; 69   : 				if (m_Header.colorBits == 16)	// 16bit

  00269	8a 41 38	 mov	 al, BYTE PTR [ecx+56]
  0026c	3c 10		 cmp	 al, 16			; 00000010H
  0026e	75 54		 jne	 SHORT $LN27@LoadFromMe

; 70   : 				{
; 71   : 					for (i = 0; i < hxw; ++i)

  00270	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _i$4$[ebp], 0
  00277	85 db		 test	 ebx, ebx
  00279	0f 84 b1 00 00
	00		 je	 $LN31@LoadFromMe
  0027f	90		 npad	 1
$LL66@LoadFromMe:

; 72   : 					{
; 73   : 						WORD w;
; 74   : 
; 75   : 						memcpy(&w, c_pbMem, sizeof(WORD));

  00280	0f b7 16	 movzx	 edx, WORD PTR [esi]

; 76   : 						c_pbMem += sizeof(WORD);

  00283	8d 76 02	 lea	 esi, DWORD PTR [esi+2]

; 77   : 						iSize -= sizeof(WORD);
; 78   : 
; 79   : 						b = (BYTE) (w & 0x1F);
; 80   : 						g = (BYTE) ((w >> 5) & 0x1F);
; 81   : 						r = (BYTE) ((w >> 10) & 0x1F);

  00286	66 8b c2	 mov	 ax, dx
  00289	66 c1 e8 0a	 shr	 ax, 10			; 0000000aH

; 82   : 
; 83   : 						b <<= 3;
; 84   : 						g <<= 3;
; 85   : 						r <<= 3;

  0028d	c0 e0 03	 shl	 al, 3

; 86   : 						a = 0xff;
; 87   : 
; 88   : 						pdwDest[i] = (a << 24) | (r << 16) | (g << 8) | b;

  00290	0f b6 c8	 movzx	 ecx, al
  00293	8b c2		 mov	 eax, edx
  00295	c1 e8 05	 shr	 eax, 5
  00298	81 c9 00 ff ff
	ff		 or	 ecx, -256		; ffffff00H
  0029e	c0 e0 03	 shl	 al, 3
  002a1	c1 e1 08	 shl	 ecx, 8
  002a4	0f b6 c0	 movzx	 eax, al
  002a7	0b c8		 or	 ecx, eax
  002a9	c0 e2 03	 shl	 dl, 3
  002ac	c1 e1 08	 shl	 ecx, 8
  002af	0f b6 c2	 movzx	 eax, dl
  002b2	0b c8		 or	 ecx, eax
  002b4	8b 45 08	 mov	 eax, DWORD PTR _i$4$[ebp]
  002b7	89 0c 87	 mov	 DWORD PTR [edi+eax*4], ecx
  002ba	40		 inc	 eax
  002bb	89 45 08	 mov	 DWORD PTR _i$4$[ebp], eax
  002be	3b c3		 cmp	 eax, ebx
  002c0	72 be		 jb	 SHORT $LL66@LoadFromMe

; 89   : 					}
; 90   : 				}

  002c2	eb 6c		 jmp	 SHORT $LN31@LoadFromMe
$LN27@LoadFromMe:

; 91   : 				else if (m_Header.colorBits == 24)	// 24bit

  002c4	3c 18		 cmp	 al, 24			; 00000018H
  002c6	75 42		 jne	 SHORT $LN29@LoadFromMe

; 92   : 				{
; 93   : 					for (i = 0; i < hxw; ++i)

  002c8	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _i$5$[ebp], 0
  002cf	85 db		 test	 ebx, ebx
  002d1	74 5d		 je	 SHORT $LN31@LoadFromMe
$LL12@LoadFromMe:

; 94   : 					{
; 95   : 						r = (BYTE) *(c_pbMem++); --iSize;

  002d3	8a 06		 mov	 al, BYTE PTR [esi]

; 96   : 						g = (BYTE) *(c_pbMem++); --iSize;
; 97   : 						b = (BYTE) *(c_pbMem++); --iSize;

  002d5	8d 76 03	 lea	 esi, DWORD PTR [esi+3]
  002d8	8a 4e fe	 mov	 cl, BYTE PTR [esi-2]
  002db	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]

; 98   : 						a = 0xff;
; 99   : 
; 100  : 						pdwDest[i] = (a << 24) | (r << 16) | (g << 8) | b;

  002de	0f b6 f8	 movzx	 edi, al
  002e1	81 cf 00 ff ff
	ff		 or	 edi, -256		; ffffff00H
  002e7	0f b6 c1	 movzx	 eax, cl
  002ea	8b 4d 08	 mov	 ecx, DWORD PTR _i$5$[ebp]
  002ed	c1 e7 08	 shl	 edi, 8
  002f0	0b f8		 or	 edi, eax
  002f2	0f b6 c2	 movzx	 eax, dl
  002f5	c1 e7 08	 shl	 edi, 8
  002f8	0b f8		 or	 edi, eax
  002fa	8b 45 f4	 mov	 eax, DWORD PTR _pdwDest$1$[ebp]
  002fd	89 3c 88	 mov	 DWORD PTR [eax+ecx*4], edi
  00300	41		 inc	 ecx
  00301	89 4d 08	 mov	 DWORD PTR _i$5$[ebp], ecx
  00304	3b cb		 cmp	 ecx, ebx
  00306	72 cb		 jb	 SHORT $LL12@LoadFromMe

; 101  : 					}
; 102  : 				}

  00308	eb 26		 jmp	 SHORT $LN31@LoadFromMe
$LN29@LoadFromMe:

; 103  : 				else if (m_Header.colorBits == 32)	// 32bit

  0030a	3c 20		 cmp	 al, 32			; 00000020H
  0030c	75 22		 jne	 SHORT $LN31@LoadFromMe

; 104  : 				{
; 105  : 					int size = GetWidth();

  0030e	e8 00 00 00 00	 call	 ?GetWidth@CImage@@QBEHXZ ; CImage::GetWidth

; 106  : 					size *= GetHeight() * 4;

  00313	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00316	8b f8		 mov	 edi, eax
  00318	e8 00 00 00 00	 call	 ?GetHeight@CImage@@QBEHXZ ; CImage::GetHeight
  0031d	0f af c7	 imul	 eax, edi
  00320	c1 e0 02	 shl	 eax, 2

; 107  : 
; 108  : 					memcpy(pdwDest, c_pbMem, size);

  00323	50		 push	 eax
  00324	56		 push	 esi
  00325	ff 75 f4	 push	 DWORD PTR _pdwDest$1$[ebp]
  00328	e8 00 00 00 00	 call	 _memcpy
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@LoadFromMe:

; 220  : 							}
; 221  : 						}
; 222  : 					}
; 223  : 				}
; 224  : 			}
; 225  : 			break;
; 226  : 	}
; 227  : 
; 228  : 	if (!(m_Header.desc & 0x20))

  00330	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]
  00333	f6 40 39 20	 test	 BYTE PTR [eax+57], 32	; 00000020H
  00337	75 07		 jne	 SHORT $LN44@LoadFromMe

; 229  : 	{
; 230  : 		FlipTopToBottom();

  00339	8b c8		 mov	 ecx, eax
  0033b	e8 00 00 00 00	 call	 ?FlipTopToBottom@CImage@@QAEXXZ ; CImage::FlipTopToBottom
$LN44@LoadFromMe:

; 231  : 	}
; 232  : 
; 233  : 	return true;
; 234  : }

  00340	5f		 pop	 edi
  00341	5e		 pop	 esi
  00342	b0 01		 mov	 al, 1
  00344	5b		 pop	 ebx
  00345	8b e5		 mov	 esp, ebp
  00347	5d		 pop	 ebp
  00348	c2 08 00	 ret	 8
?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z ENDP		; CTGAImage::LoadFromMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ?Create@CTGAImage@@UAEXHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?Create@CTGAImage@@UAEXHH@Z PROC			; CTGAImage::Create, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	memset(&m_Header, 0, sizeof(m_Header));
; 31   : 
; 32   : 	m_Header.imgType	= 2;
; 33   : 	m_Header.width		= (short) width;

  00003	8b 55 08	 mov	 edx, DWORD PTR _width$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 34   : 	m_Header.height		= (short) height;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  0000c	0f 11 41 28	 movups	 XMMWORD PTR [ecx+40], xmm0
  00010	66 c7 41 38 00
	00		 mov	 WORD PTR [ecx+56], 0
  00016	c6 41 2a 02	 mov	 BYTE PTR [ecx+42], 2
  0001a	66 89 51 34	 mov	 WORD PTR [ecx+52], dx
  0001e	66 89 41 36	 mov	 WORD PTR [ecx+54], ax

; 35   : 	m_Header.colorBits	= 32;

  00022	66 c7 41 38 20
	08		 mov	 WORD PTR [ecx+56], 2080	; 00000820H

; 36   : 	m_Header.desc		= 0x08;
; 37   : 
; 38   : 	CImage::Create(width, height);

  00028	89 45 0c	 mov	 DWORD PTR _height$[ebp], eax
  0002b	89 55 08	 mov	 DWORD PTR _width$[ebp], edx

; 39   : }

  0002e	5d		 pop	 ebp

; 36   : 	m_Header.desc		= 0x08;
; 37   : 
; 38   : 	CImage::Create(width, height);

  0002f	e9 00 00 00 00	 jmp	 ?Create@CImage@@QAEXHH@Z ; CImage::Create
?Create@CTGAImage@@UAEXHH@Z ENDP			; CTGAImage::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ??1CTGAImage@@UAE@XZ
_TEXT	SEGMENT
??1CTGAImage@@UAE@XZ PROC				; CTGAImage::~CTGAImage, COMDAT
; _this$ = ecx

; 13   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CTGAImage@@6B@

; 14   : }

  00006	e9 00 00 00 00	 jmp	 ??1CImage@@UAE@XZ	; CImage::~CImage
??1CTGAImage@@UAE@XZ ENDP				; CTGAImage::~CTGAImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ??0CTGAImage@@QAE@AAVCImage@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_image$ = 8						; size = 4
??0CTGAImage@@QAE@AAVCImage@@@Z PROC			; CTGAImage::CTGAImage, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTGAImage@@QAE@AAVCImage@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b d9		 mov	 ebx, ecx
  00028	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
  0002b	e8 00 00 00 00	 call	 ??0CImage@@QAE@XZ	; CImage::CImage

; 18   : 	int w = image.GetWidth();

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _image$[ebp]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CTGAImage@@6B@
  00040	c7 43 3c 00 00
	00 00		 mov	 DWORD PTR [ebx+60], 0
  00047	e8 00 00 00 00	 call	 ?GetWidth@CImage@@QBEHXZ ; CImage::GetWidth

; 19   : 	int h = image.GetHeight();

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _image$[ebp]
  0004f	8b d8		 mov	 ebx, eax
  00051	e8 00 00 00 00	 call	 ?GetHeight@CImage@@QBEHXZ ; CImage::GetHeight

; 20   : 
; 21   : 	Create(w, h);

  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b f8		 mov	 edi, eax
  0005b	57		 push	 edi
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 ?Create@CTGAImage@@UAEXHH@Z ; CTGAImage::Create

; 22   : 
; 23   : 	DWORD * pdwDest = GetBasePointer();

  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer

; 24   : 	memcpy(pdwDest, image.GetBasePointer(), w * h * sizeof(DWORD));

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _image$[ebp]
  0006d	8b f0		 mov	 esi, eax
  0006f	0f af fb	 imul	 edi, ebx
  00072	c1 e7 02	 shl	 edi, 2
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  0007b	50		 push	 eax
  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 _memcpy

; 25   : 	FlipTopToBottom();

  00082	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	e8 00 00 00 00	 call	 ?FlipTopToBottom@CImage@@QAEXXZ ; CImage::FlipTopToBottom

; 26   : }

  0008d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTGAImage@@QAE@AAVCImage@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CImage@@UAE@XZ	; CImage::~CImage
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0CTGAImage@@QAE@AAVCImage@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTGAImage@@QAE@AAVCImage@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTGAImage@@QAE@AAVCImage@@@Z ENDP			; CTGAImage::CTGAImage
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\TGAImage.cpp
;	COMDAT ??0CTGAImage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTGAImage@@QAE@XZ PROC				; CTGAImage::CTGAImage, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	e8 00 00 00 00	 call	 ??0CImage@@QAE@XZ	; CImage::CImage
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CTGAImage@@6B@

; 10   : }

  00015	8b c6		 mov	 eax, esi
  00017	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  0001e	5e		 pop	 esi
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??0CTGAImage@@QAE@XZ ENDP				; CTGAImage::CTGAImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000e	83 c4 04	 add	 esp, 4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00014	51		 push	 ecx
  00015	6a 00		 push	 0
  00017	56		 push	 esi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;

  0002b	5e		 pop	 esi

; 961  :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
