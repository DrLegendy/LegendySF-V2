; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0CDXTCImage@@QAE@XZ				; CDXTCImage::CDXTCImage
PUBLIC	??1CDXTCImage@@UAE@XZ				; CDXTCImage::~CDXTCImage
PUBLIC	?Initialize@CDXTCImage@@QAEXXZ			; CDXTCImage::Initialize
PUBLIC	?Clear@CDXTCImage@@QAEXXZ			; CDXTCImage::Clear
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?LoadFromFile@CDXTCImage@@QAE_NPBD@Z		; CDXTCImage::LoadFromFile
PUBLIC	?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z		; CDXTCImage::LoadFromMemory
PUBLIC	?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z	; CDXTCImage::LoadHeaderFromMemory
PUBLIC	?Copy@CDXTCImage@@QAE_NHPAEJ@Z			; CDXTCImage::Copy
PUBLIC	?Decompress@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::Decompress
PUBLIC	?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT1
PUBLIC	?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT3
PUBLIC	?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT5
PUBLIC	?DecompressARGB@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressARGB
PUBLIC	?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat
PUBLIC	?Unextract@CDXTCImage@@QAEXPAEHHH@Z		; CDXTCImage::Unextract
PUBLIC	??_GCDXTCImage@@UAEPAXI@Z			; CDXTCImage::`scalar deleting destructor'
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7CDXTCImage@@6B@				; CDXTCImage::`vftable'
PUBLIC	??_C@_04LFFPHNGG@?4DDS@				; `string'
PUBLIC	??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ ; `string'
PUBLIC	??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_07FBMAHCAD@?9premul@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ ; `string'
PUBLIC	??_C@_04DHPPFAPI@DXT1@				; `string'
PUBLIC	??_C@_04BMNCADDL@DXT2@				; `string'
PUBLIC	??_C@_04FMJDCHK@DXT3@				; `string'
PUBLIC	??_C@_04EKIIKELN@DXT4@				; `string'
PUBLIC	??_C@_04FDJDJFPM@DXT5@				; `string'
PUBLIC	??_C@_0P@NBMDABNO@Format?5Unknown@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDXTCImage@@6B@				; CDXTCImage::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDXTCImage@@@8				; CDXTCImage `RTTI Type Descriptor'
PUBLIC	??_R3CDXTCImage@@8				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDXTCImage@@8				; CDXTCImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDXTCImage@@8			; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@00000006000000040000000200000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_strstr:PROC
EXTRN	_strncpy:PROC
EXTRN	__strupr:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	??_ECDXTCImage@@UAEPAXI@Z:PROC			; CDXTCImage::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
_BSS	SEGMENT
?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA DB 0105H DUP (?) ; `CDXTCImage::LoadFromFile'::`2'::fileupper
_BSS	ENDS
_BSS	SEGMENT
?gBits@@3PAY03EA DB 010H DUP (?)			; gBits
?gAlphas@@3PAGA DW 08H DUP (?)				; gAlphas
?gACol@@3PAY03UColor8888@@A DD 010H DUP (?)		; gACol
_BSS	ENDS
;	COMDAT __xmm@00000006000000040000000200000000
CONST	SEGMENT
__xmm@00000006000000040000000200000000 DB 00H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 04H, 00H, 00H, 00H, 06H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDXTCImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDXTCImage@@8 DD FLAT:??_R0?AVCDXTCImage@@@8 ; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CDXTCImage@@8
rdata$r	SEGMENT
??_R2CDXTCImage@@8 DD FLAT:??_R1A@?0A@EA@CDXTCImage@@8	; CDXTCImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDXTCImage@@8
rdata$r	SEGMENT
??_R3CDXTCImage@@8 DD 00H				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDXTCImage@@@8
data$r	SEGMENT
??_R0?AVCDXTCImage@@@8 DD FLAT:??_7type_info@@6B@	; CDXTCImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDXTCImage@@', 00H
data$r	ENDS
;	COMDAT ??_R4CDXTCImage@@6B@
rdata$r	SEGMENT
??_R4CDXTCImage@@6B@ DD 00H				; CDXTCImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDXTCImage@@@8
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBMDABNO@Format?5Unknown@
CONST	SEGMENT
??_C@_0P@NBMDABNO@Format?5Unknown@ DB 'Format Unknown', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FDJDJFPM@DXT5@
CONST	SEGMENT
??_C@_04FDJDJFPM@DXT5@ DB 'DXT5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKIIKELN@DXT4@
CONST	SEGMENT
??_C@_04EKIIKELN@DXT4@ DB 'DXT4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMJDCHK@DXT3@
CONST	SEGMENT
??_C@_04FMJDCHK@DXT3@ DB 'DXT3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMNCADDL@DXT2@
CONST	SEGMENT
??_C@_04BMNCADDL@DXT2@ DB 'DXT2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHPPFAPI@DXT1@
CONST	SEGMENT
??_C@_04DHPPFAPI@DXT1@ DB 'DXT1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
CONST	SEGMENT
??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ DB 'ARGB-%d%d%d%d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBMAHCAD@?9premul@
CONST	SEGMENT
??_C@_07FBMAHCAD@?9premul@ DB '-premul', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ DB 'Yo'
	DB	'ur logic is jacked! bits == 0x%x', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ DB 'Ca'
	DB	'n''t open file for reading! [%s]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
CONST	SEGMENT
??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ DB 'Unknown file f'
	DB	'ormat encountered! [%s]', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFFPHNGG@?4DDS@
CONST	SEGMENT
??_C@_04LFFPHNGG@?4DDS@ DB '.DDS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDXTCImage@@6B@
CONST	SEGMENT
??_7CDXTCImage@@6B@ DD FLAT:??_R4CDXTCImage@@6B@	; CDXTCImage::`vftable'
	DD	FLAT:??_ECDXTCImage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0
__ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDXTCImage@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	57		 push	 edi
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00013	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	03 7d 10	 add	 edi, DWORD PTR __Dest$[ebp]
  0001c	8b c7		 mov	 eax, edi
  0001e	5f		 pop	 edi

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1814 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1815 :     char* const _First_ch = reinterpret_cast<char*>(_First);
; 1816 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);
; 1817 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 1818 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1819 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 1824 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1825 :     // value-initialize _Count objects to raw _First, using _Al
; 1826 :     using _Ptrty = typename _Alloc::value_type*;
; 1827 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1828 :         auto _PFirst = _Unfancy(_First);
; 1829 :         _Zero_range(_PFirst, _PFirst + _Count);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	03 f1		 add	 esi, ecx
  0000c	56		 push	 esi
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
  00013	83 c4 08	 add	 esp, 8

; 1830 :         return _First + _Count;

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi

; 1831 :     } else {
; 1832 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1833 :         for (; 0 < _Count; --_Count) {
; 1834 :             _Backout._Emplace_back();
; 1835 :         }
; 1836 : 
; 1837 :         return _Backout._Release();
; 1838 :     }
; 1839 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
__Newvec$1$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1183 :         if (_Newsize > max_size()) {

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00012	0f 87 83 00 00
	00		 ja	 $LN30@Resize_rea

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0001b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00020	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00022	89 4d fc	 mov	 DWORD PTR __Oldsize$1$[ebp], ecx

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00025	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00028	2b 0e		 sub	 ecx, DWORD PTR [esi]

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0002a	8b d1		 mov	 edx, ecx
  0002c	d1 ea		 shr	 edx, 1
  0002e	2b c2		 sub	 eax, edx
  00030	3b c8		 cmp	 ecx, eax
  00032	76 04		 jbe	 SHORT $LN10@Resize_rea

; 1620 :             return _Newsize; // geometric growth would overflow

  00034	8b df		 mov	 ebx, edi
  00036	eb 08		 jmp	 SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00038	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003b	3b df		 cmp	 ebx, edi
  0003d	0f 42 df	 cmovb	 ebx, edi
$LN11@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00040	53		 push	 ebx
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00046	8b 55 fc	 mov	 edx, DWORD PTR __Oldsize$1$[ebp]
  00049	8b cf		 mov	 ecx, edi
  0004b	2b ca		 sub	 ecx, edx
  0004d	89 45 08	 mov	 DWORD PTR __Newvec$1$[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00050	56		 push	 esi
  00051	51		 push	 ecx

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1193 : 
; 1194 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);
; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00052	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0005b	56		 push	 esi
  0005c	ff 75 08	 push	 DWORD PTR __Newvec$1$[ebp]
  0005f	ff 76 04	 push	 DWORD PTR [esi+4]
  00062	ff 36		 push	 DWORD PTR [esi]
  00064	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00069	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0006b	83 c4 20	 add	 esp, 32			; 00000020H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  0006e	85 c9		 test	 ecx, ecx
  00070	74 0f		 je	 SHORT $LN24@Resize_rea

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00075	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00077	50		 push	 eax
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0007e	83 c4 08	 add	 esp, 8
$LN24@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1680 :         _Myfirst = _Newvec;

  00081	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$1$[ebp]
  00084	89 0e		 mov	 DWORD PTR [esi], ecx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00086	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00089	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0008c	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0008f	5f		 pop	 edi
  00090	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);
; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1204 :         _RERAISE;
; 1205 :         _CATCH_END
; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1208 :     }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
$LN30@Resize_rea:

; 1184 :             _Xlength();

  0009b	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN28@Resize_rea:
  000a0	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?GetNumberOfBits@@YAGK@Z
_TEXT	SEGMENT
_dwMask$ = 8						; size = 4
?GetNumberOfBits@@YAGK@Z PROC				; GetNumberOfBits, COMDAT

; 899  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 900  : 	WORD wBits;
; 901  :     for (wBits = 0; dwMask; wBits++)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _dwMask$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 0c		 je	 SHORT $LN3@GetNumberO
  0000c	0f 1f 40 00	 npad	 4
$LL4@GetNumberO:

; 902  :         dwMask = (dwMask & (dwMask - 1));

  00010	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  00013	40		 inc	 eax
  00014	23 ca		 and	 ecx, edx
  00016	75 f8		 jne	 SHORT $LL4@GetNumberO
$LN3@GetNumberO:

; 903  : 
; 904  :     return wBits;
; 905  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?GetNumberOfBits@@YAGK@Z ENDP				; GetNumberOfBits
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDXTCImage@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDXTCImage@@UAEPAXI@Z PROC				; CDXTCImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDXTCImage@@UAE@XZ	; CDXTCImage::~CDXTCImage
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 28 01 00 00	 push	 296			; 00000128H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCDXTCImage@@UAEPAXI@Z ENDP				; CDXTCImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Unextract@CDXTCImage@@QAEXPAEHHH@Z
_TEXT	SEGMENT
_xblocks$1$ = -4					; size = 4
_pbDest$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_yblocks$1$ = 20					; size = 4
_iPitch$ = 20						; size = 4
?Unextract@CDXTCImage@@QAEXPAEHHH@Z PROC		; CDXTCImage::Unextract, COMDAT
; _this$ = ecx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi

; 289  : 	if (!m_pbCompBufferByLevels[0])

  00008	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0000b	85 f6		 test	 esi, esi
  0000d	74 5a		 je	 SHORT $LN3@Unextract

; 290  : 		return;
; 291  : 
; 292  : 	DXTColBlock * pBlock;
; 293  : 	BYTE * pPos = (BYTE *) &m_pbCompBufferByLevels[0][0];
; 294  : 	int xblocks = m_nWidth / 4;

  0000f	57		 push	 edi
  00010	8b bb 00 01 00
	00		 mov	 edi, DWORD PTR [ebx+256]
  00016	8b c7		 mov	 eax, edi
  00018	99		 cdq
  00019	83 e2 03	 and	 edx, 3
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 02	 sar	 eax, 2
  00021	89 45 fc	 mov	 DWORD PTR _xblocks$1$[ebp], eax

; 295  : 	int yblocks = (m_nHeight / 4) * ((iPitch / m_nWidth) / 2);

  00024	8b 45 14	 mov	 eax, DWORD PTR _iPitch$[ebp]
  00027	99		 cdq
  00028	f7 ff		 idiv	 edi
  0002a	99		 cdq
  0002b	2b c2		 sub	 eax, edx
  0002d	8b c8		 mov	 ecx, eax
  0002f	8b 83 04 01 00
	00		 mov	 eax, DWORD PTR [ebx+260]
  00035	99		 cdq
  00036	83 e2 03	 and	 edx, 3
  00039	d1 f9		 sar	 ecx, 1
  0003b	03 c2		 add	 eax, edx
  0003d	c1 f8 02	 sar	 eax, 2
  00040	0f af c8	 imul	 ecx, eax
  00043	89 4d 14	 mov	 DWORD PTR _yblocks$1$[ebp], ecx

; 296  : 
; 297  : 	for (int y = 0; y < yblocks; ++y)

  00046	85 c9		 test	 ecx, ecx
  00048	7e 1e		 jle	 SHORT $LN11@Unextract

; 290  : 		return;
; 291  : 
; 292  : 	DXTColBlock * pBlock;
; 293  : 	BYTE * pPos = (BYTE *) &m_pbCompBufferByLevels[0][0];
; 294  : 	int xblocks = m_nWidth / 4;

  0004a	8b 7d fc	 mov	 edi, DWORD PTR _xblocks$1$[ebp]
  0004d	8b 5d 08	 mov	 ebx, DWORD PTR _pbDest$[ebp]
  00050	c1 e7 03	 shl	 edi, 3
$LL4@Unextract:

; 298  : 	{
; 299  : 		pBlock = (DXTColBlock*) (pPos + y * xblocks * 8);
; 300  : 
; 301  : 		memcpy(pbDest, pBlock, xblocks * 8);

  00053	57		 push	 edi
  00054	56		 push	 esi
  00055	53		 push	 ebx
  00056	e8 00 00 00 00	 call	 _memcpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : 		pbDest += xblocks * 8;

  0005e	03 df		 add	 ebx, edi
  00060	03 f7		 add	 esi, edi
  00062	83 6d 14 01	 sub	 DWORD PTR _yblocks$1$[ebp], 1
  00066	75 eb		 jne	 SHORT $LL4@Unextract
$LN11@Unextract:
  00068	5f		 pop	 edi
$LN3@Unextract:
  00069	5e		 pop	 esi

; 303  : 	}
; 304  : 
; 305  : 	/*
; 306  : 	for (int y = 0; y < iHeight; ++y)
; 307  : 	{
; 308  : 		memcpy(pbDest, &m_pbCompBufferByLevels[0][0] + y*iWidth, iWidth);
; 309  : 		pbDest += iWidth;
; 310  : 	}
; 311  : 	*/
; 312  : }

  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 10 00	 ret	 16			; 00000010H
?Unextract@CDXTCImage@@QAEXPAEHHH@Z ENDP		; CDXTCImage::Unextract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z
_TEXT	SEGMENT
_strPixelFormat$ = 8					; size = 4
_pxddpf$ = 12						; size = 4
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z PROC ; CDXTCImage::DecodePixelFormat, COMDAT
; _this$ = ecx

; 914  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 915  : 	switch (pxddpf->dwFourCC)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _pxddpf$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000d	3d 44 58 54 33	 cmp	 eax, 861165636		; 33545844H
  00012	0f 87 f5 00 00
	00		 ja	 $LN12@DecodePixe
  00018	0f 84 cd 00 00
	00		 je	 $LN7@DecodePixe
  0001e	85 c0		 test	 eax, eax
  00020	74 56		 je	 SHORT $LN4@DecodePixe
  00022	3d 44 58 54 31	 cmp	 eax, 827611204		; 31545844H
  00027	74 2d		 je	 SHORT $LN5@DecodePixe
  00029	3d 44 58 54 32	 cmp	 eax, 844388420		; 32545844H
  0002e	0f 85 e7 00 00
	00		 jne	 $LN10@DecodePixe

; 933  : 			m_CompFormat = PF_DXT1;
; 934  : 			break;
; 935  : 
; 936  : 		case MAKEFOURCC('D','X','T','2'):
; 937  : 			strncpy(strPixelFormat, "DXT2", 31);

  00034	6a 1f		 push	 31			; 0000001fH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_04BMNCADDL@DXT2@
  0003b	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  0003e	e8 00 00 00 00	 call	 _strncpy

; 959  : 			break;
; 960  : 	}
; 961  : }

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c7 86 ec 00 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+236], 2
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN5@DecodePixe:

; 928  : 			}
; 929  : 			break;
; 930  : 
; 931  : 		case MAKEFOURCC('D','X','T','1'):
; 932  : 			strncpy(strPixelFormat, "DXT1", 31);

  00056	6a 1f		 push	 31			; 0000001fH
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_04DHPPFAPI@DXT1@
  0005d	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00060	e8 00 00 00 00	 call	 _strncpy

; 959  : 			break;
; 960  : 	}
; 961  : }

  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	c7 86 ec 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+236], 1
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
$LN4@DecodePixe:

; 916  : 	{
; 917  : 		case 0:
; 918  : 			{
; 919  : 				// This dds texture isn't compressed so write out ARGB format
; 920  : 				WORD a = GetNumberOfBits(pxddpf->dwRGBAlphaBitMask);
; 921  : 				WORD r = GetNumberOfBits(pxddpf->dwRBitMask);
; 922  : 				WORD g = GetNumberOfBits(pxddpf->dwGBitMask);
; 923  : 				WORD b = GetNumberOfBits(pxddpf->dwBBitMask);
; 924  : 
; 925  : 				_snprintf(strPixelFormat, 31, "ARGB-%d%d%d%d%s", a, r, g, b,

  00078	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0007b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_00CNPNBAHC@@
  00080	f7 c1 00 80 00
	00		 test	 ecx, 32768		; 00008000H
  00086	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07FBMAHCAD@?9premul@
  0008b	0f 44 c2	 cmove	 eax, edx
  0008e	50		 push	 eax
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  00095	83 c4 04	 add	 esp, 4
  00098	0f b7 c0	 movzx	 eax, ax
  0009b	50		 push	 eax
  0009c	ff 77 14	 push	 DWORD PTR [edi+20]
  0009f	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000a4	83 c4 04	 add	 esp, 4
  000a7	0f b7 c0	 movzx	 eax, ax
  000aa	50		 push	 eax
  000ab	ff 77 10	 push	 DWORD PTR [edi+16]
  000ae	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000b3	83 c4 04	 add	 esp, 4
  000b6	0f b7 c0	 movzx	 eax, ax
  000b9	50		 push	 eax
  000ba	ff 77 1c	 push	 DWORD PTR [edi+28]
  000bd	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000c2	83 c4 04	 add	 esp, 4
  000c5	0f b7 c0	 movzx	 eax, ax
  000c8	50		 push	 eax
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
  000ce	6a 1f		 push	 31			; 0000001fH
  000d0	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000d3	e8 00 00 00 00	 call	 __snprintf
  000d8	83 c4 20	 add	 esp, 32			; 00000020H

; 926  : 					pxddpf->dwBBitMask & DDPF_ALPHAPREMULT ? "-premul" : "");
; 927  : 				m_CompFormat = PF_ARGB;

  000db	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
  000e5	5f		 pop	 edi

; 959  : 			break;
; 960  : 	}
; 961  : }

  000e6	5e		 pop	 esi
  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN7@DecodePixe:

; 938  : 			m_CompFormat = PF_DXT2;
; 939  : 			break;
; 940  : 
; 941  : 		case MAKEFOURCC('D','X','T','3'):
; 942  : 			strncpy(strPixelFormat, "DXT3", 31);

  000eb	6a 1f		 push	 31			; 0000001fH
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_04FMJDCHK@DXT3@
  000f2	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000f5	e8 00 00 00 00	 call	 _strncpy

; 959  : 			break;
; 960  : 	}
; 961  : }

  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fd	c7 86 ec 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+236], 3
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5d		 pop	 ebp
  0010a	c2 08 00	 ret	 8
$LN12@DecodePixe:

; 915  : 	switch (pxddpf->dwFourCC)

  0010d	3d 44 58 54 34	 cmp	 eax, 877942852		; 34545844H
  00112	74 62		 je	 SHORT $LN8@DecodePixe
  00114	3d 44 58 54 35	 cmp	 eax, 894720068		; 35545844H
  00119	74 39		 je	 SHORT $LN9@DecodePixe
$LN10@DecodePixe:

; 953  : 			m_CompFormat = PF_DXT5;
; 954  : 			break;
; 955  : 
; 956  : 		default:
; 957  : 			strcpy(strPixelFormat, "Format Unknown");

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _strPixelFormat$[ebp]
  0011e	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@
  00126	5f		 pop	 edi
  00127	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0012b	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+8
  00130	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00133	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+12
  00139	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
  0013d	a0 0e 00 00 00	 mov	 al, BYTE PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+14
  00142	88 41 0e	 mov	 BYTE PTR [ecx+14], al

; 958  : 			m_CompFormat = PF_UNKNOWN;

  00145	c7 86 ec 00 00
	00 06 00 00 00	 mov	 DWORD PTR [esi+236], 6

; 959  : 			break;
; 960  : 	}
; 961  : }

  0014f	5e		 pop	 esi
  00150	5d		 pop	 ebp
  00151	c2 08 00	 ret	 8
$LN9@DecodePixe:

; 948  : 			m_CompFormat = PF_DXT4;
; 949  : 			break;
; 950  : 
; 951  : 		case MAKEFOURCC('D','X','T','5'):
; 952  : 			strncpy(strPixelFormat, "DXT5", 31);

  00154	6a 1f		 push	 31			; 0000001fH
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_04FDJDJFPM@DXT5@
  0015b	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  0015e	e8 00 00 00 00	 call	 _strncpy

; 959  : 			break;
; 960  : 	}
; 961  : }

  00163	83 c4 0c	 add	 esp, 12			; 0000000cH
  00166	c7 86 ec 00 00
	00 05 00 00 00	 mov	 DWORD PTR [esi+236], 5
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5d		 pop	 ebp
  00173	c2 08 00	 ret	 8
$LN8@DecodePixe:

; 943  : 			m_CompFormat = PF_DXT3;
; 944  : 			break;
; 945  : 
; 946  : 		case MAKEFOURCC('D','X','T','4'):
; 947  : 			strncpy(strPixelFormat, "DXT4", 31);

  00176	6a 1f		 push	 31			; 0000001fH
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_04EKIIKELN@DXT4@
  0017d	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00180	e8 00 00 00 00	 call	 _strncpy

; 959  : 			break;
; 960  : 	}
; 961  : }

  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
  00188	c7 86 ec 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+236], 4
  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5d		 pop	 ebp
  00195	c2 08 00	 ret	 8
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ENDP ; CDXTCImage::DecodePixelFormat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressARGB, COMDAT
; _this$ = ecx

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 856  : 	UINT lPitch = m_lPitch >> (level * 2);

  00003	8b 55 08	 mov	 edx, DWORD PTR _level$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  0000c	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00012	d3 f8		 sar	 eax, cl

; 857  : 	memcpy(pdwDest, &m_bCompVector[level][0], lPitch);

  00014	50		 push	 eax
  00015	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00018	ff 74 86 34	 push	 DWORD PTR [esi+eax*4+52]
  0001c	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	5e		 pop	 esi

; 858  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressARGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
tv2667 = -116						; size = 4
tv2666 = -112						; size = 4
_xblocks$1$ = -108					; size = 4
_alphazero$1$ = -104					; size = 4
tv2725 = -100						; size = 4
_yblocks$1$ = -96					; size = 4
_pdwDest$GSCopy$1$ = -92				; size = 4
_pPos$1$ = -88						; size = 4
tv2717 = -84						; size = 4
_pAlphaBlock$1$ = -80					; size = 4
_pBlock$1$ = -76					; size = 4
tv2721 = -72						; size = 4
tv2544 = -72						; size = 4
_nWidth$1$ = -68					; size = 4
tv2671 = -64						; size = 4
_col_1$ = -60						; size = 4
tv2711 = -56						; size = 4
_pImPos$1$ = -56					; size = 4
_col_2$ = -52						; size = 4
_col_3$ = -48						; size = 4
tv2710 = -44						; size = 4
tv2546 = -44						; size = 4
_y$1$ = -44						; size = 4
_col_0$ = -40						; size = 4
_shift$1 = -36						; size = 16
_masks$2 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT5, COMDAT
; _this$ = ecx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx

; 781  : 	int xblocks, yblocks;
; 782  : #ifdef DEBUG
; 783  : 	if ((ddsd.dwWidth % 4) != 0)
; 784  : 	{
; 785  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 786  : 	}
; 787  : 
; 788  : 	if ((ddsd.dwHeight % 4) != 0)
; 789  : 	{
; 790  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 791  : 	}
; 792  : 
; 793  : 	Tracef("end check\n");
; 794  : #endif
; 795  : 	UINT nWidth = m_nWidth >> level;
; 796  : 	UINT nHeight = m_nHeight >> level;
; 797  : 
; 798  : 	xblocks = nWidth / 4;
; 799  : 	yblocks = nHeight / 4;
; 800  : 
; 801  : 	int x, y;
; 802  : 
; 803  : 	DWORD * pBase = (DWORD *) pdwDest;
; 804  : 	WORD  * pPos = pPos = (WORD *) &m_bCompVector[level][0]; // pos in compressed data
; 805  : 	DWORD * pImPos;	// pos in decompressed data
; 806  : 
; 807  : 	DXTColBlock	* pBlock;
; 808  : 	DXTAlphaBlock3BitLinear * pAlphaBlock;
; 809  : 
; 810  : 	Color8888 col_0, col_1, col_2, col_3;
; 811  : 	WORD wrd;
; 812  : 
; 813  : 	// fill alphazero with appropriate value to zero out alpha when
; 814  : 	// alphazero is ANDed with the image color 32 bit DWORD:
; 815  : 	col_0.a = 0;
; 816  : 	col_0.r = col_0.g = col_0.b = 0xff;

  00012	c7 45 d8 ff ff
	ff 00		 mov	 DWORD PTR _col_0$[ebp], 16777215 ; 00ffffffH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	8b 82 00 01 00
	00		 mov	 eax, DWORD PTR [edx+256]
  00024	8b 9a 04 01 00
	00		 mov	 ebx, DWORD PTR [edx+260]
  0002a	8b 75 0c	 mov	 esi, DWORD PTR _pdwDest$[ebp]
  0002d	d3 f8		 sar	 eax, cl
  0002f	57		 push	 edi
  00030	8b f8		 mov	 edi, eax
  00032	d3 fb		 sar	 ebx, cl
  00034	89 45 bc	 mov	 DWORD PTR _nWidth$1$[ebp], eax
  00037	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0003a	8b 4c 82 34	 mov	 ecx, DWORD PTR [edx+eax*4+52]
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 817  : 	DWORD alphazero = *((DWORD *) &col_0);

  0003e	8b 45 d8	 mov	 eax, DWORD PTR _col_0$[ebp]
  00041	c1 eb 02	 shr	 ebx, 2
  00044	c1 ef 02	 shr	 edi, 2
  00047	89 75 a4	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], esi
  0004a	89 7d 94	 mov	 DWORD PTR _xblocks$1$[ebp], edi
  0004d	89 5d a0	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00050	89 4d a8	 mov	 DWORD PTR _pPos$1$[ebp], ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 817  : 	DWORD alphazero = *((DWORD *) &col_0);

  00053	89 45 98	 mov	 DWORD PTR _alphazero$1$[ebp], eax

; 818  : 
; 819  : 	////////////////////////////////
; 820  : 	// Tracef("blocks: x: %d y: %d\n", xblocks, yblocks);
; 821  : 	for (y = 0; y < yblocks; ++y)

  00056	85 db		 test	 ebx, ebx
  00058	0f 84 bf 04 00
	00		 je	 $LN3@Decompress

; 780  : {

  0005e	8b 55 bc	 mov	 edx, DWORD PTR _nWidth$1$[ebp]
  00061	c1 e2 06	 shl	 edx, 6
  00064	89 55 8c	 mov	 DWORD PTR tv2667[ebp], edx
  00067	8b d7		 mov	 edx, edi
  00069	c1 e2 05	 shl	 edx, 5
  0006c	89 55 90	 mov	 DWORD PTR tv2666[ebp], edx
  0006f	90		 npad	 1
$LL4@Decompress:

; 822  : 	{
; 823  : 		// 8 bytes per block
; 824  : 		// 1 block for alpha, 1 block for color
; 825  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  00070	8b d1		 mov	 edx, ecx

; 826  : 
; 827  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00072	85 ff		 test	 edi, edi
  00074	0f 84 8b 04 00
	00		 je	 $LN2@Decompress

; 444  : 	const int   shift[] = { 0, 2, 4, 6 };

  0007a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000

; 358  : 	col_0->a = 0xff;

  00081	c6 45 db ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 365  : 
; 366  : 	pCol = (Color565*) & (pBlock->col1);
; 367  : 	col_1->a = 0xff;

  00085	c6 45 c7 ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 415  : 		col_2->r = (BYTE)wrd;
; 416  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 417  : 		col_2->g = (BYTE)wrd;
; 418  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 419  : 		col_2->b = (BYTE)wrd;
; 420  : 		col_2->a = 0xff;

  00089	c6 45 cf ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 443  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  0008d	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _masks$2[ebp], 3
  00094	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+4], 12 ; 0000000cH
  0009b	c7 45 f4 30 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+8], 48 ; 00000030H
  000a2	c7 45 f8 c0 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+12], 192 ; 000000c0H

; 444  : 	const int   shift[] = { 0, 2, 4, 6 };

  000a9	0f 11 45 dc	 movups	 XMMWORD PTR _shift$1[ebp], xmm0

; 822  : 	{
; 823  : 		// 8 bytes per block
; 824  : 		// 1 block for alpha, 1 block for color
; 825  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  000ad	89 75 c0	 mov	 DWORD PTR tv2671[ebp], esi
  000b0	89 7d ac	 mov	 DWORD PTR tv2717[ebp], edi
$LL7@Decompress:

; 359  : 	col_0->r = pCol->nRed;

  000b3	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000b6	8b c1		 mov	 eax, ecx

; 368  : 	col_1->r = pCol->nRed;

  000b8	8b 5a 0a	 mov	 ebx, DWORD PTR [edx+10]

; 828  : 		{
; 829  : 			// inline
; 830  : 			// Get alpha block
; 831  : 			pAlphaBlock = (DXTAlphaBlock3BitLinear*) pBlock;

  000bb	89 55 b0	 mov	 DWORD PTR _pAlphaBlock$1$[ebp], edx

; 832  : 
; 833  : 			// inline func:
; 834  : 			// Get color block & colors
; 835  : 			pBlock++;

  000be	83 c2 08	 add	 edx, 8

; 359  : 	col_0->r = pCol->nRed;

  000c1	c1 e8 0b	 shr	 eax, 11			; 0000000bH

; 360  : 	col_0->r <<= 3;				// shift to full precision

  000c4	c0 e0 03	 shl	 al, 3
  000c7	89 45 b8	 mov	 DWORD PTR tv2544[ebp], eax
  000ca	88 45 da	 mov	 BYTE PTR _col_0$[ebp+2], al

; 361  : 	col_0->g = pCol->nGreen;

  000cd	8b c1		 mov	 eax, ecx
  000cf	c1 e8 05	 shr	 eax, 5

; 362  : 	col_0->g <<= 2;

  000d2	c0 e0 02	 shl	 al, 2
  000d5	89 45 d4	 mov	 DWORD PTR tv2546[ebp], eax

; 363  : 	col_0->b = pCol->nBlue;
; 364  : 	col_0->b <<= 3;

  000d8	8a e1		 mov	 ah, cl

; 832  : 
; 833  : 			// inline func:
; 834  : 			// Get color block & colors
; 835  : 			pBlock++;

  000da	89 55 b4	 mov	 DWORD PTR _pBlock$1$[ebp], edx

; 370  : 	col_1->g = pCol->nGreen;

  000dd	8b cb		 mov	 ecx, ebx
  000df	c1 e9 05	 shr	 ecx, 5
  000e2	8b d3		 mov	 edx, ebx

; 371  : 	col_1->g <<= 2;

  000e4	c0 e1 02	 shl	 cl, 2
  000e7	88 45 d9	 mov	 BYTE PTR _col_0$[ebp+1], al

; 372  : 	col_1->b = pCol->nBlue;
; 373  : 	col_1->b <<= 3;

  000ea	8a c3		 mov	 al, bl
  000ec	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  000ef	88 4d c5	 mov	 BYTE PTR _col_1$[ebp+1], cl
  000f2	c0 e0 03	 shl	 al, 3
  000f5	0f b6 f9	 movzx	 edi, cl
  000f8	8b 4d b8	 mov	 ecx, DWORD PTR tv2544[ebp]
  000fb	c0 e4 03	 shl	 ah, 3
  000fe	c0 e2 03	 shl	 dl, 3
  00101	0f b6 c9	 movzx	 ecx, cl
  00104	88 65 d8	 mov	 BYTE PTR _col_0$[ebp], ah
  00107	88 45 c4	 mov	 BYTE PTR _col_1$[ebp], al
  0010a	88 55 c6	 mov	 BYTE PTR _col_1$[ebp+2], dl
  0010d	0f b6 f2	 movzx	 esi, dl
  00110	0f b6 d0	 movzx	 edx, al
  00113	89 4d c8	 mov	 DWORD PTR tv2711[ebp], ecx
  00116	8b 4d d4	 mov	 ecx, DWORD PTR tv2546[ebp]
  00119	0f b6 c4	 movzx	 eax, ah
  0011c	89 45 d4	 mov	 DWORD PTR tv2710[ebp], eax

; 374  : 
; 375  : 	if (pBlock->col0 > pBlock->col1)

  0011f	8b 45 b4	 mov	 eax, DWORD PTR _pBlock$1$[ebp]
  00122	0f b6 c9	 movzx	 ecx, cl
  00125	89 55 9c	 mov	 DWORD PTR tv2725[ebp], edx
  00128	89 4d b8	 mov	 DWORD PTR tv2721[ebp], ecx
  0012b	66 39 18	 cmp	 WORD PTR [eax], bx
  0012e	8b 45 c8	 mov	 eax, DWORD PTR tv2711[ebp]
  00131	76 72		 jbe	 SHORT $LN12@Decompress

; 376  : 	{
; 377  : 		// Four-color block: derive the other two colors.
; 378  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 379  : 		// These two bit codes correspond to the 2-bit fields
; 380  : 		// stored in the 64-bit block.
; 381  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);
; 382  : 		// no +1 for rounding
; 383  : 		// as bits have been shifted to 888
; 384  : 		col_2->r = (BYTE)wrd;
; 385  : 
; 386  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 387  : 		col_2->g = (BYTE)wrd;
; 388  : 
; 389  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);

  00133	8b 5d 9c	 mov	 ebx, DWORD PTR tv2725[ebp]
  00136	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00139	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH

; 390  : 		col_2->b = (BYTE)wrd;
; 391  : 		col_2->a = 0xff;
; 392  : 
; 393  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 394  : 		col_3->r = (BYTE)wrd;
; 395  : 
; 396  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 397  : 		col_3->g = (BYTE)wrd;
; 398  : 
; 399  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 400  : 		col_3->b = (BYTE)wrd;
; 401  : 		col_3->a = 0xff;

  0013e	c6 45 d3 ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  00142	f7 e1		 mul	 ecx
  00144	8b 45 b8	 mov	 eax, DWORD PTR tv2721[ebp]
  00147	d1 ea		 shr	 edx, 1
  00149	88 55 ce	 mov	 BYTE PTR _col_2$[ebp+2], dl
  0014c	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  0014f	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00154	f7 e1		 mul	 ecx
  00156	8b 45 d4	 mov	 eax, DWORD PTR tv2710[ebp]
  00159	d1 ea		 shr	 edx, 1
  0015b	88 55 cd	 mov	 BYTE PTR _col_2$[ebp+1], dl
  0015e	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  00161	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00166	f7 e1		 mul	 ecx
  00168	8b 45 c8	 mov	 eax, DWORD PTR tv2711[ebp]
  0016b	d1 ea		 shr	 edx, 1
  0016d	88 55 cc	 mov	 BYTE PTR _col_2$[ebp], dl
  00170	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  00173	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00178	f7 e1		 mul	 ecx
  0017a	8b 45 b8	 mov	 eax, DWORD PTR tv2721[ebp]
  0017d	d1 ea		 shr	 edx, 1
  0017f	88 55 d2	 mov	 BYTE PTR _col_3$[ebp+2], dl
  00182	8d 0c 78	 lea	 ecx, DWORD PTR [eax+edi*2]
  00185	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0018a	f7 e1		 mul	 ecx
  0018c	8b 45 d4	 mov	 eax, DWORD PTR tv2710[ebp]
  0018f	d1 ea		 shr	 edx, 1
  00191	88 55 d1	 mov	 BYTE PTR _col_3$[ebp+1], dl
  00194	8d 0c 58	 lea	 ecx, DWORD PTR [eax+ebx*2]
  00197	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0019c	f7 e1		 mul	 ecx
  0019e	d1 ea		 shr	 edx, 1
  001a0	88 55 d0	 mov	 BYTE PTR _col_3$[ebp], dl

; 402  : 	}

  001a3	eb 27		 jmp	 SHORT $LN13@Decompress
$LN12@Decompress:

; 403  : 	else
; 404  : 	{
; 405  : 		// Three-color block: derive the other color.
; 406  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 407  : 		// 11 = transparent.
; 408  : 		// These two bit codes correspond to the 2-bit fields
; 409  : 		// stored in the 64-bit block.
; 410  : 
; 411  : 		// explicit for each component, unlike some refrasts...
; 412  : 
; 413  : 		// Tracef("block has alpha\n");
; 414  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001a5	03 c6		 add	 eax, esi

; 421  : 
; 422  : 		col_3->r = 0x00;		// random color to indicate alpha
; 423  : 		col_3->g = 0x00;

  001a7	66 c7 45 d1 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001ad	d1 e8		 shr	 eax, 1
  001af	88 45 ce	 mov	 BYTE PTR _col_2$[ebp+2], al
  001b2	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  001b5	d1 e8		 shr	 eax, 1
  001b7	88 45 cd	 mov	 BYTE PTR _col_2$[ebp+1], al
  001ba	8b 45 d4	 mov	 eax, DWORD PTR tv2710[ebp]
  001bd	03 c2		 add	 eax, edx

; 424  : 		col_3->b = 0x00;

  001bf	c6 45 d0 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001c3	d1 e8		 shr	 eax, 1
  001c5	88 45 cc	 mov	 BYTE PTR _col_2$[ebp], al

; 425  : 		col_3->a = 0x00;

  001c8	c6 45 d3 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
$LN13@Decompress:

; 836  : 
; 837  : 			// Tracef("pBlock: 0x%.8x\n", pBlock);
; 838  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 839  : 
; 840  : 			// Decode the color block into the bitmap bits
; 841  : 			// inline func:
; 842  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 843  : 
; 844  : 			//DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);
; 845  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001cc	8b 55 c0	 mov	 edx, DWORD PTR tv2671[ebp]

; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001cf	33 c0		 xor	 eax, eax
  001d1	8b 75 d8	 mov	 esi, DWORD PTR _col_0$[ebp]
  001d4	8b 7d d0	 mov	 edi, DWORD PTR _col_3$[ebp]

; 836  : 
; 837  : 			// Tracef("pBlock: 0x%.8x\n", pBlock);
; 838  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 839  : 
; 840  : 			// Decode the color block into the bitmap bits
; 841  : 			// inline func:
; 842  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 843  : 
; 844  : 			//DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);
; 845  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001d7	89 55 c8	 mov	 DWORD PTR _pImPos$1$[ebp], edx

; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001da	89 45 d4	 mov	 DWORD PTR _y$1$[ebp], eax
  001dd	0f 1f 00	 npad	 3
$LL18@Decompress:

; 448  : 	{
; 449  : 		// width * 4 bytes per pixel per line
; 450  : 		// each j dxtc row is 4 lines of pixels
; 451  : 
; 452  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 453  : 
; 454  : 		// n steps through pixels
; 455  : 		for (n = 0; n < 4; ++n)

  001e0	33 db		 xor	 ebx, ebx
$LL21@Decompress:

; 456  : 		{
; 457  : 			bits = pColorBlock->row[y] & masks[n];

  001e2	8b 4d b4	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  001e5	0f b6 4c 08 04	 movzx	 ecx, BYTE PTR [eax+ecx+4]
  001ea	8b 44 1d ec	 mov	 eax, DWORD PTR _masks$2[ebp+ebx]
  001ee	23 c1		 and	 eax, ecx

; 458  : 			bits >>= shift[n];

  001f0	8b 4c 1d dc	 mov	 ecx, DWORD PTR _shift$1[ebp+ebx]
  001f4	d3 e8		 shr	 eax, cl

; 459  : 
; 460  : 			switch (bits)

  001f6	83 f8 03	 cmp	 eax, 3
  001f9	77 1d		 ja	 SHORT $LN28@Decompress
  001fb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN91@Decompress[eax*4]
$LN24@Decompress:

; 461  : 			{
; 462  : 				case 0:
; 463  : 					*pImPos = *col_0;

  00202	89 32		 mov	 DWORD PTR [edx], esi

; 464  : 					pImPos++; // increment to next DWORD
; 465  : 					break;

  00204	eb 23		 jmp	 SHORT $LN19@Decompress
$LN25@Decompress:

; 466  : 
; 467  : 				case 1:
; 468  : 					*pImPos = *col_1;

  00206	8b 45 c4	 mov	 eax, DWORD PTR _col_1$[ebp]
  00209	89 02		 mov	 DWORD PTR [edx], eax

; 469  : 					pImPos++;
; 470  : 					break;

  0020b	eb 1c		 jmp	 SHORT $LN19@Decompress
$LN26@Decompress:

; 471  : 
; 472  : 				case 2:
; 473  : 					*pImPos = *col_2;

  0020d	8b 45 cc	 mov	 eax, DWORD PTR _col_2$[ebp]
  00210	89 02		 mov	 DWORD PTR [edx], eax

; 474  : 					pImPos++;
; 475  : 					break;

  00212	eb 15		 jmp	 SHORT $LN19@Decompress
$LN27@Decompress:

; 476  : 
; 477  : 				case 3:
; 478  : 					*pImPos = *col_3;

  00214	89 3a		 mov	 DWORD PTR [edx], edi

; 479  : 					pImPos++;
; 480  : 					break;

  00216	eb 11		 jmp	 SHORT $LN19@Decompress
$LN28@Decompress:

; 481  : 
; 482  : 				default:
; 483  : 					Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00218	50		 push	 eax
  00219	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0021e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00223	8b 55 c8	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00226	83 c4 08	 add	 esp, 8
$LN19@Decompress:

; 448  : 	{
; 449  : 		// width * 4 bytes per pixel per line
; 450  : 		// each j dxtc row is 4 lines of pixels
; 451  : 
; 452  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 453  : 
; 454  : 		// n steps through pixels
; 455  : 		for (n = 0; n < 4; ++n)

  00229	8b 45 d4	 mov	 eax, DWORD PTR _y$1$[ebp]
  0022c	83 c2 04	 add	 edx, 4
  0022f	83 c3 04	 add	 ebx, 4
  00232	89 55 c8	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00235	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00238	7c a8		 jl	 SHORT $LL21@Decompress

; 445  : 
; 446  : 	// r steps through lines in y
; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0023a	8b 4d bc	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0023d	40		 inc	 eax
  0023e	89 45 d4	 mov	 DWORD PTR _y$1$[ebp], eax
  00241	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00244	83 c2 f0	 add	 edx, -16		; fffffff0H
  00247	89 55 c8	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  0024a	83 f8 04	 cmp	 eax, 4
  0024d	7c 91		 jl	 SHORT $LL18@Decompress

; 548  : 	gAlphas[0] = pAlphaBlock->alpha0;

  0024f	8b 4d b0	 mov	 ecx, DWORD PTR _pAlphaBlock$1$[ebp]

; 846  : 
; 847  : 			// Overwrite the previous alpha bits with the alpha block
; 848  : 			//  info
; 849  : 			DecodeAlpha3BitLinear(pImPos, pAlphaBlock, nWidth, alphazero);

  00252	8b 75 c0	 mov	 esi, DWORD PTR tv2671[ebp]

; 548  : 	gAlphas[0] = pAlphaBlock->alpha0;

  00255	8a 11		 mov	 dl, BYTE PTR [ecx]

; 549  : 	gAlphas[1] = pAlphaBlock->alpha1;

  00257	8a 49 01	 mov	 cl, BYTE PTR [ecx+1]
  0025a	0f b6 c2	 movzx	 eax, dl
  0025d	66 a3 00 00 00
	00		 mov	 WORD PTR ?gAlphas@@3PAGA, ax
  00263	0f b6 c1	 movzx	 eax, cl
  00266	66 a3 02 00 00
	00		 mov	 WORD PTR ?gAlphas@@3PAGA+2, ax
  0026c	0f b6 fa	 movzx	 edi, dl
  0026f	0f b6 d9	 movzx	 ebx, cl
  00272	3a d1		 cmp	 dl, cl

; 550  : 
; 551  : 	// 8-alpha or 6-alpha block?
; 552  : 	if (gAlphas[0] > gAlphas[1])

  00274	0f 86 b4 00 00
	00		 jbe	 $LN43@Decompress

; 553  : 	{
; 554  : 		// 8-alpha block:  derive the other 6 alphas.
; 555  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 556  : 		gAlphas[2] = (WORD) ((6 * gAlphas[0] +     gAlphas[1]) / 7);	// Bit code 010

  0027a	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0027d	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  00280	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  00285	f7 e1		 mul	 ecx

; 557  : 		gAlphas[3] = (WORD) ((5 * gAlphas[0] + 2 * gAlphas[1]) / 7);	// Bit code 011

  00287	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0028c	2b ca		 sub	 ecx, edx
  0028e	d1 e9		 shr	 ecx, 1
  00290	03 ca		 add	 ecx, edx
  00292	c1 e9 02	 shr	 ecx, 2
  00295	66 89 0d 04 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+4, cx
  0029c	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  0029f	8d 0c b9	 lea	 ecx, DWORD PTR [ecx+edi*4]
  002a2	03 cf		 add	 ecx, edi
  002a4	f7 e1		 mul	 ecx

; 558  : 		gAlphas[4] = (WORD) ((4 * gAlphas[0] + 3 * gAlphas[1]) / 7);	// Bit code 100

  002a6	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  002ab	2b ca		 sub	 ecx, edx
  002ad	d1 e9		 shr	 ecx, 1
  002af	03 ca		 add	 ecx, edx
  002b1	c1 e9 02	 shr	 ecx, 2
  002b4	66 89 0d 06 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+6, cx
  002bb	8d 0c 5b	 lea	 ecx, DWORD PTR [ebx+ebx*2]
  002be	8d 0c b9	 lea	 ecx, DWORD PTR [ecx+edi*4]
  002c1	f7 e1		 mul	 ecx

; 559  : 		gAlphas[5] = (WORD) ((3 * gAlphas[0] + 4 * gAlphas[1]) / 7);	// Bit code 101

  002c3	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  002c6	2b ca		 sub	 ecx, edx
  002c8	d1 e9		 shr	 ecx, 1
  002ca	03 ca		 add	 ecx, edx
  002cc	c1 e9 02	 shr	 ecx, 2
  002cf	66 89 0d 08 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+8, cx
  002d6	8d 0c 98	 lea	 ecx, DWORD PTR [eax+ebx*4]
  002d9	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  002de	f7 e1		 mul	 ecx

; 560  : 		gAlphas[6] = (WORD) ((2 * gAlphas[0] + 5 * gAlphas[1]) / 7);	// Bit code 110

  002e0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  002e3	2b ca		 sub	 ecx, edx
  002e5	d1 e9		 shr	 ecx, 1
  002e7	03 ca		 add	 ecx, edx
  002e9	c1 e9 02	 shr	 ecx, 2
  002ec	66 89 0d 0a 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+10, cx
  002f3	8d 0c 98	 lea	 ecx, DWORD PTR [eax+ebx*4]
  002f6	03 cb		 add	 ecx, ebx
  002f8	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  002fd	f7 e1		 mul	 ecx

; 561  : 		gAlphas[7] = (WORD) ((    gAlphas[0] + 6 * gAlphas[1]) / 7);	// Bit code 111

  002ff	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00302	2b ca		 sub	 ecx, edx
  00304	d1 e9		 shr	 ecx, 1
  00306	03 ca		 add	 ecx, edx
  00308	c1 e9 02	 shr	 ecx, 2
  0030b	66 89 0d 0c 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+12, cx
  00312	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  00315	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0031a	f7 e1		 mul	 ecx
  0031c	2b ca		 sub	 ecx, edx
  0031e	d1 e9		 shr	 ecx, 1
  00320	03 ca		 add	 ecx, edx
  00322	c1 e9 02	 shr	 ecx, 2
  00325	66 89 0d 0e 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+14, cx

; 562  : 	}

  0032c	eb 64		 jmp	 SHORT $LN44@Decompress
$LN43@Decompress:

; 563  : 	else
; 564  : 	{
; 565  : 		// 6-alpha block:  derive the other alphas.
; 566  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 567  : 		gAlphas[2] = (WORD) ((4 * gAlphas[0] +     gAlphas[1]) / 5);	// Bit code 010

  0032e	8d 0c bb	 lea	 ecx, DWORD PTR [ebx+edi*4]

; 568  : 		gAlphas[3] = (WORD) ((3 * gAlphas[0] + 2 * gAlphas[1]) / 5);	// Bit code 011
; 569  : 		gAlphas[4] = (WORD) ((2 * gAlphas[0] + 3 * gAlphas[1]) / 5);	// Bit code 100
; 570  : 		gAlphas[5] = (WORD) ((   gAlphas[0] + 4 * gAlphas[1]) / 5);		// Bit code 101
; 571  : 		gAlphas[6] = 0;													// Bit code 110

  00331	c7 05 0c 00 00
	00 00 00 ff 00	 mov	 DWORD PTR ?gAlphas@@3PAGA+12, 16711680 ; 00ff0000H
  0033b	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00340	f7 e1		 mul	 ecx
  00342	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00345	c1 ea 02	 shr	 edx, 2
  00348	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  0034b	03 c8		 add	 ecx, eax
  0034d	66 89 15 04 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+4, dx
  00354	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00359	f7 e1		 mul	 ecx
  0035b	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  0035e	c1 ea 02	 shr	 edx, 2
  00361	8d 0c 5b	 lea	 ecx, DWORD PTR [ebx+ebx*2]
  00364	03 c8		 add	 ecx, eax
  00366	66 89 15 06 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+6, dx
  0036d	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00372	f7 e1		 mul	 ecx
  00374	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]
  00377	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0037c	c1 ea 02	 shr	 edx, 2
  0037f	66 89 15 08 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+8, dx
  00386	f7 e1		 mul	 ecx
  00388	c1 ea 02	 shr	 edx, 2
  0038b	66 89 15 0a 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+10, dx
$LN44@Decompress:

; 572  : 		gAlphas[7] = 255;												// Bit code 111
; 573  : 	}
; 574  : 
; 575  : 	// Decode 3-bit fields into array of 16 BYTES with same value
; 576  : 
; 577  : 	// first two rows of 4 pixels each:
; 578  : 	// pRows = (Alpha3BitRows*) & (pAlphaBlock->stuff[0]);
; 579  : 	const DWORD mask = 0x00000007;		// bits = 00 00 01 11
; 580  : 	DWORD bits = *((DWORD*) & (pAlphaBlock->stuff[0]));

  00392	8b 55 b0	 mov	 edx, DWORD PTR _pAlphaBlock$1$[ebp]
  00395	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]

; 581  : 
; 582  : 	gBits[0][0] = (BYTE) (bits & mask);

  00398	8a c1		 mov	 al, cl
  0039a	24 07		 and	 al, 7

; 583  : 	bits >>= 3;

  0039c	c1 e9 03	 shr	 ecx, 3
  0039f	a2 00 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA, al

; 584  : 	gBits[0][1] = (BYTE) (bits & mask);

  003a4	8a c1		 mov	 al, cl
  003a6	24 07		 and	 al, 7

; 585  : 	bits >>= 3;

  003a8	c1 e9 03	 shr	 ecx, 3
  003ab	a2 01 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+1, al

; 586  : 	gBits[0][2] = (BYTE) (bits & mask);

  003b0	8a c1		 mov	 al, cl
  003b2	24 07		 and	 al, 7

; 587  : 	bits >>= 3;

  003b4	c1 e9 03	 shr	 ecx, 3
  003b7	a2 02 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+2, al

; 588  : 	gBits[0][3] = (BYTE) (bits & mask);

  003bc	8a c1		 mov	 al, cl
  003be	24 07		 and	 al, 7

; 589  : 	bits >>= 3;

  003c0	c1 e9 03	 shr	 ecx, 3
  003c3	a2 03 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+3, al

; 590  : 	gBits[1][0] = (BYTE) (bits & mask);

  003c8	8a c1		 mov	 al, cl
  003ca	24 07		 and	 al, 7

; 591  : 	bits >>= 3;

  003cc	c1 e9 03	 shr	 ecx, 3
  003cf	a2 04 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+4, al

; 592  : 	gBits[1][1] = (BYTE) (bits & mask);

  003d4	8a c1		 mov	 al, cl
  003d6	24 07		 and	 al, 7

; 593  : 	bits >>= 3;

  003d8	c1 e9 03	 shr	 ecx, 3
  003db	a2 05 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+5, al

; 594  : 	gBits[1][2] = (BYTE) (bits & mask);

  003e0	8a c1		 mov	 al, cl
  003e2	24 07		 and	 al, 7

; 595  : 	bits >>= 3;

  003e4	c1 e9 03	 shr	 ecx, 3
  003e7	a2 06 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+6, al

; 596  : 	gBits[1][3] = (BYTE) (bits & mask);

  003ec	80 e1 07	 and	 cl, 7
  003ef	88 0d 07 00 00
	00		 mov	 BYTE PTR ?gBits@@3PAY03EA+7, cl

; 597  : 
; 598  : 	// now for last two rows:
; 599  : 	bits = *((DWORD*) & (pAlphaBlock->stuff[3]));		// last 3 bytes

  003f5	8b 4a 05	 mov	 ecx, DWORD PTR [edx+5]

; 600  : 
; 601  : 	gBits[2][0] = (BYTE) (bits & mask);

  003f8	8a c1		 mov	 al, cl
  003fa	24 07		 and	 al, 7

; 602  : 	bits >>= 3;

  003fc	c1 e9 03	 shr	 ecx, 3
  003ff	a2 08 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+8, al
  00404	ba 07 00 00 00	 mov	 edx, OFFSET ?gACol@@3PAY03UColor8888@@A+7

; 603  : 	gBits[2][1] = (BYTE) (bits & mask);

  00409	8a c1		 mov	 al, cl

; 604  : 	bits >>= 3;

  0040b	c1 e9 03	 shr	 ecx, 3
  0040e	24 07		 and	 al, 7
  00410	a2 09 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+9, al

; 605  : 	gBits[2][2] = (BYTE) (bits & mask);

  00415	8a c1		 mov	 al, cl
  00417	24 07		 and	 al, 7

; 606  : 	bits >>= 3;

  00419	c1 e9 03	 shr	 ecx, 3
  0041c	a2 0a 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+10, al

; 607  : 	gBits[2][3] = (BYTE) (bits & mask);

  00421	8a c1		 mov	 al, cl
  00423	24 07		 and	 al, 7

; 608  : 	bits >>= 3;

  00425	c1 e9 03	 shr	 ecx, 3
  00428	a2 0b 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+11, al

; 609  : 	gBits[3][0] = (BYTE) (bits & mask);

  0042d	8a c1		 mov	 al, cl
  0042f	24 07		 and	 al, 7

; 610  : 	bits >>= 3;

  00431	c1 e9 03	 shr	 ecx, 3
  00434	a2 0c 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+12, al

; 611  : 	gBits[3][1] = (BYTE) (bits & mask);

  00439	8a c1		 mov	 al, cl
  0043b	24 07		 and	 al, 7

; 612  : 	bits >>= 3;

  0043d	c1 e9 03	 shr	 ecx, 3
  00440	a2 0d 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+13, al

; 613  : 	gBits[3][2] = (BYTE) (bits & mask);

  00445	8a c1		 mov	 al, cl

; 614  : 	bits >>= 3;

  00447	c1 e9 03	 shr	 ecx, 3
  0044a	24 07		 and	 al, 7

; 615  : 	gBits[3][3] = (BYTE) (bits & mask);

  0044c	80 e1 07	 and	 cl, 7
  0044f	a2 0e 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+14, al
  00454	88 0d 0f 00 00
	00		 mov	 BYTE PTR ?gBits@@3PAY03EA+15, cl
  0045a	b9 01 00 00 00	 mov	 ecx, OFFSET ?gBits@@3PAY03EA+1
  0045f	90		 npad	 1
$LL33@Decompress:

; 616  : 
; 617  : 	// decode the codes into alpha values
; 618  : 	int row, pix;
; 619  : 
; 620  : 	for (row = 0; row < 4; ++row)
; 621  : 	{
; 622  : 		for (pix = 0; pix < 4; ++pix)
; 623  : 		{
; 624  : 			gACol[row][pix].a = (BYTE) gAlphas[gBits[row][pix]];

  00460	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00464	8d 52 10	 lea	 edx, DWORD PTR [edx+16]
  00467	8a 04 45 00 00
	00 00		 mov	 al, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  0046e	88 42 ec	 mov	 BYTE PTR [edx-20], al
  00471	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00474	8a 04 45 00 00
	00 00		 mov	 al, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  0047b	88 42 f0	 mov	 BYTE PTR [edx-16], al
  0047e	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00482	8a 04 45 00 00
	00 00		 mov	 al, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  00489	88 42 f4	 mov	 BYTE PTR [edx-12], al
  0048c	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  00490	83 c1 04	 add	 ecx, 4
  00493	8a 04 45 00 00
	00 00		 mov	 al, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  0049a	88 42 f8	 mov	 BYTE PTR [edx-8], al
  0049d	81 f9 11 00 00
	00		 cmp	 ecx, OFFSET ?gBits@@3PAY03EA+17
  004a3	7c bb		 jl	 SHORT $LL33@Decompress
  004a5	8b 55 98	 mov	 edx, DWORD PTR _alphazero$1$[ebp]

; 625  : 
; 626  : 			assert(gACol[row][pix].r == 0);
; 627  : 			assert(gACol[row][pix].g == 0);
; 628  : 			assert(gACol[row][pix].b == 0);
; 629  : 		}
; 630  : 	}
; 631  : 
; 632  : 	// Write out alpha values to the image bits
; 633  : 	for (row = 0; row < 4; ++row, pImPos += width - 4)

  004a8	b9 04 00 00 00	 mov	 ecx, OFFSET ?gACol@@3PAY03UColor8888@@A+4
  004ad	8b 7d bc	 mov	 edi, DWORD PTR _nWidth$1$[ebp]
$LL39@Decompress:

; 634  : 	{
; 635  : 		// pImPow += pImPos += width - 4 moves to next row down
; 636  : 		for (pix = 0; pix < 4; ++pix)
; 637  : 		{
; 638  : 			// zero the alpha bits of image pixel
; 639  : 			*pImPos &= alphazero;

  004b0	21 16		 and	 DWORD PTR [esi], edx

; 640  : 			*pImPos |= *((DWORD*) &(gACol[row][pix]));	// or the bits into the prev. nulled alpha

  004b2	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  004b5	09 06		 or	 DWORD PTR [esi], eax
  004b7	21 56 04	 and	 DWORD PTR [esi+4], edx
  004ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  004bc	09 46 04	 or	 DWORD PTR [esi+4], eax
  004bf	21 56 08	 and	 DWORD PTR [esi+8], edx
  004c2	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  004c5	09 46 08	 or	 DWORD PTR [esi+8], eax
  004c8	21 56 0c	 and	 DWORD PTR [esi+12], edx
  004cb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  004ce	83 c1 10	 add	 ecx, 16			; 00000010H
  004d1	09 46 0c	 or	 DWORD PTR [esi+12], eax
  004d4	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  004db	03 f0		 add	 esi, eax
  004dd	81 f9 44 00 00
	00		 cmp	 ecx, OFFSET ?gACol@@3PAY03UColor8888@@A+68
  004e3	7c cb		 jl	 SHORT $LL39@Decompress

; 826  : 
; 827  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  004e5	8b 55 b4	 mov	 edx, DWORD PTR _pBlock$1$[ebp]
  004e8	83 45 c0 40	 add	 DWORD PTR tv2671[ebp], 64 ; 00000040H
  004ec	83 c2 08	 add	 edx, 8
  004ef	83 6d ac 01	 sub	 DWORD PTR tv2717[ebp], 1
  004f3	0f 85 ba fb ff
	ff		 jne	 $LL7@Decompress
  004f9	8b 5d a0	 mov	 ebx, DWORD PTR _yblocks$1$[ebp]
  004fc	8b 4d a8	 mov	 ecx, DWORD PTR _pPos$1$[ebp]
  004ff	8b 75 a4	 mov	 esi, DWORD PTR _pdwDest$GSCopy$1$[ebp]
  00502	8b 7d 94	 mov	 edi, DWORD PTR _xblocks$1$[ebp]
$LN2@Decompress:

; 818  : 
; 819  : 	////////////////////////////////
; 820  : 	// Tracef("blocks: x: %d y: %d\n", xblocks, yblocks);
; 821  : 	for (y = 0; y < yblocks; ++y)

  00505	03 4d 90	 add	 ecx, DWORD PTR tv2666[ebp]
  00508	03 75 8c	 add	 esi, DWORD PTR tv2667[ebp]
  0050b	83 eb 01	 sub	 ebx, 1
  0050e	89 4d a8	 mov	 DWORD PTR _pPos$1$[ebp], ecx
  00511	89 75 a4	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], esi
  00514	89 5d a0	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
  00517	0f 85 53 fb ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:

; 850  : 		}
; 851  : 	}
; 852  : }	// dxt5

  0051d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00520	5f		 pop	 edi
  00521	5e		 pop	 esi
  00522	33 cd		 xor	 ecx, ebp
  00524	5b		 pop	 ebx
  00525	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0052a	8b e5		 mov	 esp, ebp
  0052c	5d		 pop	 ebp
  0052d	c2 08 00	 ret	 8
$LN91@Decompress:
  00530	00 00 00 00	 DD	 $LN24@Decompress
  00534	00 00 00 00	 DD	 $LN25@Decompress
  00538	00 00 00 00	 DD	 $LN26@Decompress
  0053c	00 00 00 00	 DD	 $LN27@Decompress
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT5
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
tv1591 = -120						; size = 4
tv1590 = -116						; size = 4
_xblocks$1$ = -112					; size = 4
_pAlphaBlock$1$ = -108					; size = 4
_alphazero$1$ = -104					; size = 4
tv1628 = -100						; size = 4
_yblocks$1$ = -96					; size = 4
_pdwDest$GSCopy$1$ = -92				; size = 4
_pPos$1$ = -88						; size = 4
tv1617 = -84						; size = 4
_pBlock$1$ = -80					; size = 4
tv1626 = -76						; size = 4
tv1532 = -76						; size = 4
_nWidth$1$ = -72					; size = 4
tv1596 = -68						; size = 4
_col_1$ = -64						; size = 4
_col_2$ = -60						; size = 4
_col_3$ = -56						; size = 4
_y$1$ = -52						; size = 4
tv1621 = -52						; size = 4
tv1534 = -52						; size = 4
_col_0$ = -48						; size = 4
_col$1 = -44						; size = 4
_pImPos$1$ = -40					; size = 4
tv1624 = -40						; size = 4
_wrd$2 = -40						; size = 2
_shift$3 = -36						; size = 16
_masks$4 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT3, COMDAT
; _this$ = ecx

; 706  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx

; 707  : 	int xblocks, yblocks;
; 708  : #ifdef DEBUG
; 709  : 	if ((ddsd.dwWidth % 4) != 0)
; 710  : 	{
; 711  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 712  : 	}
; 713  : 
; 714  : 	if ((ddsd.dwHeight % 4) != 0)
; 715  : 	{
; 716  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 717  : 	}
; 718  : 
; 719  : 	Tracef("end check\n");
; 720  : #endif
; 721  : 	UINT nWidth = m_nWidth >> miplevel;
; 722  : 	UINT nHeight = m_nHeight >> miplevel;
; 723  : 
; 724  : 	xblocks = nWidth / 4;
; 725  : 	yblocks = nHeight / 4;
; 726  : 
; 727  : 	int		x, y;
; 728  : 	DWORD * pBase	= (DWORD *) pdwDest;
; 729  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0]; // pos in compressed data
; 730  : 	DWORD * pImPos;	// pos in decompressed data
; 731  : 
; 732  : 	DXTColBlock	* pBlock;
; 733  : 	DXTAlphaBlockExplicit * pAlphaBlock;
; 734  : 
; 735  : 	Color8888 col_0, col_1, col_2, col_3;
; 736  : 	WORD wrd;
; 737  : 
; 738  : 	// fill alphazero with appropriate value to zero out alpha when
; 739  : 	//  alphazero is ANDed with the image color 32 bit DWORD:
; 740  : 	col_0.a = 0;
; 741  : 	col_0.r = col_0.g = col_0.b = 0xff;

  00012	c7 45 d0 ff ff
	ff 00		 mov	 DWORD PTR _col_0$[ebp], 16777215 ; 00ffffffH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	8b 82 00 01 00
	00		 mov	 eax, DWORD PTR [edx+256]
  00024	8b 9a 04 01 00
	00		 mov	 ebx, DWORD PTR [edx+260]
  0002a	8b 75 0c	 mov	 esi, DWORD PTR _pdwDest$[ebp]
  0002d	d3 f8		 sar	 eax, cl
  0002f	57		 push	 edi
  00030	8b f8		 mov	 edi, eax
  00032	d3 fb		 sar	 ebx, cl
  00034	89 45 b8	 mov	 DWORD PTR _nWidth$1$[ebp], eax
  00037	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0003a	8b 4c 82 34	 mov	 ecx, DWORD PTR [edx+eax*4+52]
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 743  : 	DWORD alphazero = *((DWORD *) &col_0);

  0003e	8b 45 d0	 mov	 eax, DWORD PTR _col_0$[ebp]
  00041	c1 eb 02	 shr	 ebx, 2
  00044	c1 ef 02	 shr	 edi, 2
  00047	89 75 a4	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], esi
  0004a	89 7d 90	 mov	 DWORD PTR _xblocks$1$[ebp], edi
  0004d	89 5d a0	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00050	89 4d a8	 mov	 DWORD PTR _pPos$1$[ebp], ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 743  : 	DWORD alphazero = *((DWORD *) &col_0);

  00053	89 45 98	 mov	 DWORD PTR _alphazero$1$[ebp], eax

; 744  : 
; 745  : 	for (y = 0; y < yblocks; ++y)

  00056	85 db		 test	 ebx, ebx
  00058	0f 84 dc 02 00
	00		 je	 $LN3@Decompress

; 706  : {

  0005e	8b 55 b8	 mov	 edx, DWORD PTR _nWidth$1$[ebp]
  00061	c1 e2 06	 shl	 edx, 6
  00064	89 55 88	 mov	 DWORD PTR tv1591[ebp], edx
  00067	8b d7		 mov	 edx, edi
  00069	c1 e2 05	 shl	 edx, 5
  0006c	89 55 8c	 mov	 DWORD PTR tv1590[ebp], edx
  0006f	90		 npad	 1
$LL4@Decompress:

; 746  : 	{
; 747  : 		// 8 bytes per block
; 748  : 		// 1 block for alpha, 1 block for color
; 749  : 		pBlock = (DXTColBlock *) ((DWORD) (pPos + y * xblocks * 16));

  00070	8b d1		 mov	 edx, ecx

; 750  : 
; 751  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00072	85 ff		 test	 edi, edi
  00074	0f 84 a8 02 00
	00		 je	 $LN2@Decompress

; 444  : 	const int   shift[] = { 0, 2, 4, 6 };

  0007a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000

; 358  : 	col_0->a = 0xff;

  00081	c6 45 d3 ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 365  : 
; 366  : 	pCol = (Color565*) & (pBlock->col1);
; 367  : 	col_1->a = 0xff;

  00085	c6 45 c3 ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 415  : 		col_2->r = (BYTE)wrd;
; 416  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 417  : 		col_2->g = (BYTE)wrd;
; 418  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 419  : 		col_2->b = (BYTE)wrd;
; 420  : 		col_2->a = 0xff;

  00089	c6 45 c7 ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 443  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  0008d	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _masks$4[ebp], 3
  00094	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _masks$4[ebp+4], 12 ; 0000000cH
  0009b	c7 45 f4 30 00
	00 00		 mov	 DWORD PTR _masks$4[ebp+8], 48 ; 00000030H
  000a2	c7 45 f8 c0 00
	00 00		 mov	 DWORD PTR _masks$4[ebp+12], 192 ; 000000c0H

; 444  : 	const int   shift[] = { 0, 2, 4, 6 };

  000a9	0f 11 45 dc	 movups	 XMMWORD PTR _shift$3[ebp], xmm0

; 506  : 	col.r = col.g = col.b = 0;

  000ad	66 c7 45 d4 00
	00		 mov	 WORD PTR _col$1[ebp], 0
  000b3	c6 45 d6 00	 mov	 BYTE PTR _col$1[ebp+2], 0

; 746  : 	{
; 747  : 		// 8 bytes per block
; 748  : 		// 1 block for alpha, 1 block for color
; 749  : 		pBlock = (DXTColBlock *) ((DWORD) (pPos + y * xblocks * 16));

  000b7	89 75 bc	 mov	 DWORD PTR tv1596[ebp], esi
  000ba	89 7d ac	 mov	 DWORD PTR tv1617[ebp], edi
  000bd	0f 1f 00	 npad	 3
$LL7@Decompress:

; 359  : 	col_0->r = pCol->nRed;

  000c0	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000c3	8b c1		 mov	 eax, ecx

; 368  : 	col_1->r = pCol->nRed;

  000c5	8b 5a 0a	 mov	 ebx, DWORD PTR [edx+10]

; 752  : 		{
; 753  : 			// inline
; 754  : 			// Get alpha block
; 755  : 			pAlphaBlock = (DXTAlphaBlockExplicit *) pBlock;

  000c8	89 55 94	 mov	 DWORD PTR _pAlphaBlock$1$[ebp], edx

; 756  : 
; 757  : 			// inline func:
; 758  : 			// Get color block & colors
; 759  : 			pBlock++;

  000cb	83 c2 08	 add	 edx, 8

; 359  : 	col_0->r = pCol->nRed;

  000ce	c1 e8 0b	 shr	 eax, 11			; 0000000bH

; 360  : 	col_0->r <<= 3;				// shift to full precision

  000d1	c0 e0 03	 shl	 al, 3
  000d4	89 45 b4	 mov	 DWORD PTR tv1532[ebp], eax
  000d7	88 45 d2	 mov	 BYTE PTR _col_0$[ebp+2], al

; 361  : 	col_0->g = pCol->nGreen;

  000da	8b c1		 mov	 eax, ecx
  000dc	c1 e8 05	 shr	 eax, 5

; 362  : 	col_0->g <<= 2;

  000df	c0 e0 02	 shl	 al, 2
  000e2	89 45 cc	 mov	 DWORD PTR tv1534[ebp], eax

; 363  : 	col_0->b = pCol->nBlue;
; 364  : 	col_0->b <<= 3;

  000e5	8a e1		 mov	 ah, cl

; 756  : 
; 757  : 			// inline func:
; 758  : 			// Get color block & colors
; 759  : 			pBlock++;

  000e7	89 55 b0	 mov	 DWORD PTR _pBlock$1$[ebp], edx

; 370  : 	col_1->g = pCol->nGreen;

  000ea	8b cb		 mov	 ecx, ebx
  000ec	c1 e9 05	 shr	 ecx, 5
  000ef	8b d3		 mov	 edx, ebx

; 371  : 	col_1->g <<= 2;

  000f1	c0 e1 02	 shl	 cl, 2
  000f4	88 45 d1	 mov	 BYTE PTR _col_0$[ebp+1], al

; 372  : 	col_1->b = pCol->nBlue;
; 373  : 	col_1->b <<= 3;

  000f7	8a c3		 mov	 al, bl
  000f9	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  000fc	88 4d c1	 mov	 BYTE PTR _col_1$[ebp+1], cl
  000ff	c0 e0 03	 shl	 al, 3
  00102	0f b6 f9	 movzx	 edi, cl
  00105	8b 4d b4	 mov	 ecx, DWORD PTR tv1532[ebp]
  00108	c0 e4 03	 shl	 ah, 3
  0010b	c0 e2 03	 shl	 dl, 3
  0010e	0f b6 c9	 movzx	 ecx, cl
  00111	88 65 d0	 mov	 BYTE PTR _col_0$[ebp], ah
  00114	88 45 c0	 mov	 BYTE PTR _col_1$[ebp], al
  00117	88 55 c2	 mov	 BYTE PTR _col_1$[ebp+2], dl
  0011a	0f b6 f2	 movzx	 esi, dl
  0011d	0f b6 d0	 movzx	 edx, al
  00120	89 4d d8	 mov	 DWORD PTR tv1624[ebp], ecx
  00123	8b 4d cc	 mov	 ecx, DWORD PTR tv1534[ebp]
  00126	0f b6 c4	 movzx	 eax, ah
  00129	89 45 cc	 mov	 DWORD PTR tv1621[ebp], eax

; 374  : 
; 375  : 	if (pBlock->col0 > pBlock->col1)

  0012c	8b 45 b0	 mov	 eax, DWORD PTR _pBlock$1$[ebp]
  0012f	0f b6 c9	 movzx	 ecx, cl
  00132	89 55 9c	 mov	 DWORD PTR tv1628[ebp], edx
  00135	89 4d b4	 mov	 DWORD PTR tv1626[ebp], ecx
  00138	66 39 18	 cmp	 WORD PTR [eax], bx
  0013b	8b 45 d8	 mov	 eax, DWORD PTR tv1624[ebp]
  0013e	76 72		 jbe	 SHORT $LN12@Decompress

; 376  : 	{
; 377  : 		// Four-color block: derive the other two colors.
; 378  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 379  : 		// These two bit codes correspond to the 2-bit fields
; 380  : 		// stored in the 64-bit block.
; 381  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);
; 382  : 		// no +1 for rounding
; 383  : 		// as bits have been shifted to 888
; 384  : 		col_2->r = (BYTE)wrd;
; 385  : 
; 386  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 387  : 		col_2->g = (BYTE)wrd;
; 388  : 
; 389  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);

  00140	8b 5d 9c	 mov	 ebx, DWORD PTR tv1628[ebp]
  00143	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00146	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH

; 390  : 		col_2->b = (BYTE)wrd;
; 391  : 		col_2->a = 0xff;
; 392  : 
; 393  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 394  : 		col_3->r = (BYTE)wrd;
; 395  : 
; 396  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 397  : 		col_3->g = (BYTE)wrd;
; 398  : 
; 399  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 400  : 		col_3->b = (BYTE)wrd;
; 401  : 		col_3->a = 0xff;

  0014b	c6 45 cb ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  0014f	f7 e1		 mul	 ecx
  00151	8b 45 b4	 mov	 eax, DWORD PTR tv1626[ebp]
  00154	d1 ea		 shr	 edx, 1
  00156	88 55 c6	 mov	 BYTE PTR _col_2$[ebp+2], dl
  00159	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  0015c	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00161	f7 e1		 mul	 ecx
  00163	8b 45 cc	 mov	 eax, DWORD PTR tv1621[ebp]
  00166	d1 ea		 shr	 edx, 1
  00168	88 55 c5	 mov	 BYTE PTR _col_2$[ebp+1], dl
  0016b	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  0016e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00173	f7 e1		 mul	 ecx
  00175	8b 45 d8	 mov	 eax, DWORD PTR tv1624[ebp]
  00178	d1 ea		 shr	 edx, 1
  0017a	88 55 c4	 mov	 BYTE PTR _col_2$[ebp], dl
  0017d	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  00180	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00185	f7 e1		 mul	 ecx
  00187	8b 45 b4	 mov	 eax, DWORD PTR tv1626[ebp]
  0018a	d1 ea		 shr	 edx, 1
  0018c	88 55 ca	 mov	 BYTE PTR _col_3$[ebp+2], dl
  0018f	8d 0c 78	 lea	 ecx, DWORD PTR [eax+edi*2]
  00192	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00197	f7 e1		 mul	 ecx
  00199	8b 45 cc	 mov	 eax, DWORD PTR tv1621[ebp]
  0019c	d1 ea		 shr	 edx, 1
  0019e	88 55 c9	 mov	 BYTE PTR _col_3$[ebp+1], dl
  001a1	8d 0c 58	 lea	 ecx, DWORD PTR [eax+ebx*2]
  001a4	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001a9	f7 e1		 mul	 ecx
  001ab	d1 ea		 shr	 edx, 1
  001ad	88 55 c8	 mov	 BYTE PTR _col_3$[ebp], dl

; 402  : 	}

  001b0	eb 27		 jmp	 SHORT $LN13@Decompress
$LN12@Decompress:

; 403  : 	else
; 404  : 	{
; 405  : 		// Three-color block: derive the other color.
; 406  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 407  : 		// 11 = transparent.
; 408  : 		// These two bit codes correspond to the 2-bit fields
; 409  : 		// stored in the 64-bit block.
; 410  : 
; 411  : 		// explicit for each component, unlike some refrasts...
; 412  : 
; 413  : 		// Tracef("block has alpha\n");
; 414  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001b2	03 c6		 add	 eax, esi

; 421  : 
; 422  : 		col_3->r = 0x00;		// random color to indicate alpha
; 423  : 		col_3->g = 0x00;

  001b4	66 c7 45 c9 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001ba	d1 e8		 shr	 eax, 1
  001bc	88 45 c6	 mov	 BYTE PTR _col_2$[ebp+2], al
  001bf	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  001c2	d1 e8		 shr	 eax, 1
  001c4	88 45 c5	 mov	 BYTE PTR _col_2$[ebp+1], al
  001c7	8b 45 cc	 mov	 eax, DWORD PTR tv1621[ebp]
  001ca	03 c2		 add	 eax, edx

; 424  : 		col_3->b = 0x00;

  001cc	c6 45 c8 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001d0	d1 e8		 shr	 eax, 1
  001d2	88 45 c4	 mov	 BYTE PTR _col_2$[ebp], al

; 425  : 		col_3->a = 0x00;

  001d5	c6 45 cb 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
$LN13@Decompress:

; 760  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 761  : 
; 762  : 			// Decode the color block into the bitmap bits
; 763  : 			// inline func:
; 764  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 765  : 
; 766  : 			DecodeColorBlock(pImPos,

  001d9	8b 55 bc	 mov	 edx, DWORD PTR tv1596[ebp]

; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001dc	33 c0		 xor	 eax, eax
  001de	8b 75 d0	 mov	 esi, DWORD PTR _col_0$[ebp]
  001e1	8b 7d c8	 mov	 edi, DWORD PTR _col_3$[ebp]

; 760  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 761  : 
; 762  : 			// Decode the color block into the bitmap bits
; 763  : 			// inline func:
; 764  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 765  : 
; 766  : 			DecodeColorBlock(pImPos,

  001e4	89 55 d8	 mov	 DWORD PTR _pImPos$1$[ebp], edx

; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001e7	89 45 cc	 mov	 DWORD PTR _y$1$[ebp], eax
  001ea	66 0f 1f 44 00
	00		 npad	 6
$LL18@Decompress:

; 448  : 	{
; 449  : 		// width * 4 bytes per pixel per line
; 450  : 		// each j dxtc row is 4 lines of pixels
; 451  : 
; 452  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 453  : 
; 454  : 		// n steps through pixels
; 455  : 		for (n = 0; n < 4; ++n)

  001f0	33 db		 xor	 ebx, ebx
$LL21@Decompress:

; 456  : 		{
; 457  : 			bits = pColorBlock->row[y] & masks[n];

  001f2	8b 4d b0	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  001f5	0f b6 4c 08 04	 movzx	 ecx, BYTE PTR [eax+ecx+4]
  001fa	8b 44 1d ec	 mov	 eax, DWORD PTR _masks$4[ebp+ebx]
  001fe	23 c1		 and	 eax, ecx

; 458  : 			bits >>= shift[n];

  00200	8b 4c 1d dc	 mov	 ecx, DWORD PTR _shift$3[ebp+ebx]
  00204	d3 e8		 shr	 eax, cl

; 459  : 
; 460  : 			switch (bits)

  00206	83 f8 03	 cmp	 eax, 3
  00209	77 1d		 ja	 SHORT $LN28@Decompress
  0020b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN70@Decompress[eax*4]
$LN24@Decompress:

; 461  : 			{
; 462  : 				case 0:
; 463  : 					*pImPos = *col_0;

  00212	89 32		 mov	 DWORD PTR [edx], esi

; 464  : 					pImPos++; // increment to next DWORD
; 465  : 					break;

  00214	eb 23		 jmp	 SHORT $LN19@Decompress
$LN25@Decompress:

; 466  : 
; 467  : 				case 1:
; 468  : 					*pImPos = *col_1;

  00216	8b 45 c0	 mov	 eax, DWORD PTR _col_1$[ebp]
  00219	89 02		 mov	 DWORD PTR [edx], eax

; 469  : 					pImPos++;
; 470  : 					break;

  0021b	eb 1c		 jmp	 SHORT $LN19@Decompress
$LN26@Decompress:

; 471  : 
; 472  : 				case 2:
; 473  : 					*pImPos = *col_2;

  0021d	8b 45 c4	 mov	 eax, DWORD PTR _col_2$[ebp]
  00220	89 02		 mov	 DWORD PTR [edx], eax

; 474  : 					pImPos++;
; 475  : 					break;

  00222	eb 15		 jmp	 SHORT $LN19@Decompress
$LN27@Decompress:

; 476  : 
; 477  : 				case 3:
; 478  : 					*pImPos = *col_3;

  00224	89 3a		 mov	 DWORD PTR [edx], edi

; 479  : 					pImPos++;
; 480  : 					break;

  00226	eb 11		 jmp	 SHORT $LN19@Decompress
$LN28@Decompress:

; 481  : 
; 482  : 				default:
; 483  : 					Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00228	50		 push	 eax
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0022e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00233	8b 55 d8	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00236	83 c4 08	 add	 esp, 8
$LN19@Decompress:

; 448  : 	{
; 449  : 		// width * 4 bytes per pixel per line
; 450  : 		// each j dxtc row is 4 lines of pixels
; 451  : 
; 452  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 453  : 
; 454  : 		// n steps through pixels
; 455  : 		for (n = 0; n < 4; ++n)

  00239	8b 45 cc	 mov	 eax, DWORD PTR _y$1$[ebp]
  0023c	83 c2 04	 add	 edx, 4
  0023f	83 c3 04	 add	 ebx, 4
  00242	89 55 d8	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00245	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00248	7c a8		 jl	 SHORT $LL21@Decompress

; 445  : 
; 446  : 	// r steps through lines in y
; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0024a	8b 4d b8	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0024d	40		 inc	 eax
  0024e	89 45 cc	 mov	 DWORD PTR _y$1$[ebp], eax
  00251	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00254	83 c2 f0	 add	 edx, -16		; fffffff0H
  00257	89 55 d8	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  0025a	83 f8 04	 cmp	 eax, 4
  0025d	7c 91		 jl	 SHORT $LL18@Decompress

; 767  : 							 pBlock,
; 768  : 							 nWidth,
; 769  : 							 (DWORD *) &col_0, (DWORD *) &col_1, (DWORD *) &col_2, (DWORD *) &col_3);
; 770  : 
; 771  : 			// Overwrite the previous alpha bits with the alpha block
; 772  : 			//  info
; 773  : 			// inline func:
; 774  : 			DecodeAlphaExplicit(pImPos, pAlphaBlock, nWidth, alphazero);

  0025f	8b 75 bc	 mov	 esi, DWORD PTR tv1596[ebp]
  00262	33 ff		 xor	 edi, edi
  00264	8b 5d 98	 mov	 ebx, DWORD PTR _alphazero$1$[ebp]
$LL33@Decompress:

; 512  : 		wrd = pAlphaBlock->row[row];

  00267	8b 45 94	 mov	 eax, DWORD PTR _pAlphaBlock$1$[ebp]
  0026a	0f b7 04 78	 movzx	 eax, WORD PTR [eax+edi*2]
  0026e	47		 inc	 edi

; 513  : 
; 514  : 		// Tracef("0x%.8x\t\t", wrd);
; 515  : 		for (pix = 0; pix < 4; ++pix)
; 516  : 		{
; 517  : 			// zero the alpha bits of image pixel
; 518  : 			*pImPos &= alphazero;
; 519  : 
; 520  : 			col.a = (BYTE) (wrd & 0x000f);		// get only low 4 bits

  0026f	8a c8		 mov	 cl, al
  00271	89 45 d8	 mov	 DWORD PTR _wrd$2[ebp], eax

; 521  : 			//			col.a <<= 4;				// shift to full byte precision
; 522  : 			// NOTE:  with just a << 4 you'll never have alpha
; 523  : 			// of 0xff,  0xf0 is max so pure shift doesn't quite
; 524  : 			// cover full alpha range.
; 525  : 			// It's much cheaper than divide & scale though.
; 526  : 			// To correct for this, and get 0xff for max alpha,
; 527  : 			//  or the low bits back in after left shifting
; 528  : 			col.a = (BYTE) (col.a | (col.a << 4));	// This allows max 4 bit alpha to be 0xff alpha
; 529  : 			//  in final image, and is crude approach to full
; 530  : 			//  range scale
; 531  : 
; 532  : 			*pImPos |= *((DWORD*)&col);	// or the bits into the prev. nulled alpha
; 533  : 
; 534  : 			wrd >>= 4; // move next bits to lowest 4

  00274	66 8b 55 d8	 mov	 dx, WORD PTR _wrd$2[ebp]
  00278	80 e1 0f	 and	 cl, 15			; 0000000fH
  0027b	8a c1		 mov	 al, cl
  0027d	66 c1 ea 04	 shr	 dx, 4
  00281	c0 e0 04	 shl	 al, 4
  00284	0a c1		 or	 al, cl
  00286	66 89 55 d8	 mov	 WORD PTR _wrd$2[ebp], dx
  0028a	88 45 d7	 mov	 BYTE PTR _col$1[ebp+3], al
  0028d	8a ca		 mov	 cl, dl
  0028f	8b 06		 mov	 eax, DWORD PTR [esi]
  00291	80 e1 0f	 and	 cl, 15			; 0000000fH
  00294	23 c3		 and	 eax, ebx
  00296	66 c1 ea 04	 shr	 dx, 4
  0029a	0b 45 d4	 or	 eax, DWORD PTR _col$1[ebp]
  0029d	89 06		 mov	 DWORD PTR [esi], eax
  0029f	8a c1		 mov	 al, cl
  002a1	c0 e0 04	 shl	 al, 4
  002a4	0a c1		 or	 al, cl
  002a6	66 89 55 d8	 mov	 WORD PTR _wrd$2[ebp], dx
  002aa	88 45 d7	 mov	 BYTE PTR _col$1[ebp+3], al
  002ad	8a ca		 mov	 cl, dl
  002af	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002b2	80 e1 0f	 and	 cl, 15			; 0000000fH
  002b5	23 c3		 and	 eax, ebx
  002b7	0b 45 d4	 or	 eax, DWORD PTR _col$1[ebp]
  002ba	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002bd	8a c1		 mov	 al, cl
  002bf	c0 e0 04	 shl	 al, 4
  002c2	0a c1		 or	 al, cl
  002c4	8b 4d d8	 mov	 ecx, DWORD PTR _wrd$2[ebp]
  002c7	88 45 d7	 mov	 BYTE PTR _col$1[ebp+3], al
  002ca	8b c3		 mov	 eax, ebx
  002cc	23 46 08	 and	 eax, DWORD PTR [esi+8]
  002cf	0b 45 d4	 or	 eax, DWORD PTR _col$1[ebp]
  002d2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  002d5	c1 e9 04	 shr	 ecx, 4
  002d8	8a c1		 mov	 al, cl
  002da	c0 e0 04	 shl	 al, 4
  002dd	0a c1		 or	 al, cl
  002df	8b 4d b8	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  002e2	88 45 d7	 mov	 BYTE PTR _col$1[ebp+3], al
  002e5	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  002e8	23 c3		 and	 eax, ebx
  002ea	0b 45 d4	 or	 eax, DWORD PTR _col$1[ebp]
  002ed	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  002f0	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  002f7	03 f0		 add	 esi, eax
  002f9	83 ff 04	 cmp	 edi, 4
  002fc	0f 8c 65 ff ff
	ff		 jl	 $LL33@Decompress

; 750  : 
; 751  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00302	8b 55 b0	 mov	 edx, DWORD PTR _pBlock$1$[ebp]
  00305	83 45 bc 40	 add	 DWORD PTR tv1596[ebp], 64 ; 00000040H
  00309	83 c2 08	 add	 edx, 8
  0030c	83 6d ac 01	 sub	 DWORD PTR tv1617[ebp], 1
  00310	0f 85 aa fd ff
	ff		 jne	 $LL7@Decompress
  00316	8b 4d a8	 mov	 ecx, DWORD PTR _pPos$1$[ebp]
  00319	8b 5d a0	 mov	 ebx, DWORD PTR _yblocks$1$[ebp]
  0031c	8b 75 a4	 mov	 esi, DWORD PTR _pdwDest$GSCopy$1$[ebp]
  0031f	8b 7d 90	 mov	 edi, DWORD PTR _xblocks$1$[ebp]
$LN2@Decompress:

; 744  : 
; 745  : 	for (y = 0; y < yblocks; ++y)

  00322	03 4d 8c	 add	 ecx, DWORD PTR tv1590[ebp]
  00325	03 75 88	 add	 esi, DWORD PTR tv1591[ebp]
  00328	83 eb 01	 sub	 ebx, 1
  0032b	89 4d a8	 mov	 DWORD PTR _pPos$1$[ebp], ecx
  0032e	89 75 a4	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], esi
  00331	89 5d a0	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
  00334	0f 85 36 fd ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:

; 775  : 		}
; 776  : 	}
; 777  : }

  0033a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033d	5f		 pop	 edi
  0033e	5e		 pop	 esi
  0033f	33 cd		 xor	 ecx, ebp
  00341	5b		 pop	 ebx
  00342	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00347	8b e5		 mov	 esp, ebp
  00349	5d		 pop	 ebp
  0034a	c2 08 00	 ret	 8
  0034d	0f 1f 00	 npad	 3
$LN70@Decompress:
  00350	00 00 00 00	 DD	 $LN24@Decompress
  00354	00 00 00 00	 DD	 $LN25@Decompress
  00358	00 00 00 00	 DD	 $LN26@Decompress
  0035c	00 00 00 00	 DD	 $LN27@Decompress
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
tv1134 = -104						; size = 4
_xblocks$1$ = -100					; size = 4
tv1151 = -96						; size = 4
_yblocks$1$ = -92					; size = 4
_pdwDest$GSCopy$1$ = -88				; size = 4
_pPos$1$ = -84						; size = 4
tv1152 = -80						; size = 4
_nWidth$1$ = -76					; size = 4
tv1138 = -72						; size = 4
tv1129 = -68						; size = 4
tv1080 = -68						; size = 4
_pBlock$1$ = -64					; size = 4
_col_1$ = -60						; size = 4
_col_0$ = -56						; size = 4
_pImPos$1$ = -52					; size = 4
tv1130 = -52						; size = 4
_col_2$ = -48						; size = 4
_col_3$ = -44						; size = 4
_y$1$ = -40						; size = 4
tv1128 = -40						; size = 4
tv1082 = -40						; size = 4
_shift$1 = -36						; size = 16
_masks$2 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT1, COMDAT
; _this$ = ecx

; 647  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _pdwDest$[ebp]

; 648  : 	// This was hacked up pretty quick & slopily
; 649  : 	// decompresses to 32 bit format 0xARGB
; 650  : 	int xblocks, yblocks;
; 651  : #ifdef DEBUG
; 652  : 	if ((ddsd.dwWidth % 4) != 0)
; 653  : 	{
; 654  : 		Tracef("****** warning width not div by 4!  %d\n", ddsd.dwWidth);
; 655  : 	}
; 656  : 
; 657  : 	if ((ddsd.dwHeight % 4) != 0)
; 658  : 	{
; 659  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 660  : 	}
; 661  : 
; 662  : 	Tracef("end check\n");
; 663  : #endif
; 664  : 	UINT nWidth = m_nWidth >> miplevel;

  0001a	8b 82 00 01 00
	00		 mov	 eax, DWORD PTR [edx+256]

; 665  : 	UINT nHeight = m_nHeight >> miplevel;

  00020	8b 9a 04 01 00
	00		 mov	 ebx, DWORD PTR [edx+260]
  00026	d3 f8		 sar	 eax, cl
  00028	57		 push	 edi

; 666  : 
; 667  : 	xblocks = nWidth / 4;

  00029	8b f8		 mov	 edi, eax
  0002b	d3 fb		 sar	 ebx, cl
  0002d	89 45 b4	 mov	 DWORD PTR _nWidth$1$[ebp], eax

; 669  : 
; 670  : 	int		x, y;
; 671  : 	DWORD * pBase	= (DWORD *) pdwDest;
; 672  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0];;	// pos in compressed data

  00030	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00033	8b 44 82 34	 mov	 eax, DWORD PTR [edx+eax*4+52]
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 668  : 	yblocks = nHeight / 4;

  00037	c1 eb 02	 shr	 ebx, 2
  0003a	c1 ef 02	 shr	 edi, 2
  0003d	89 75 a8	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], esi
  00040	89 7d 9c	 mov	 DWORD PTR _xblocks$1$[ebp], edi
  00043	89 5d a4	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00046	89 45 ac	 mov	 DWORD PTR _pPos$1$[ebp], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 680  : 	for (y = 0; y < yblocks; ++y)

  00049	85 db		 test	 ebx, ebx
  0004b	0f 84 2f 02 00
	00		 je	 $LN3@Decompress

; 647  : {

  00051	8b 4d b4	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  00054	c1 e1 04	 shl	 ecx, 4
  00057	89 4d 98	 mov	 DWORD PTR tv1134[ebp], ecx
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Decompress:

; 681  : 	{
; 682  : 		// 8 bytes per block
; 683  : 		pBlock = (DXTColBlock *) ((DWORD) pPos + y * xblocks * 8);

  00060	8b d0		 mov	 edx, eax
  00062	89 55 c0	 mov	 DWORD PTR _pBlock$1$[ebp], edx

; 684  : 
; 685  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00065	85 ff		 test	 edi, edi
  00067	0f 84 f6 01 00
	00		 je	 $LN2@Decompress

; 444  : 	const int   shift[] = { 0, 2, 4, 6 };

  0006d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000

; 358  : 	col_0->a = 0xff;

  00074	c6 45 cb ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 360  : 	col_0->r <<= 3;				// shift to full precision
; 361  : 	col_0->g = pCol->nGreen;
; 362  : 	col_0->g <<= 2;
; 363  : 	col_0->b = pCol->nBlue;
; 364  : 	col_0->b <<= 3;
; 365  : 
; 366  : 	pCol = (Color565*) & (pBlock->col1);
; 367  : 	col_1->a = 0xff;

  00078	c6 45 c7 ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 415  : 		col_2->r = (BYTE)wrd;
; 416  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 417  : 		col_2->g = (BYTE)wrd;
; 418  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 419  : 		col_2->b = (BYTE)wrd;
; 420  : 		col_2->a = 0xff;

  0007c	c6 45 d3 ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 443  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  00080	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _masks$2[ebp], 3
  00087	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+4], 12 ; 0000000cH
  0008e	c7 45 f4 30 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+8], 48 ; 00000030H
  00095	c7 45 f8 c0 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+12], 192 ; 000000c0H

; 444  : 	const int   shift[] = { 0, 2, 4, 6 };

  0009c	0f 11 45 dc	 movups	 XMMWORD PTR _shift$1[ebp], xmm0

; 681  : 	{
; 682  : 		// 8 bytes per block
; 683  : 		pBlock = (DXTColBlock *) ((DWORD) pPos + y * xblocks * 8);

  000a0	89 75 b8	 mov	 DWORD PTR tv1138[ebp], esi
  000a3	89 7d b0	 mov	 DWORD PTR tv1152[ebp], edi
$LL7@Decompress:

; 359  : 	col_0->r = pCol->nRed;

  000a6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000a8	8b c1		 mov	 eax, ecx

; 368  : 	col_1->r = pCol->nRed;

  000aa	8b 5a 02	 mov	 ebx, DWORD PTR [edx+2]
  000ad	8b d3		 mov	 edx, ebx
  000af	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  000b2	c0 e0 03	 shl	 al, 3
  000b5	89 45 bc	 mov	 DWORD PTR tv1080[ebp], eax
  000b8	88 45 ca	 mov	 BYTE PTR _col_0$[ebp+2], al
  000bb	8b c1		 mov	 eax, ecx
  000bd	c1 e8 05	 shr	 eax, 5
  000c0	c0 e0 02	 shl	 al, 2
  000c3	89 45 d8	 mov	 DWORD PTR tv1082[ebp], eax
  000c6	8a e1		 mov	 ah, cl

; 369  : 	col_1->r <<= 3;				// shift to full precision
; 370  : 	col_1->g = pCol->nGreen;

  000c8	8b cb		 mov	 ecx, ebx
  000ca	88 45 c9	 mov	 BYTE PTR _col_0$[ebp+1], al
  000cd	c1 e9 05	 shr	 ecx, 5

; 371  : 	col_1->g <<= 2;
; 372  : 	col_1->b = pCol->nBlue;
; 373  : 	col_1->b <<= 3;

  000d0	8a c3		 mov	 al, bl
  000d2	c0 e1 02	 shl	 cl, 2
  000d5	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  000d8	88 4d c5	 mov	 BYTE PTR _col_1$[ebp+1], cl
  000db	c0 e0 03	 shl	 al, 3
  000de	0f b6 f9	 movzx	 edi, cl
  000e1	8b 4d bc	 mov	 ecx, DWORD PTR tv1080[ebp]
  000e4	c0 e4 03	 shl	 ah, 3
  000e7	c0 e2 03	 shl	 dl, 3
  000ea	0f b6 c9	 movzx	 ecx, cl
  000ed	88 65 c8	 mov	 BYTE PTR _col_0$[ebp], ah
  000f0	88 45 c4	 mov	 BYTE PTR _col_1$[ebp], al
  000f3	88 55 c6	 mov	 BYTE PTR _col_1$[ebp+2], dl
  000f6	0f b6 f2	 movzx	 esi, dl
  000f9	0f b6 d0	 movzx	 edx, al
  000fc	89 4d cc	 mov	 DWORD PTR tv1130[ebp], ecx
  000ff	8b 4d d8	 mov	 ecx, DWORD PTR tv1082[ebp]
  00102	0f b6 c4	 movzx	 eax, ah
  00105	89 45 d8	 mov	 DWORD PTR tv1128[ebp], eax

; 374  : 
; 375  : 	if (pBlock->col0 > pBlock->col1)

  00108	8b 45 c0	 mov	 eax, DWORD PTR _pBlock$1$[ebp]
  0010b	0f b6 c9	 movzx	 ecx, cl
  0010e	89 55 a0	 mov	 DWORD PTR tv1151[ebp], edx
  00111	89 4d bc	 mov	 DWORD PTR tv1129[ebp], ecx
  00114	66 39 18	 cmp	 WORD PTR [eax], bx
  00117	8b 45 cc	 mov	 eax, DWORD PTR tv1130[ebp]
  0011a	76 72		 jbe	 SHORT $LN12@Decompress

; 376  : 	{
; 377  : 		// Four-color block: derive the other two colors.
; 378  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 379  : 		// These two bit codes correspond to the 2-bit fields
; 380  : 		// stored in the 64-bit block.
; 381  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);
; 382  : 		// no +1 for rounding
; 383  : 		// as bits have been shifted to 888
; 384  : 		col_2->r = (BYTE)wrd;
; 385  : 
; 386  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 387  : 		col_2->g = (BYTE)wrd;
; 388  : 
; 389  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);

  0011c	8b 5d a0	 mov	 ebx, DWORD PTR tv1151[ebp]
  0011f	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00122	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH

; 390  : 		col_2->b = (BYTE)wrd;
; 391  : 		col_2->a = 0xff;
; 392  : 
; 393  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 394  : 		col_3->r = (BYTE)wrd;
; 395  : 
; 396  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 397  : 		col_3->g = (BYTE)wrd;
; 398  : 
; 399  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 400  : 		col_3->b = (BYTE)wrd;
; 401  : 		col_3->a = 0xff;

  00127	c6 45 d7 ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  0012b	f7 e1		 mul	 ecx
  0012d	8b 45 bc	 mov	 eax, DWORD PTR tv1129[ebp]
  00130	d1 ea		 shr	 edx, 1
  00132	88 55 d2	 mov	 BYTE PTR _col_2$[ebp+2], dl
  00135	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  00138	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0013d	f7 e1		 mul	 ecx
  0013f	8b 45 d8	 mov	 eax, DWORD PTR tv1128[ebp]
  00142	d1 ea		 shr	 edx, 1
  00144	88 55 d1	 mov	 BYTE PTR _col_2$[ebp+1], dl
  00147	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  0014a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0014f	f7 e1		 mul	 ecx
  00151	8b 45 cc	 mov	 eax, DWORD PTR tv1130[ebp]
  00154	d1 ea		 shr	 edx, 1
  00156	88 55 d0	 mov	 BYTE PTR _col_2$[ebp], dl
  00159	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  0015c	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00161	f7 e1		 mul	 ecx
  00163	8b 45 bc	 mov	 eax, DWORD PTR tv1129[ebp]
  00166	d1 ea		 shr	 edx, 1
  00168	88 55 d6	 mov	 BYTE PTR _col_3$[ebp+2], dl
  0016b	8d 0c 78	 lea	 ecx, DWORD PTR [eax+edi*2]
  0016e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00173	f7 e1		 mul	 ecx
  00175	8b 45 d8	 mov	 eax, DWORD PTR tv1128[ebp]
  00178	d1 ea		 shr	 edx, 1
  0017a	88 55 d5	 mov	 BYTE PTR _col_3$[ebp+1], dl
  0017d	8d 0c 58	 lea	 ecx, DWORD PTR [eax+ebx*2]
  00180	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00185	f7 e1		 mul	 ecx
  00187	d1 ea		 shr	 edx, 1
  00189	88 55 d4	 mov	 BYTE PTR _col_3$[ebp], dl

; 402  : 	}

  0018c	eb 27		 jmp	 SHORT $LN13@Decompress
$LN12@Decompress:

; 403  : 	else
; 404  : 	{
; 405  : 		// Three-color block: derive the other color.
; 406  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 407  : 		// 11 = transparent.
; 408  : 		// These two bit codes correspond to the 2-bit fields
; 409  : 		// stored in the 64-bit block.
; 410  : 
; 411  : 		// explicit for each component, unlike some refrasts...
; 412  : 
; 413  : 		// Tracef("block has alpha\n");
; 414  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  0018e	03 c6		 add	 eax, esi

; 421  : 
; 422  : 		col_3->r = 0x00;		// random color to indicate alpha
; 423  : 		col_3->g = 0x00;

  00190	66 c7 45 d5 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  00196	d1 e8		 shr	 eax, 1
  00198	88 45 d2	 mov	 BYTE PTR _col_2$[ebp+2], al
  0019b	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0019e	d1 e8		 shr	 eax, 1
  001a0	88 45 d1	 mov	 BYTE PTR _col_2$[ebp+1], al
  001a3	8b 45 d8	 mov	 eax, DWORD PTR tv1128[ebp]
  001a6	03 c2		 add	 eax, edx

; 424  : 		col_3->b = 0x00;

  001a8	c6 45 d4 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001ac	d1 e8		 shr	 eax, 1
  001ae	88 45 d0	 mov	 BYTE PTR _col_2$[ebp], al

; 425  : 		col_3->a = 0x00;

  001b1	c6 45 d7 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
$LN13@Decompress:

; 686  : 		{
; 687  : 			// inline func:
; 688  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 689  : 
; 690  : 			pImPos = (DWORD *) ((DWORD) pBase + x*16 + (y*4) * nWidth * 4);
; 691  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001b5	8b 55 b8	 mov	 edx, DWORD PTR tv1138[ebp]

; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001b8	33 c0		 xor	 eax, eax
  001ba	8b 75 d4	 mov	 esi, DWORD PTR _col_3$[ebp]
  001bd	8b 7d d0	 mov	 edi, DWORD PTR _col_2$[ebp]

; 686  : 		{
; 687  : 			// inline func:
; 688  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 689  : 
; 690  : 			pImPos = (DWORD *) ((DWORD) pBase + x*16 + (y*4) * nWidth * 4);
; 691  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001c0	89 55 cc	 mov	 DWORD PTR _pImPos$1$[ebp], edx

; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001c3	89 45 d8	 mov	 DWORD PTR _y$1$[ebp], eax
$LL18@Decompress:

; 448  : 	{
; 449  : 		// width * 4 bytes per pixel per line
; 450  : 		// each j dxtc row is 4 lines of pixels
; 451  : 
; 452  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 453  : 
; 454  : 		// n steps through pixels
; 455  : 		for (n = 0; n < 4; ++n)

  001c6	33 db		 xor	 ebx, ebx
  001c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL21@Decompress:

; 456  : 		{
; 457  : 			bits = pColorBlock->row[y] & masks[n];

  001d0	8b 4d c0	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  001d3	0f b6 4c 01 04	 movzx	 ecx, BYTE PTR [ecx+eax+4]
  001d8	8b 44 1d ec	 mov	 eax, DWORD PTR _masks$2[ebp+ebx]
  001dc	23 c1		 and	 eax, ecx

; 458  : 			bits >>= shift[n];

  001de	8b 4c 1d dc	 mov	 ecx, DWORD PTR _shift$1[ebp+ebx]
  001e2	d3 e8		 shr	 eax, cl

; 459  : 
; 460  : 			switch (bits)

  001e4	83 f8 03	 cmp	 eax, 3
  001e7	77 1d		 ja	 SHORT $LN28@Decompress
  001e9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN46@Decompress[eax*4]
$LN24@Decompress:

; 461  : 			{
; 462  : 				case 0:
; 463  : 					*pImPos = *col_0;

  001f0	8b 45 c8	 mov	 eax, DWORD PTR _col_0$[ebp]
  001f3	89 02		 mov	 DWORD PTR [edx], eax

; 464  : 					pImPos++; // increment to next DWORD
; 465  : 					break;

  001f5	eb 20		 jmp	 SHORT $LN19@Decompress
$LN25@Decompress:

; 466  : 
; 467  : 				case 1:
; 468  : 					*pImPos = *col_1;

  001f7	8b 45 c4	 mov	 eax, DWORD PTR _col_1$[ebp]
  001fa	89 02		 mov	 DWORD PTR [edx], eax

; 469  : 					pImPos++;
; 470  : 					break;

  001fc	eb 19		 jmp	 SHORT $LN19@Decompress
$LN26@Decompress:

; 471  : 
; 472  : 				case 2:
; 473  : 					*pImPos = *col_2;

  001fe	89 3a		 mov	 DWORD PTR [edx], edi

; 474  : 					pImPos++;
; 475  : 					break;

  00200	eb 15		 jmp	 SHORT $LN19@Decompress
$LN27@Decompress:

; 476  : 
; 477  : 				case 3:
; 478  : 					*pImPos = *col_3;

  00202	89 32		 mov	 DWORD PTR [edx], esi

; 479  : 					pImPos++;
; 480  : 					break;

  00204	eb 11		 jmp	 SHORT $LN19@Decompress
$LN28@Decompress:

; 481  : 
; 482  : 				default:
; 483  : 					Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00206	50		 push	 eax
  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0020c	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00211	8b 55 cc	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00214	83 c4 08	 add	 esp, 8
$LN19@Decompress:

; 448  : 	{
; 449  : 		// width * 4 bytes per pixel per line
; 450  : 		// each j dxtc row is 4 lines of pixels
; 451  : 
; 452  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 453  : 
; 454  : 		// n steps through pixels
; 455  : 		for (n = 0; n < 4; ++n)

  00217	8b 45 d8	 mov	 eax, DWORD PTR _y$1$[ebp]
  0021a	83 c2 04	 add	 edx, 4
  0021d	83 c3 04	 add	 ebx, 4
  00220	89 55 cc	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00223	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00226	7c a8		 jl	 SHORT $LL21@Decompress

; 445  : 
; 446  : 	// r steps through lines in y
; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00228	8b 4d b4	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0022b	40		 inc	 eax
  0022c	89 45 d8	 mov	 DWORD PTR _y$1$[ebp], eax
  0022f	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00232	83 c2 f0	 add	 edx, -16		; fffffff0H
  00235	89 55 cc	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00238	83 f8 04	 cmp	 eax, 4
  0023b	7c 89		 jl	 SHORT $LL18@Decompress

; 684  : 
; 685  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  0023d	8b 55 c0	 mov	 edx, DWORD PTR _pBlock$1$[ebp]
  00240	83 45 b8 10	 add	 DWORD PTR tv1138[ebp], 16 ; 00000010H
  00244	83 c2 08	 add	 edx, 8
  00247	83 6d b0 01	 sub	 DWORD PTR tv1152[ebp], 1
  0024b	89 55 c0	 mov	 DWORD PTR _pBlock$1$[ebp], edx
  0024e	0f 85 52 fe ff
	ff		 jne	 $LL7@Decompress
  00254	8b 45 ac	 mov	 eax, DWORD PTR _pPos$1$[ebp]
  00257	8b 5d a4	 mov	 ebx, DWORD PTR _yblocks$1$[ebp]
  0025a	8b 75 a8	 mov	 esi, DWORD PTR _pdwDest$GSCopy$1$[ebp]
  0025d	8b 7d 9c	 mov	 edi, DWORD PTR _xblocks$1$[ebp]
  00260	8b 4d 98	 mov	 ecx, DWORD PTR tv1134[ebp]
$LN2@Decompress:

; 680  : 	for (y = 0; y < yblocks; ++y)

  00263	8d 14 fd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*8]
  0026a	03 f1		 add	 esi, ecx
  0026c	03 c2		 add	 eax, edx
  0026e	89 75 a8	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], esi
  00271	83 eb 01	 sub	 ebx, 1
  00274	89 45 ac	 mov	 DWORD PTR _pPos$1$[ebp], eax
  00277	89 5d a4	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
  0027a	0f 85 e0 fd ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:

; 692  : 			// Set to RGB test pattern
; 693  : 			//	pImPos = (DWORD*) ((DWORD) pBase + i * 4 + j * m_nWidth * 4);
; 694  : 			//	*pImPos = ((i * 4) << 16) | ((j * 4) << 8) | ((63 - i) * 4);
; 695  : 
; 696  : 			// checkerboard of only col_0 and col_1 basis colors:
; 697  : 			//	pImPos = (DWORD *) ((DWORD) pBase + i * 8 + j * m_nWidth * 8);
; 698  : 			//	*pImPos = *((DWORD *) &col_0);
; 699  : 			//	pImPos += 1 + m_nWidth;
; 700  : 			//	*pImPos = *((DWORD *) &col_1);
; 701  : 		}
; 702  : 	}
; 703  : }

  00280	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00283	5f		 pop	 edi
  00284	5e		 pop	 esi
  00285	33 cd		 xor	 ecx, ebp
  00287	5b		 pop	 ebx
  00288	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028d	8b e5		 mov	 esp, ebp
  0028f	5d		 pop	 ebp
  00290	c2 08 00	 ret	 8
  00293	90		 npad	 1
$LN46@Decompress:
  00294	00 00 00 00	 DD	 $LN24@Decompress
  00298	00 00 00 00	 DD	 $LN25@Decompress
  0029c	00 00 00 00	 DD	 $LN26@Decompress
  002a0	00 00 00 00	 DD	 $LN27@Decompress
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Decompress@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?Decompress@CDXTCImage@@QAEXHPAK@Z PROC			; CDXTCImage::Decompress, COMDAT
; _this$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 316  : 	switch (m_CompFormat)

  00003	8b 81 ec 00 00
	00		 mov	 eax, DWORD PTR [ecx+236]
  00009	83 f8 05	 cmp	 eax, 5
  0000c	77 1f		 ja	 SHORT $LN8@Decompress
  0000e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@Decompress[eax*4]
$LN4@Decompress:

; 332  : 			break;
; 333  : 
; 334  : 		case PF_UNKNOWN:
; 335  : 			break;
; 336  : 	}
; 337  : }

  00015	5d		 pop	 ebp

; 317  : 	{
; 318  : 		case PF_DXT1:
; 319  : 			DecompressDXT1(miplevel, pdwDest);

  00016	e9 00 00 00 00	 jmp	 ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT1
$LN5@Decompress:

; 332  : 			break;
; 333  : 
; 334  : 		case PF_UNKNOWN:
; 335  : 			break;
; 336  : 	}
; 337  : }

  0001b	5d		 pop	 ebp

; 320  : 			break;
; 321  : 
; 322  : 		case PF_DXT3:
; 323  : 			DecompressDXT3(miplevel, pdwDest);

  0001c	e9 00 00 00 00	 jmp	 ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT3
$LN6@Decompress:

; 332  : 			break;
; 333  : 
; 334  : 		case PF_UNKNOWN:
; 335  : 			break;
; 336  : 	}
; 337  : }

  00021	5d		 pop	 ebp

; 324  : 			break;
; 325  : 
; 326  : 		case PF_DXT5:
; 327  : 			DecompressDXT5(miplevel, pdwDest);

  00022	e9 00 00 00 00	 jmp	 ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT5
$LN7@Decompress:

; 332  : 			break;
; 333  : 
; 334  : 		case PF_UNKNOWN:
; 335  : 			break;
; 336  : 	}
; 337  : }

  00027	5d		 pop	 ebp

; 328  : 			break;
; 329  : 
; 330  : 		case PF_ARGB:
; 331  : 			DecompressARGB(miplevel, pdwDest);

  00028	e9 00 00 00 00	 jmp	 ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressARGB
$LN8@Decompress:

; 332  : 			break;
; 333  : 
; 334  : 		case PF_UNKNOWN:
; 335  : 			break;
; 336  : 	}
; 337  : }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
  00031	0f 1f 00	 npad	 3
$LN10@Decompress:
  00034	00 00 00 00	 DD	 $LN7@Decompress
  00038	00 00 00 00	 DD	 $LN4@Decompress
  0003c	00 00 00 00	 DD	 $LN8@Decompress
  00040	00 00 00 00	 DD	 $LN5@Decompress
  00044	00 00 00 00	 DD	 $LN8@Decompress
  00048	00 00 00 00	 DD	 $LN6@Decompress
?Decompress@CDXTCImage@@QAEXHPAK@Z ENDP			; CDXTCImage::Decompress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Copy@CDXTCImage@@QAE_NHPAEJ@Z
_TEXT	SEGMENT
_miplevel$ = 8						; size = 4
_pbDest$ = 12						; size = 4
_lDestPitch$ = 16					; size = 4
?Copy@CDXTCImage@@QAE_NHPAEJ@Z PROC			; CDXTCImage::Copy, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  : 	if (!(m_dwFlags & DDSD_MIPMAPCOUNT))

  00003	8b 55 08	 mov	 edx, DWORD PTR _miplevel$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	f7 86 fc 00 00
	00 00 00 02 00	 test	 DWORD PTR [esi+252], 131072 ; 00020000H
  00013	75 0b		 jne	 SHORT $LN3@Copy

; 263  : 		if (miplevel)

  00015	85 d2		 test	 edx, edx
  00017	74 07		 je	 SHORT $LN3@Copy

; 264  : 			return false;

  00019	32 c0		 xor	 al, al
  0001b	5e		 pop	 esi

; 285  : }

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN3@Copy:

; 265  : 
; 266  : 	/*
; 267  : 	DXTColBlock * pBlock;
; 268  : 	WORD * pPos = (WORD *) &m_pbCompBufferByLevels[miplevel][0];
; 269  : 	int xblocks = (m_nWidth >> miplevel) / 4;
; 270  : 	int yblocks = (m_nHeight >> miplevel) / 4;
; 271  : 
; 272  : 	for (int y = 0; y < yblocks; ++y)
; 273  : 	{
; 274  : 		// 8 bytes per block
; 275  : 		pBlock = (DXTColBlock*) ((DWORD) pPos + y * xblocks * 8);
; 276  : 
; 277  : 		memcpy(pbDest, pBlock, xblocks * 8);
; 278  : 		pbDest += lDestPitch;
; 279  : 	}
; 280  : 	*/
; 281  : 
; 282  : 	memcpy(pbDest, m_pbCompBufferByLevels[miplevel], m_lPitch >> (miplevel * 2));

  00020	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00026	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  00029	d3 f8		 sar	 eax, cl
  0002b	50		 push	 eax
  0002c	ff 74 96 04	 push	 DWORD PTR [esi+edx*4+4]
  00030	ff 75 0c	 push	 DWORD PTR _pbDest$[ebp]
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 283  : 	pbDest += lDestPitch;
; 284  : 	return true;

  0003b	b0 01		 mov	 al, 1
  0003d	5e		 pop	 esi

; 285  : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?Copy@CDXTCImage@@QAE_NHPAEJ@Z ENDP			; CDXTCImage::Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z
_TEXT	SEGMENT
_ddsd$ = -128						; size = 124
_this$1$ = -4						; size = 4
_c_pbMap$ = 8						; size = 4
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z PROC	; CDXTCImage::LoadHeaderFromMemory, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx

; 132  : 	//////////////////////////////////////
; 133  : 	// start reading the file
; 134  : 	// from Microsoft's mssdk D3DIM example "Compress"
; 135  : 	DWORD dwMagic;
; 136  : 
; 137  : 	// Read magic number
; 138  : 	dwMagic = *(DWORD *) c_pbMap;
; 139  : 	c_pbMap += sizeof(DWORD);

  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _c_pbMap$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 140  : 
; 141  : //!@#
; 142  : //	if (dwMagic != MAKEFOURCC('D','D','S',' '))
; 143  : //		return false;
; 144  : 
; 145  : 	DDSURFACEDESC2 ddsd; // read from dds file
; 146  : 
; 147  : 	// Read the surface description
; 148  : 	memcpy(&ddsd, c_pbMap, sizeof(DDSURFACEDESC2));

  00012	8d 7d 80	 lea	 edi, DWORD PTR _ddsd$[ebp]
  00015	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  00018	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0001d	f3 a5		 rep movsd

; 149  : 	c_pbMap += sizeof(DDSURFACEDESC2);
; 150  : 
; 151  : 	// Does texture have mipmaps?
; 152  : 	m_bMipTexture = (ddsd.dwMipMapCount > 0) ? TRUE : FALSE;

  0001f	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  00022	83 eb 80	 sub	 ebx, -128		; ffffff80H
  00025	8b 7d 98	 mov	 edi, DWORD PTR _ddsd$[ebp+24]

; 153  : 
; 154  : 	// Clear unwanted flags
; 155  : 	// Can't do this!!!  surface not re-created here
; 156  : 	//    ddsd.dwFlags &= (~DDSD_PITCH);
; 157  : 	//    ddsd.dwFlags &= (~DDSD_LINEARSIZE);
; 158  : 
; 159  : 	// Is it DXTC ?
; 160  : 	// I sure hope pixelformat is valid!
; 161  : 	m_xddPixelFormat.dwFlags = ddsd.ddpfPixelFormat.dwFlags;
; 162  : 	m_xddPixelFormat.dwFourCC = ddsd.ddpfPixelFormat.dwFourCC;
; 163  : 	m_xddPixelFormat.dwSize = ddsd.ddpfPixelFormat.dwSize;

  00028	8d 8e 08 01 00
	00		 lea	 ecx, DWORD PTR [esi+264]
  0002e	85 ff		 test	 edi, edi

; 164  : 	m_xddPixelFormat.dwRGBBitCount = ddsd.ddpfPixelFormat.dwRGBBitCount;
; 165  : 	m_xddPixelFormat.dwRGBAlphaBitMask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
; 166  : 	m_xddPixelFormat.dwRBitMask = ddsd.ddpfPixelFormat.dwRBitMask;
; 167  : 	m_xddPixelFormat.dwGBitMask = ddsd.ddpfPixelFormat.dwGBitMask;
; 168  : 	m_xddPixelFormat.dwBBitMask = ddsd.ddpfPixelFormat.dwBBitMask;
; 169  : 
; 170  : 	DecodePixelFormat(m_strFormat, &m_xddPixelFormat);

  00030	51		 push	 ecx
  00031	0f 95 c0	 setne	 al
  00034	88 86 f8 00 00
	00		 mov	 BYTE PTR [esi+248], al
  0003a	8b 45 cc	 mov	 eax, DWORD PTR _ddsd$[ebp+76]
  0003d	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  00043	8b 45 d0	 mov	 eax, DWORD PTR _ddsd$[ebp+80]
  00046	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax
  0004c	8b 45 c8	 mov	 eax, DWORD PTR _ddsd$[ebp+72]
  0004f	89 01		 mov	 DWORD PTR [ecx], eax
  00051	8b ce		 mov	 ecx, esi
  00053	8b 45 d4	 mov	 eax, DWORD PTR _ddsd$[ebp+84]
  00056	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  0005c	8b 45 e4	 mov	 eax, DWORD PTR _ddsd$[ebp+100]
  0005f	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax
  00065	8b 45 d8	 mov	 eax, DWORD PTR _ddsd$[ebp+88]
  00068	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  0006e	8b 45 dc	 mov	 eax, DWORD PTR _ddsd$[ebp+92]
  00071	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  00077	8b 45 e0	 mov	 eax, DWORD PTR _ddsd$[ebp+96]
  0007a	89 86 20 01 00
	00		 mov	 DWORD PTR [esi+288], eax
  00080	8d 86 cc 00 00
	00		 lea	 eax, DWORD PTR [esi+204]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat

; 171  : 
; 172  : 	if (m_CompFormat != PF_DXT1 &&
; 173  : 		m_CompFormat != PF_DXT3 &&

  0008c	8b 86 ec 00 00
	00		 mov	 eax, DWORD PTR [esi+236]
  00092	83 f8 01	 cmp	 eax, 1
  00095	74 15		 je	 SHORT $LN5@LoadHeader
  00097	83 f8 03	 cmp	 eax, 3
  0009a	74 10		 je	 SHORT $LN5@LoadHeader
  0009c	83 f8 05	 cmp	 eax, 5
  0009f	74 0b		 je	 SHORT $LN5@LoadHeader

; 212  : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	32 c0		 xor	 al, al
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
$LN5@LoadHeader:

; 174  : 		m_CompFormat != PF_DXT5)
; 175  : 	{
; 176  : 		return false;
; 177  : 	}
; 178  : 
; 179  : 	if (ddsd.dwMipMapCount > MAX_MIPLEVELS)
; 180  : 		ddsd.dwMipMapCount = MAX_MIPLEVELS;
; 181  : 
; 182  : 	m_nWidth		= ddsd.dwWidth;
; 183  : 	m_nHeight		= ddsd.dwHeight;
; 184  : 	//!@#
; 185  : 	m_dwMipMapCount = max(1, ddsd.dwMipMapCount);
; 186  : 	m_dwFlags		= ddsd.dwFlags;

  000ac	8b 4d 84	 mov	 ecx, DWORD PTR _ddsd$[ebp+4]
  000af	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000b4	3b f8		 cmp	 edi, eax
  000b6	89 8e fc 00 00
	00		 mov	 DWORD PTR [esi+252], ecx
  000bc	0f 47 f8	 cmova	 edi, eax
  000bf	8b 45 8c	 mov	 eax, DWORD PTR _ddsd$[ebp+12]
  000c2	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  000c8	8b 45 88	 mov	 eax, DWORD PTR _ddsd$[ebp+8]
  000cb	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	3b f8		 cmp	 edi, eax
  000d8	0f 42 f8	 cmovb	 edi, eax

; 187  : 
; 188  : 	if (ddsd.dwFlags & DDSD_PITCH)

  000db	8b 45 90	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  000de	89 be f4 00 00
	00		 mov	 DWORD PTR [esi+244], edi
  000e4	89 86 f0 00 00
	00		 mov	 DWORD PTR [esi+240], eax
  000ea	f6 c1 08	 test	 cl, 8
  000ed	75 2f		 jne	 SHORT $LN9@LoadHeader

; 189  : 	{
; 190  : 		m_lPitch = ddsd.lPitch;
; 191  : 		m_pbCompBufferByLevels[0] = c_pbMap;
; 192  : 	}
; 193  : 	else
; 194  : 	{
; 195  : 		m_lPitch = ddsd.dwLinearSize;
; 196  : 
; 197  : 		if (ddsd.dwFlags & DDSD_MIPMAPCOUNT)

  000ef	f7 c1 00 00 02
	00		 test	 ecx, 131072		; 00020000H
  000f5	74 27		 je	 SHORT $LN9@LoadHeader

; 198  : 		{
; 199  : 			for (DWORD dwLinearSize = ddsd.dwLinearSize, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  000f7	33 d2		 xor	 edx, edx
  000f9	85 ff		 test	 edi, edi
  000fb	74 24		 je	 SHORT $LN10@LoadHeader
  000fd	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
$LL4@LoadHeader:

; 200  : 			{
; 201  : 				m_pbCompBufferByLevels[i] = c_pbMap;

  00100	89 19		 mov	 DWORD PTR [ecx], ebx
  00102	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]

; 202  : 				c_pbMap += dwLinearSize;

  00105	03 d8		 add	 ebx, eax
  00107	42		 inc	 edx
  00108	c1 e8 02	 shr	 eax, 2
  0010b	3b 96 f4 00 00
	00		 cmp	 edx, DWORD PTR [esi+244]
  00111	72 ed		 jb	 SHORT $LL4@LoadHeader

; 212  : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	b0 01		 mov	 al, 1
  00117	5b		 pop	 ebx
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 04 00	 ret	 4
$LN9@LoadHeader:

; 203  : 			}
; 204  : 		}
; 205  : 		else
; 206  : 		{
; 207  : 			m_pbCompBufferByLevels[0] = c_pbMap;
; 208  : 		}
; 209  : 	}
; 210  : 
; 211  : 	return true;

  0011e	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$LN10@LoadHeader:
  00121	5f		 pop	 edi

; 212  : }

  00122	5e		 pop	 esi
  00123	b0 01		 mov	 al, 1
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 04 00	 ret	 4
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z ENDP	; CDXTCImage::LoadHeaderFromMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
_dwBytesPerRow$1$ = -4					; size = 4
_yp$1$ = 8						; size = 4
_c_pbMap$ = 8						; size = 4
$T1 = 11						; size = 1
?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z PROC		; CDXTCImage::LoadFromMemory, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 217  : 	if (!LoadHeaderFromMemory(c_pbMap))

  00005	ff 75 08	 push	 DWORD PTR _c_pbMap$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	e8 00 00 00 00	 call	 ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z ; CDXTCImage::LoadHeaderFromMemory
  0000f	84 c0		 test	 al, al
  00011	75 07		 jne	 SHORT $LN8@LoadFromMe
  00013	5b		 pop	 ebx

; 258  : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN8@LoadFromMe:

; 218  : 		return false;
; 219  : 
; 220  : 	if (m_dwFlags & DDSD_PITCH)

  0001a	8b 83 fc 00 00
	00		 mov	 eax, DWORD PTR [ebx+252]
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	a8 08		 test	 al, 8
  00024	0f 84 87 00 00
	00		 je	 $LN9@LoadFromMe

; 221  : 	{
; 222  : 		DWORD dwBytesPerRow = m_nWidth * m_xddPixelFormat.dwRGBBitCount / 8;

  0002a	8b 8b 14 01 00
	00		 mov	 ecx, DWORD PTR [ebx+276]
  00030	0f af 8b 00 01
	00 00		 imul	 ecx, DWORD PTR [ebx+256]

; 223  : 
; 224  : 		m_nCompSize = m_lPitch * m_nHeight;

  00037	8b 83 04 01 00
	00		 mov	 eax, DWORD PTR [ebx+260]
  0003d	0f af 83 f0 00
	00 00		 imul	 eax, DWORD PTR [ebx+240]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	89 4d fc	 mov	 DWORD PTR _dwBytesPerRow$1$[ebp], ecx

; 225  : 		m_nCompLineSz = dwBytesPerRow;

  0004a	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx

; 226  : 
; 227  : 		m_bCompVector[0].resize(m_nCompSize);

  00050	8d 4b 34	 lea	 ecx, DWORD PTR [ebx+52]
  00053	50		 push	 eax
  00054	89 83 c4 00 00
	00		 mov	 DWORD PTR [ebx+196], eax
  0005a	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 231  : 
; 232  : 		for (int yp = 0; yp < m_nHeight; ++yp)

  0005f	83 bb 04 01 00
	00 00		 cmp	 DWORD PTR [ebx+260], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00066	8b 73 34	 mov	 esi, DWORD PTR [ebx+52]
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 230  : 		c_pbMap = m_pbCompBufferByLevels[0];

  00069	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 231  : 
; 232  : 		for (int yp = 0; yp < m_nHeight; ++yp)

  0006c	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _yp$1$[ebp], 0
  00073	0f 8e ec 00 00
	00		 jle	 $LN12@LoadFromMe
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@LoadFromMe:

; 233  : 		{
; 234  : 			memcpy(pDest, c_pbMap, dwBytesPerRow);

  00080	ff 75 fc	 push	 DWORD PTR _dwBytesPerRow$1$[ebp]
  00083	57		 push	 edi
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 _memcpy

; 235  : 			pDest += m_lPitch;

  0008a	8b 83 f0 00 00
	00		 mov	 eax, DWORD PTR [ebx+240]
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	03 f0		 add	 esi, eax

; 236  : 			c_pbMap += m_lPitch;

  00095	03 f8		 add	 edi, eax
  00097	8b 45 08	 mov	 eax, DWORD PTR _yp$1$[ebp]
  0009a	40		 inc	 eax
  0009b	89 45 08	 mov	 DWORD PTR _yp$1$[ebp], eax
  0009e	3b 83 04 01 00
	00		 cmp	 eax, DWORD PTR [ebx+260]
  000a4	7c da		 jl	 SHORT $LL4@LoadFromMe

; 253  : 		}
; 254  : 	}
; 255  : 
; 256  : 	// done reading file
; 257  : 	return true;

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	b0 01		 mov	 al, 1
  000aa	5b		 pop	 ebx

; 258  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
$LN9@LoadFromMe:

; 237  : 		}
; 238  : 	}
; 239  : 	else
; 240  : 	{
; 241  : 		if (m_dwFlags & DDSD_MIPMAPCOUNT)

  000b1	8b bb f0 00 00
	00		 mov	 edi, DWORD PTR [ebx+240]
  000b7	a9 00 00 02 00	 test	 eax, 131072		; 00020000H
  000bc	0f 84 88 00 00
	00		 je	 $LN11@LoadFromMe

; 242  : 		{
; 243  : 			for (DWORD dwLinearSize = m_lPitch, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  000c2	83 bb f4 00 00
	00 00		 cmp	 DWORD PTR [ebx+244], 0
  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  000d0	0f 86 8f 00 00
	00		 jbe	 $LN12@LoadFromMe
  000d6	8d 73 34	 lea	 esi, DWORD PTR [ebx+52]
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@LoadFromMe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  000e0	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000e3	8b 16		 mov	 edx, DWORD PTR [esi]
  000e5	2b ca		 sub	 ecx, edx

; 1216 :         if (_Newsize < _Oldsize) { // trim

  000e7	3b f9		 cmp	 edi, ecx
  000e9	73 05		 jae	 SHORT $LN19@LoadFromMe

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  000eb	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);
; 1220 :             _Mylast = _Newlast;
; 1221 :             return;

  000ee	eb 2a		 jmp	 SHORT $LN37@LoadFromMe
$LN19@LoadFromMe:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  000f0	76 2b		 jbe	 SHORT $LN20@LoadFromMe

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  000f2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f5	2b c2		 sub	 eax, edx

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  000f7	3b f8		 cmp	 edi, eax
  000f9	76 0e		 jbe	 SHORT $LN21@LoadFromMe

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  000fb	8d 45 0b	 lea	 eax, DWORD PTR $T1[ebp]
  000fe	8b ce		 mov	 ecx, esi
  00100	50		 push	 eax
  00101	57		 push	 edi
  00102	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  00107	eb 14		 jmp	 SHORT $LN20@LoadFromMe
$LN21@LoadFromMe:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;
; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00109	8b c7		 mov	 eax, edi

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  0010b	56		 push	 esi

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  0010c	2b c1		 sub	 eax, ecx

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  0010e	50		 push	 eax
  0010f	ff 76 04	 push	 DWORD PTR [esi+4]
  00112	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@LoadFromMe:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 246  : 				Copy(i, &m_bCompVector[i][0], dwLinearSize);

  0011a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN20@LoadFromMe:
  0011d	57		 push	 edi
  0011e	ff 36		 push	 DWORD PTR [esi]
  00120	8b cb		 mov	 ecx, ebx
  00122	ff 75 fc	 push	 DWORD PTR _i$1$[ebp]
  00125	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR _i$1$[ebp]
  0012d	83 c6 0c	 add	 esi, 12			; 0000000cH
  00130	41		 inc	 ecx
  00131	c1 ef 02	 shr	 edi, 2
  00134	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
  00137	3b 8b f4 00 00
	00		 cmp	 ecx, DWORD PTR [ebx+244]
  0013d	72 a1		 jb	 SHORT $LL7@LoadFromMe

; 253  : 		}
; 254  : 	}
; 255  : 
; 256  : 	// done reading file
; 257  : 	return true;

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	b0 01		 mov	 al, 1
  00143	5b		 pop	 ebx

; 258  : }

  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c2 04 00	 ret	 4
$LN11@LoadFromMe:

; 247  : 			}
; 248  : 		}
; 249  : 		else
; 250  : 		{
; 251  : 			m_bCompVector[0].resize(m_lPitch);

  0014a	57		 push	 edi
  0014b	8d 4b 34	 lea	 ecx, DWORD PTR [ebx+52]
  0014e	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 252  : 			Copy(0, &m_bCompVector[0][0], m_lPitch);

  00153	ff b3 f0 00 00
	00		 push	 DWORD PTR [ebx+240]
  00159	8b cb		 mov	 ecx, ebx
  0015b	ff 73 34	 push	 DWORD PTR [ebx+52]
  0015e	6a 00		 push	 0
  00160	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy
$LN12@LoadFromMe:

; 253  : 		}
; 254  : 	}
; 255  : 
; 256  : 	// done reading file
; 257  : 	return true;

  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	b0 01		 mov	 al, 1
  00169	5b		 pop	 ebx

; 258  : }

  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c2 04 00	 ret	 4
?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z ENDP		; CDXTCImage::LoadFromMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_pvMap$ = -344						; size = 4
_mappedFile$ = -340					; size = 324
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z PROC		; CDXTCImage::LoadFromFile, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f9		 mov	 edi, ecx
  00030	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]

; 88   : 	// only understands .dds files for now
; 89   : 	// return true if success
; 90   : 	char * exts[] = { ".DDS" };
; 91   : 	int next = 1;
; 92   : 
; 93   : 	static char fileupper[MAX_PATH+1];
; 94   : 
; 95   : 	strncpy(fileupper, filename, MAX_PATH);

  00033	68 04 01 00 00	 push	 260			; 00000104H
  00038	56		 push	 esi
  00039	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  0003e	e8 00 00 00 00	 call	 _strncpy

; 96   : 	_strupr(fileupper);

  00043	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  00048	e8 00 00 00 00	 call	 __strupr
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_04LFFPHNGG@?4DDS@
  00052	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  00057	e8 00 00 00 00	 call	 _strstr
  0005c	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp

; 105  : 		if (found != NULL)

  0005f	85 c0		 test	 eax, eax
  00061	75 12		 jne	 SHORT $LN6@LoadFromFi

; 106  : 		{
; 107  : 			knownformat = true;
; 108  : 			break;
; 109  : 		}
; 110  : 	}
; 111  : 
; 112  : 	if (knownformat == false)
; 113  : 	{
; 114  : 		Tracef("Unknown file format encountered! [%s]\n", filename);

  00063	56		 push	 esi
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
  00069	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0006e	83 c4 08	 add	 esp, 8

; 115  : 		return(false);

  00071	32 c0		 xor	 al, al
  00073	eb 5b		 jmp	 SHORT $LN1@LoadFromFi
$LN6@LoadFromFi:

; 116  : 	}
; 117  : 
; 118  : 	CMappedFile mappedFile;

  00075	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  0007b	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 119  : 	LPCVOID pvMap;
; 120  : 
; 121  : 	if (!mappedFile.Create(filename, &pvMap, 0, 0))

  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pvMap$[ebp]
  0008a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00091	50		 push	 eax
  00092	56		 push	 esi
  00093	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00099	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  0009e	85 c0		 test	 eax, eax
  000a0	75 12		 jne	 SHORT $LN7@LoadFromFi

; 122  : 	{
; 123  : 		Tracef("Can't open file for reading! [%s]\n", filename);

  000a2	56		 push	 esi
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
  000a8	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000ad	83 c4 08	 add	 esp, 8
  000b0	32 db		 xor	 bl, bl
  000b2	eb 0f		 jmp	 SHORT $LN10@LoadFromFi
$LN7@LoadFromFi:

; 124  : 		return false;
; 125  : 	}
; 126  : 
; 127  : 	return LoadFromMemory((const BYTE*) pvMap);

  000b4	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _pvMap$[ebp]
  000ba	8b cf		 mov	 ecx, edi
  000bc	e8 00 00 00 00	 call	 ?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z ; CDXTCImage::LoadFromMemory
  000c1	8a d8		 mov	 bl, al
$LN10@LoadFromFi:
  000c3	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000c9	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000ce	8a c3		 mov	 al, bl
$LN1@LoadFromFi:

; 128  : }

  000d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000da	59		 pop	 ecx
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	33 cd		 xor	 ecx, ebp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0:
  00000	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z ENDP		; CDXTCImage::LoadFromFile
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
$T1 = 11						; size = 1
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 1240 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00003	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]

; 1240 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000f	2b cf		 sub	 ecx, edi

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00011	3b d1		 cmp	 edx, ecx
  00013	73 0c		 jae	 SHORT $LN4@resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00015	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00018	5f		 pop	 edi

; 1241 :         // trim or append value-initialized elements, provide strong guarantee
; 1242 :         _Resize(_Newsize, _Value_init_tag{});
; 1243 :     }

  00019	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN4@resize:

; 1224 :         if (_Newsize > _Oldsize) { // append

  00021	76 2d		 jbe	 SHORT $LN5@resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00026	2b c7		 sub	 eax, edi

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00028	3b d0		 cmp	 edx, eax
  0002a	76 12		 jbe	 SHORT $LN6@resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  0002c	8d 45 0b	 lea	 eax, DWORD PTR $T1[ebp]
  0002f	8b ce		 mov	 ecx, esi
  00031	50		 push	 eax
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
  00038	5f		 pop	 edi

; 1241 :         // trim or append value-initialized elements, provide strong guarantee
; 1242 :         _Resize(_Newsize, _Value_init_tag{});
; 1243 :     }

  00039	5e		 pop	 esi
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN6@resize:

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  0003e	56		 push	 esi

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  0003f	2b d1		 sub	 edx, ecx

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00041	52		 push	 edx
  00042	ff 76 04	 push	 DWORD PTR [esi+4]
  00045	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1241 :         // trim or append value-initialized elements, provide strong guarantee
; 1242 :         _Resize(_Newsize, _Value_init_tag{});
; 1243 :     }

  0004d	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN5@resize:
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 23		 je	 SHORT $LN4@vector

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  0001e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00025	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0002c	5e		 pop	 esi

; 673  :         _Tidy();
; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0002d	c3		 ret	 0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 447  :     }

  00006	8b c1		 mov	 eax, ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 447  :     }

  00016	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Clear@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
?Clear@CDXTCImage@@QAEXXZ PROC				; CDXTCImage::Clear, COMDAT
; _this$ = ecx

; 79   : {

  00000	56		 push	 esi

; 80   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)

  00001	8d 41 34	 lea	 eax, DWORD PTR [ecx+52]
  00004	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Clear:

; 81   : 		m_bCompVector[i].clear();

  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8d 40 0c	 lea	 eax, DWORD PTR [eax+12]
  00015	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  00018	83 ee 01	 sub	 esi, 1
  0001b	75 f3		 jne	 SHORT $LL4@Clear

; 82   : 
; 83   : 	Initialize();

  0001d	5e		 pop	 esi
  0001e	e9 00 00 00 00	 jmp	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize
?Clear@CDXTCImage@@QAEXXZ ENDP				; CDXTCImage::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Initialize@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
?Initialize@CDXTCImage@@QAEXXZ PROC			; CDXTCImage::Initialize, COMDAT
; _this$ = ecx

; 70   : {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 71   : 	m_nWidth = 0;

  00003	c7 81 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+256], 0

; 72   : 	m_nHeight = 0;

  0000d	c7 81 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+260], 0
  00017	0f 11 41 04	 movups	 XMMWORD PTR [ecx+4], xmm0
  0001b	0f 11 41 14	 movups	 XMMWORD PTR [ecx+20], xmm0
  0001f	0f 11 41 24	 movups	 XMMWORD PTR [ecx+36], xmm0

; 73   : 
; 74   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)
; 75   : 		m_pbCompBufferByLevels[i] = NULL;
; 76   : }

  00023	c3		 ret	 0
?Initialize@CDXTCImage@@QAEXXZ ENDP			; CDXTCImage::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ??1CDXTCImage@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CDXTCImage@@UAE@XZ PROC				; CDXTCImage::~CDXTCImage, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDXTCImage@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 67   : }

  00022	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00027	6a 0c		 push	 12			; 0000000cH
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	8d 41 34	 lea	 eax, DWORD PTR [ecx+52]
  0002e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDXTCImage@@6B@
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
  00049	cc		 int	 3
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CDXTCImage@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDXTCImage@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDXTCImage@@UAE@XZ ENDP				; CDXTCImage::~CDXTCImage
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ??0CDXTCImage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDXTCImage@@QAE@XZ PROC				; CDXTCImage::CDXTCImage, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  0000a	8b f1		 mov	 esi, ecx
  0000c	68 00 00 00 00	 push	 OFFSET ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  00011	6a 0c		 push	 12			; 0000000cH
  00013	6a 0c		 push	 12			; 0000000cH
  00015	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  00018	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0001b	50		 push	 eax
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDXTCImage@@6B@
  00022	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z

; 62   : 	Initialize();

  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize

; 63   : }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??0CDXTCImage@@QAE@XZ ENDP				; CDXTCImage::CDXTCImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);
; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1975 :         __crt_va_end(_ArgList);
; 1976 :         return _Result;
; 1977 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
