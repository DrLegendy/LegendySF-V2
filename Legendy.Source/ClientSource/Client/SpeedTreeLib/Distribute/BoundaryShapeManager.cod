; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?deallocate@?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@QAEXQAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@I@Z ; std::allocator<std::vector<SPoint,std::allocator<SPoint> > >::deallocate
PUBLIC	?_Destroy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@0@Z ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Xlength
PUBLIC	??1SBoundaryShape@@QAE@XZ			; SBoundaryShape::~SBoundaryShape
PUBLIC	??0CBoundaryShapeManager@@QAE@XZ		; CBoundaryShapeManager::CBoundaryShapeManager
PUBLIC	??1CBoundaryShapeManager@@UAE@XZ		; CBoundaryShapeManager::~CBoundaryShapeManager
PUBLIC	?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z	; CBoundaryShapeManager::LoadBsfFile
PUBLIC	?PointInside@CBoundaryShapeManager@@QAE_NMM@Z	; CBoundaryShapeManager::PointInside
PUBLIC	?RandomPoint@CBoundaryShapeManager@@QAE_NAAM0@Z	; CBoundaryShapeManager::RandomPoint
PUBLIC	?PointInShape@CBoundaryShapeManager@@AAE_NAAUSBoundaryShape@@MM@Z ; CBoundaryShapeManager::PointInShape
PUBLIC	?deallocate@?$allocator@USBoundaryShape@@@std@@QAEXQAUSBoundaryShape@@I@Z ; std::allocator<SBoundaryShape>::deallocate
PUBLIC	?_Destroy@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@AAEXPAUSBoundaryShape@@0@Z ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Destroy
PUBLIC	?_Xlength@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@CAXXZ ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Xlength
PUBLIC	??_GCBoundaryShapeManager@@UAEPAXI@Z		; CBoundaryShapeManager::`scalar deleting destructor'
PUBLIC	??0?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@ABV01@@Z ; std::vector<SPoint,std::allocator<SPoint> >::vector<SPoint,std::allocator<SPoint> >
PUBLIC	??1?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@XZ ; std::vector<SPoint,std::allocator<SPoint> >::~vector<SPoint,std::allocator<SPoint> >
PUBLIC	?_Xlength@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@CAXXZ ; std::vector<SPoint,std::allocator<SPoint> >::_Xlength
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Emplace_reallocate@ABUSPoint@@@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAEPAUSPoint@@QAU2@ABU2@@Z ; std::vector<SPoint,std::allocator<SPoint> >::_Emplace_reallocate<SPoint const &>
PUBLIC	??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<SBoundaryShape> >::construct<SBoundaryShape,SBoundaryShape const &>
PUBLIC	??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Emplace_reallocate<SBoundaryShape const &>
PUBLIC	??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Emplace_reallocate<std::vector<SPoint,std::allocator<SPoint> > const &>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Destroy_range@V?$allocator@USPoint@@@std@@@std@@YAXPAUSPoint@@QAU1@AAV?$allocator@USPoint@@@0@@Z ; std::_Destroy_range<std::allocator<SPoint> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Destroy_range<std::allocator<SBoundaryShape> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ; std::_Uninitialized_move<SPoint *,std::allocator<SPoint> >
PUBLIC	??$_Uninitialized_move@PAUSBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@YAPAUSBoundaryShape@@QAU1@0PAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Uninitialized_move<SBoundaryShape *,std::allocator<SBoundaryShape> >
PUBLIC	??$_Uninitialized_move@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
PUBLIC	??1?$_Tidy_guard@V?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >::~_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >
PUBLIC	??$_Copy_memmove@PAUSPoint@@PAU1@@std@@YAPAUSPoint@@PAU1@00@Z ; std::_Copy_memmove<SPoint *,SPoint *>
PUBLIC	??$_Uninitialized_copy@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ; std::_Uninitialized_copy<SPoint *,std::allocator<SPoint> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
PUBLIC	??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CBoundaryShapeManager@@6B@			; CBoundaryShapeManager::`vftable'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0EE@GKKDMKOH@Error?5in?5CBoundaryShapeManager?3@ ; `string'
PUBLIC	??_C@_0EP@MFJNADHG@Error?5in?5CBoundaryShapeManager?3@ ; `string'
PUBLIC	??_C@_0FB@HDPHEENE@Error?5in?5CBoundaryShapeManager?3@ ; `string'
PUBLIC	??_C@_0FD@HJGPFIJI@Error?5in?5CBoundaryShapeManager?3@ ; `string'
PUBLIC	??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@ ; `string'
PUBLIC	??_C@_0EB@KDBLFLMN@Error?5in?5CBoundaryShapeManager?3@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CBoundaryShapeManager@@6B@			; CBoundaryShapeManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBoundaryShapeManager@@@8		; CBoundaryShapeManager `RTTI Type Descriptor'
PUBLIC	??_R3CBoundaryShapeManager@@8			; CBoundaryShapeManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBoundaryShapeManager@@8			; CBoundaryShapeManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBoundaryShapeManager@@8		; CBoundaryShapeManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?frandom@@YAMMM@Z:PROC				; frandom
EXTRN	?random_range@@YAJJJ@Z:PROC			; random_range
EXTRN	??_ECBoundaryShapeManager@@UAEPAXI@Z:PROC	; CBoundaryShapeManager::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ??_R1A@?0A@EA@CBoundaryShapeManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBoundaryShapeManager@@8 DD FLAT:??_R0?AVCBoundaryShapeManager@@@8 ; CBoundaryShapeManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBoundaryShapeManager@@8
rdata$r	ENDS
;	COMDAT ??_R2CBoundaryShapeManager@@8
rdata$r	SEGMENT
??_R2CBoundaryShapeManager@@8 DD FLAT:??_R1A@?0A@EA@CBoundaryShapeManager@@8 ; CBoundaryShapeManager::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBoundaryShapeManager@@8
rdata$r	SEGMENT
??_R3CBoundaryShapeManager@@8 DD 00H			; CBoundaryShapeManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBoundaryShapeManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBoundaryShapeManager@@@8
data$r	SEGMENT
??_R0?AVCBoundaryShapeManager@@@8 DD FLAT:??_7type_info@@6B@ ; CBoundaryShapeManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBoundaryShapeManager@@', 00H
data$r	ENDS
;	COMDAT ??_R4CBoundaryShapeManager@@6B@
rdata$r	SEGMENT
??_R4CBoundaryShapeManager@@6B@ DD 00H			; CBoundaryShapeManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBoundaryShapeManager@@@8
	DD	FLAT:??_R3CBoundaryShapeManager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@KDBLFLMN@Error?5in?5CBoundaryShapeManager?3@
CONST	SEGMENT
??_C@_0EB@KDBLFLMN@Error?5in?5CBoundaryShapeManager?3@ DB 'Error in CBoun'
	DB	'daryShapeManager::LoadBsfFile(): Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@
CONST	SEGMENT
??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@ DB 'Error in CBoun'
	DB	'daryShapeManager::LoadBsfFile(): Could not open ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@HJGPFIJI@Error?5in?5CBoundaryShapeManager?3@
CONST	SEGMENT
??_C@_0FD@HJGPFIJI@Error?5in?5CBoundaryShapeManager?3@ DB 'Error in CBoun'
	DB	'daryShapeManager::LoadBsfFile(): Failed to read number of bou'
	DB	'ndaries', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@HDPHEENE@Error?5in?5CBoundaryShapeManager?3@
CONST	SEGMENT
??_C@_0FB@HDPHEENE@Error?5in?5CBoundaryShapeManager?3@ DB 'Error in CBoun'
	DB	'daryShapeManager::LoadBsfFile(): Failed to read number of con'
	DB	'tours', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@MFJNADHG@Error?5in?5CBoundaryShapeManager?3@
CONST	SEGMENT
??_C@_0EP@MFJNADHG@Error?5in?5CBoundaryShapeManager?3@ DB 'Error in CBoun'
	DB	'daryShapeManager::LoadBsfFile(): Failed to read number of poi'
	DB	'nts', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GKKDMKOH@Error?5in?5CBoundaryShapeManager?3@
CONST	SEGMENT
??_C@_0EE@GKKDMKOH@Error?5in?5CBoundaryShapeManager?3@ DB 'Error in CBoun'
	DB	'daryShapeManager::LoadBsfFile(): Failed to read point', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7CBoundaryShapeManager@@6B@
CONST	SEGMENT
??_7CBoundaryShapeManager@@6B@ DD FLAT:??_R4CBoundaryShapeManager@@6B@ ; CBoundaryShapeManager::`vftable'
	DD	FLAT:??_ECBoundaryShapeManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z$0
__unwindtable$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z$1
__ehfuncinfo$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$0
__tryblocktable$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z DD 00H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$13
__ehfuncinfo$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$5
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SBoundaryShape@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SBoundaryShape@@QAE@ABU0@@Z$1
__ehfuncinfo$??0SBoundaryShape@@QAE@ABU0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SBoundaryShape@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >, COMDAT

; 1527 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00028	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0002b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]

; 1528 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1529 :     // note: only called internally from elsewhere in the STL
; 1530 :     using _Ptrval = typename _Alloc::value_type*;
; 1531 : 
; 1532 :     auto _UFirst      = _Get_unwrapped(_First);

  0002e	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi
  00034	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi
  00037	89 45 f0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1533 :     const auto _ULast = _Get_unwrapped(_Last);
; 1534 : 
; 1535 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1536 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1537 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1538 :         _Dest += _ULast - _UFirst;
; 1539 :     } else {
; 1540 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1541 :         for (; _UFirst != _ULast; ++_UFirst) {

  0003a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	3b f3		 cmp	 esi, ebx
  00046	74 18		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00048	56		 push	 esi
  00049	8b cf		 mov	 ecx, edi
  0004b	e8 00 00 00 00	 call	 ??0?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@ABV01@@Z ; std::vector<SPoint,std::allocator<SPoint> >::vector<SPoint,std::allocator<SPoint> >

; 1509 :         ++_Last;

  00050	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1533 :     const auto _ULast = _Get_unwrapped(_Last);
; 1534 : 
; 1535 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1536 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1537 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1538 :         _Dest += _ULast - _UFirst;
; 1539 :     } else {
; 1540 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1541 :         for (; _UFirst != _ULast; ++_UFirst) {

  00053	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1509 :         ++_Last;

  00056	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi

; 1533 :     const auto _ULast = _Get_unwrapped(_Last);
; 1534 : 
; 1535 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1536 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1537 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1538 :         _Dest += _ULast - _UFirst;
; 1539 :     } else {
; 1540 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1541 :         for (; _UFirst != _ULast; ++_UFirst) {

  00059	3b f3		 cmp	 esi, ebx
  0005b	75 eb		 jne	 SHORT $LL4@Uninitiali
  0005d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
$LN3@Uninitiali:

; 1503 :         _Destroy_range(_First, _Last, _Al);

  00060	50		 push	 eax
  00061	57		 push	 edi
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :             _Backout._Emplace_back(*_UFirst);
; 1543 :         }
; 1544 : 
; 1545 :         _Dest = _Backout._Release();
; 1546 :     }
; 1547 : 
; 1548 :     return _Dest;

  0006b	8b c7		 mov	 eax, edi

; 1549 : }

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >, COMDAT
; _this$ = ecx

; 1503 :         _Destroy_range(_First, _Last, _Al);

  00000	ff 71 08	 push	 DWORD PTR [ecx+8]
  00003	ff 71 04	 push	 DWORD PTR [ecx+4]
  00006	ff 31		 push	 DWORD PTR [ecx]
  00008	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1504 :     }

  00010	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z PROC ; std::_Uninitialized_copy<SPoint *,std::allocator<SPoint> >, COMDAT

; 1527 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1528 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1529 :     // note: only called internally from elsewhere in the STL
; 1530 :     using _Ptrval = typename _Alloc::value_type*;
; 1531 : 
; 1532 :     auto _UFirst      = _Get_unwrapped(_First);
; 1533 :     const auto _ULast = _Get_unwrapped(_Last);
; 1534 : 
; 1535 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1536 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1537 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSPoint@@PAU1@@std@@YAPAUSPoint@@PAU1@00@Z ; std::_Copy_memmove<SPoint *,SPoint *>

; 1538 :         _Dest += _ULast - _UFirst;

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001d	f7 ef		 imul	 edi
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	d1 fa		 sar	 edx, 1
  00024	8b c2		 mov	 eax, edx
  00026	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00029	03 c2		 add	 eax, edx

; 1539 :     } else {
; 1540 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1541 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1542 :             _Backout._Emplace_back(*_UFirst);
; 1543 :         }
; 1544 : 
; 1545 :         _Dest = _Backout._Release();
; 1546 :     }
; 1547 : 
; 1548 :     return _Dest;

  0002b	5f		 pop	 edi
  0002c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002f	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00032	5b		 pop	 ebx

; 1549 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Uninitialized_copy@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ENDP ; std::_Uninitialized_copy<SPoint *,std::allocator<SPoint> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSPoint@@PAU1@@std@@YAPAUSPoint@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUSPoint@@PAU1@@std@@YAPAUSPoint@@PAU1@00@Z PROC ; std::_Copy_memmove<SPoint *,SPoint *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAUSPoint@@PAU1@@std@@YAPAUSPoint@@PAU1@00@Z ENDP ; std::_Copy_memmove<SPoint *,SPoint *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >::~_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >, COMDAT
; _this$ = ecx

; 31   :         if (_Target) {

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	0f 85 00 00 00
	00		 jne	 ?_Tidy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Tidy

; 32   :             _Target->_Tidy();
; 33   :         }
; 34   :     }

  0000a	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >::~_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  0000a	57		 push	 edi

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b cf		 cmp	 ecx, edi
  00010	74 57		 je	 SHORT $LN3@Uninitiali

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00012	8b d6		 mov	 edx, esi
  00014	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00017	2b d1		 sub	 edx, ecx
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00026	8d 40 0c	 lea	 eax, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00029	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00030	c7 44 02 f4 00
	00 00 00	 mov	 DWORD PTR [edx+eax-12], 0

; 386  :         _Myfirst = _Right._Myfirst;

  00038	8b 48 ec	 mov	 ecx, DWORD PTR [eax-20]
  0003b	89 0e		 mov	 DWORD PTR [esi], ecx

; 387  :         _Mylast  = _Right._Mylast;

  0003d	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00040	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00043	83 c6 0c	 add	 esi, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 388  :         _Myend   = _Right._Myend;

  00046	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  00049	89 4c 02 f4	 mov	 DWORD PTR [edx+eax-12], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0004d	8d 48 f8	 lea	 ecx, DWORD PTR [eax-8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 390  :         _Right._Myfirst = pointer();

  00050	c7 40 ec 00 00
	00 00		 mov	 DWORD PTR [eax-20], 0

; 391  :         _Right._Mylast  = pointer();

  00057	c7 40 f0 00 00
	00 00		 mov	 DWORD PTR [eax-16], 0

; 392  :         _Right._Myend   = pointer();

  0005e	c7 40 f4 00 00
	00 00		 mov	 DWORD PTR [eax-12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00065	3b cf		 cmp	 ecx, edi
  00067	75 b7		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1503 :         _Destroy_range(_First, _Last, _Al);

  00069	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0006c	56		 push	 esi
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();

  00076	8b c6		 mov	 eax, esi
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi

; 1664 :     }
; 1665 : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
??$_Uninitialized_move@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@YAPAUSBoundaryShape@@QAU1@0PAU1@AAV?$allocator@USBoundaryShape@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@YAPAUSBoundaryShape@@QAU1@0PAU1@AAV?$allocator@USBoundaryShape@@@0@@Z PROC ; std::_Uninitialized_move<SBoundaryShape *,std::allocator<SBoundaryShape> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  0000a	57		 push	 edi

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b c7		 cmp	 eax, edi
  00010	74 77		 je	 SHORT $LN3@Uninitiali

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00012	8b d6		 mov	 edx, esi
  00014	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00017	2b d0		 sub	 edx, eax
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00026	8d 49 24	 lea	 ecx, DWORD PTR [ecx+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00029	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00030	c7 44 0a dc 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-36], 0

; 386  :         _Myfirst = _Right._Myfirst;

  00038	8b 41 d4	 mov	 eax, DWORD PTR [ecx-44]
  0003b	89 06		 mov	 DWORD PTR [esi], eax

; 387  :         _Mylast  = _Right._Mylast;

  0003d	8b 41 d8	 mov	 eax, DWORD PTR [ecx-40]
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 388  :         _Myend   = _Right._Myend;

  00043	8b 41 dc	 mov	 eax, DWORD PTR [ecx-36]
  00046	89 44 0a dc	 mov	 DWORD PTR [edx+ecx-36], eax

; 389  : 
; 390  :         _Right._Myfirst = pointer();

  0004a	c7 41 d4 00 00
	00 00		 mov	 DWORD PTR [ecx-44], 0

; 391  :         _Right._Mylast  = pointer();

  00051	c7 41 d8 00 00
	00 00		 mov	 DWORD PTR [ecx-40], 0

; 392  :         _Right._Myend   = pointer();

  00058	c7 41 dc 00 00
	00 00		 mov	 DWORD PTR [ecx-36], 0
  0005f	f3 0f 7e 41 e0	 movq	 xmm0, QWORD PTR [ecx-32]
  00064	66 0f d6 46 0c	 movq	 QWORD PTR [esi+12], xmm0
  00069	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  0006c	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0006f	f3 0f 7e 41 ec	 movq	 xmm0, QWORD PTR [ecx-20]
  00074	66 0f d6 46 18	 movq	 QWORD PTR [esi+24], xmm0
  00079	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  0007c	89 46 20	 mov	 DWORD PTR [esi+32], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0007f	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]

; 1509 :         ++_Last;

  00082	83 c6 24	 add	 esi, 36			; 00000024H

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00085	3b c7		 cmp	 eax, edi
  00087	75 97		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1503 :         _Destroy_range(_First, _Last, _Al);

  00089	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0008c	56		 push	 esi
  0008d	56		 push	 esi
  0008e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Destroy_range<std::allocator<SBoundaryShape> >
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();

  00096	8b c6		 mov	 eax, esi
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 1664 :     }
; 1665 : }

  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
??$_Uninitialized_move@PAUSBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@YAPAUSBoundaryShape@@QAU1@0PAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ENDP ; std::_Uninitialized_move<SBoundaryShape *,std::allocator<SBoundaryShape> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z PROC ; std::_Uninitialized_move<SPoint *,std::allocator<SPoint> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSPoint@@PAU1@@std@@YAPAUSPoint@@PAU1@00@Z ; std::_Copy_memmove<SPoint *,SPoint *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001d	f7 ef		 imul	 edi
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	d1 fa		 sar	 edx, 1
  00024	8b c2		 mov	 eax, edx
  00026	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00029	03 c2		 add	 eax, edx
  0002b	5f		 pop	 edi
  0002c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002f	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00032	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Uninitialized_move@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ENDP ; std::_Uninitialized_move<SPoint *,std::allocator<SPoint> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 959  :         for (; _First != _Last; ++_First) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 48		 je	 SHORT $LN3@Destroy_ra
  0000f	57		 push	 edi
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00010	8b 3e		 mov	 edi, DWORD PTR [esi]
  00012	85 ff		 test	 edi, edi
  00014	74 39		 je	 SHORT $LN14@Destroy_ra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	2b cf		 sub	 ecx, edi
  00020	f7 e9		 imul	 ecx
  00022	d1 fa		 sar	 edx, 1
  00024	8b c2		 mov	 eax, edx
  00026	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00029	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002e	c1 e0 02	 shl	 eax, 2
  00031	50		 push	 eax
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003e	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN14@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  0004f	83 c6 0c	 add	 esi, 12			; 0000000cH
  00052	3b f3		 cmp	 esi, ebx
  00054	75 ba		 jne	 SHORT $LL4@Destroy_ra
  00056	5f		 pop	 edi
$LN3@Destroy_ra:
  00057	5e		 pop	 esi

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00058	5b		 pop	 ebx
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SBoundaryShape> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 959  :         for (; _First != _Last; ++_First) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 54		 je	 SHORT $LN3@Destroy_ra
  0000f	57		 push	 edi
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	85 c0		 test	 eax, eax
  00014	74 45		 je	 SHORT $LN17@Destroy_ra

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00016	56		 push	 esi
  00017	ff 76 04	 push	 DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00020	8b 3e		 mov	 edi, DWORD PTR [esi]
  00022	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00027	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002a	2b cf		 sub	 ecx, edi
  0002c	f7 e9		 imul	 ecx
  0002e	d1 fa		 sar	 edx, 1
  00030	8b c2		 mov	 eax, edx
  00032	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00035	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00037	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0003a	c1 e0 02	 shl	 eax, 2
  0003d	50		 push	 eax
  0003e	57		 push	 edi
  0003f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00044	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0004a	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  0004d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00054	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN17@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  0005b	83 c6 24	 add	 esi, 36			; 00000024H
  0005e	3b f3		 cmp	 esi, ebx
  00060	75 ae		 jne	 SHORT $LL4@Destroy_ra
  00062	5f		 pop	 edi
$LN3@Destroy_ra:
  00063	5e		 pop	 esi

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00064	5b		 pop	 ebx
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SBoundaryShape> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USPoint@@@std@@@std@@YAXPAUSPoint@@QAU1@AAV?$allocator@USPoint@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USPoint@@@std@@@std@@YAXPAUSPoint@@QAU1@AAV?$allocator@USPoint@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SPoint> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@USPoint@@@std@@@std@@YAXPAUSPoint@@QAU1@AAV?$allocator@USPoint@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SPoint> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 902  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 903  :         _Left = _STD move(_Right);
; 904  :     }
; 905  : }

  00000	c2 00 00	 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 268  :     _Obj.~_Ty();
; 269  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z
_TEXT	SEGMENT
__Newvec$ = -44						; size = 4
_this$ = -40						; size = 4
tv383 = -36						; size = 4
tv384 = -32						; size = 4
__Newsize$1$ = -28					; size = 4
__Newcapacity$ = -24					; size = 4
__Whereoff$1$ = -20					; size = 4
__Constructed_last$ = -20				; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z PROC ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Emplace_reallocate<std::vector<SPoint,std::allocator<SPoint> > const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d d8	 mov	 DWORD PTR _this$[ebp], edi

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00030	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00032	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00037	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0003a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003d	2b d3		 sub	 edx, ebx
  0003f	f7 ea		 imul	 edx
  00041	2b cb		 sub	 ecx, ebx
  00043	d1 fa		 sar	 edx, 1
  00045	8b c2		 mov	 eax, edx
  00047	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004a	03 c2		 add	 eax, edx
  0004c	89 45 ec	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0004f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00054	f7 e9		 imul	 ecx
  00056	d1 fa		 sar	 edx, 1
  00058	8b f2		 mov	 esi, edx
  0005a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0005d	03 f2		 add	 esi, edx

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0005f	81 fe 55 55 55
	15		 cmp	 esi, 357913941		; 15555555H
  00065	0f 84 36 01 00
	00		 je	 $LN44@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0006e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00073	2b cb		 sub	 ecx, ebx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00075	46		 inc	 esi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00076	f7 e9		 imul	 ecx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00078	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0007d	89 75 e4	 mov	 DWORD PTR __Newsize$1$[ebp], esi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00080	d1 fa		 sar	 edx, 1
  00082	8b ca		 mov	 ecx, edx
  00084	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00087	03 ca		 add	 ecx, edx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00089	8b d1		 mov	 edx, ecx
  0008b	d1 ea		 shr	 edx, 1
  0008d	2b c2		 sub	 eax, edx
  0008f	3b c8		 cmp	 ecx, eax
  00091	76 07		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00093	8b c6		 mov	 eax, esi
  00095	89 75 e8	 mov	 DWORD PTR __Newcapacity$[ebp], esi
  00098	eb 0b		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0009a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0009d	3b c6		 cmp	 eax, esi
  0009f	0f 42 c6	 cmovb	 eax, esi
  000a2	89 45 e8	 mov	 DWORD PTR __Newcapacity$[ebp], eax
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  000a5	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  000aa	0f 87 f6 00 00
	00		 ja	 $LN45@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000b0	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000b3	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000b6	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  000b7	89 45 e0	 mov	 DWORD PTR tv384[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000ba	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000bf	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 748  :         _TRY_BEGIN

  000c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000c8	8b 45 ec	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000cb	83 c4 04	 add	 esp, 4
  000ce	89 5d d4	 mov	 DWORD PTR __Newvec$[ebp], ebx

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000d1	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000d4	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000d7	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  000da	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  000dd	89 4d dc	 mov	 DWORD PTR tv383[ebp], ecx
  000e0	89 45 ec	 mov	 DWORD PTR __Constructed_last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000e3	e8 00 00 00 00	 call	 ??0?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@ABV01@@Z ; std::vector<SPoint,std::allocator<SPoint> >::vector<SPoint,std::allocator<SPoint> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000e8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000eb	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  000ee	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000f0	3b d0		 cmp	 edx, eax
  000f2	75 04		 jne	 SHORT $LN4@Emplace_re

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000f4	8b d3		 mov	 edx, ebx

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  000f6	eb 15		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000f8	57		 push	 edi
  000f9	53		 push	 ebx
  000fa	52		 push	 edx
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
  00101	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00104	83 c4 10	 add	 esp, 16			; 00000010H
  00107	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0010a	8b 55 ec	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
$LN5@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0010d	57		 push	 edi
  0010e	52		 push	 edx
  0010f	50		 push	 eax
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00116	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00118	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  0011b	85 c9		 test	 ecx, ecx
  0011d	74 34		 je	 SHORT $LN35@Emplace_re

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0011f	57		 push	 edi
  00120	ff 77 04	 push	 DWORD PTR [edi+4]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00129	8b 37		 mov	 esi, DWORD PTR [edi]
  0012b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00130	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00133	2b ce		 sub	 ecx, esi
  00135	f7 e9		 imul	 ecx
  00137	d1 fa		 sar	 edx, 1
  00139	8b c2		 mov	 eax, edx
  0013b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0013e	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00140	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00143	c1 e0 02	 shl	 eax, 2
  00146	50		 push	 eax
  00147	56		 push	 esi
  00148	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0014d	8b 75 e4	 mov	 esi, DWORD PTR __Newsize$1$[ebp]
  00150	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 766  :         return _Newvec + _Whereoff;

  00153	8b 45 dc	 mov	 eax, DWORD PTR tv383[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00156	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00159	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  0015c	89 1f		 mov	 DWORD PTR [edi], ebx
  0015e	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00161	8b 4d e0	 mov	 ecx, DWORD PTR tv384[ebp]
  00164	03 cb		 add	 ecx, ebx
  00166	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 767  :     }

  00169	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0016c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00173	59		 pop	 ecx
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 08 00	 ret	 8
__catch$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0017d	8b 45 ec	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00180	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	50		 push	 eax
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@0@Z ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0018a	ff 75 e8	 push	 DWORD PTR __Newcapacity$[ebp]
  0018d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	ff 75 d4	 push	 DWORD PTR __Newvec$[ebp]
  00193	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@QAEXQAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@I@Z ; std::allocator<std::vector<SPoint,std::allocator<SPoint> > >::deallocate

; 762  :         _RERAISE;

  00198	6a 00		 push	 0
  0019a	6a 00		 push	 0
  0019c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Emplace_re:

; 738  :             _Xlength();

  001a1	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Xlength
$LN45@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  001a6	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN42@Emplace_re:
  001ab	cc		 int	 3
  001ac	cc		 int	 3
  001ad	cc		 int	 3
  001ae	cc		 int	 3
  001af	cc		 int	 3
  001b0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z ENDP ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Emplace_reallocate<std::vector<SPoint,std::allocator<SPoint> > const &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Newvec$ = -44						; size = 4
_this$ = -40						; size = 4
tv383 = -36						; size = 4
tv384 = -32						; size = 4
__Newsize$1$ = -28					; size = 4
__Newcapacity$ = -24					; size = 4
__Whereoff$1$ = -20					; size = 4
__Constructed_last$ = -20				; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z PROC ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Emplace_reallocate<SBoundaryShape const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d d8	 mov	 DWORD PTR _this$[ebp], edi

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00030	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00032	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00037	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0003a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003d	2b d3		 sub	 edx, ebx
  0003f	f7 ea		 imul	 edx
  00041	2b cb		 sub	 ecx, ebx
  00043	c1 fa 03	 sar	 edx, 3
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx
  0004d	89 45 ec	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  00050	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00055	f7 e9		 imul	 ecx
  00057	c1 fa 03	 sar	 edx, 3
  0005a	8b f2		 mov	 esi, edx
  0005c	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0005f	03 f2		 add	 esi, edx

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00061	81 fe c7 71 1c
	07		 cmp	 esi, 119304647		; 071c71c7H
  00067	0f 84 3a 01 00
	00		 je	 $LN42@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00070	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00075	2b cb		 sub	 ecx, ebx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00077	46		 inc	 esi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00078	f7 e9		 imul	 ecx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0007a	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0007f	89 75 e4	 mov	 DWORD PTR __Newsize$1$[ebp], esi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00082	c1 fa 03	 sar	 edx, 3
  00085	8b ca		 mov	 ecx, edx
  00087	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0008a	03 ca		 add	 ecx, edx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0008c	8b d1		 mov	 edx, ecx
  0008e	d1 ea		 shr	 edx, 1
  00090	2b c2		 sub	 eax, edx
  00092	3b c8		 cmp	 ecx, eax
  00094	76 07		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00096	8b c6		 mov	 eax, esi
  00098	89 75 e8	 mov	 DWORD PTR __Newcapacity$[ebp], esi
  0009b	eb 0b		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0009d	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  000a0	3b c6		 cmp	 eax, esi
  000a2	0f 42 c6	 cmovb	 eax, esi
  000a5	89 45 e8	 mov	 DWORD PTR __Newcapacity$[ebp], eax
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  000a8	3d c7 71 1c 07	 cmp	 eax, 119304647		; 071c71c7H
  000ad	0f 87 f9 00 00
	00		 ja	 $LN43@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000b3	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  000b6	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000b9	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  000ba	89 45 e0	 mov	 DWORD PTR tv384[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000bd	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000c2	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000c5	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 748  :         _TRY_BEGIN

  000c7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ce	8b 45 ec	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000d1	89 5d d4	 mov	 DWORD PTR __Newvec$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000d4	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  000d7	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000da	51		 push	 ecx
  000db	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  000de	89 4d dc	 mov	 DWORD PTR tv383[ebp], ecx
  000e1	57		 push	 edi
  000e2	89 45 ec	 mov	 DWORD PTR __Constructed_last$[ebp], eax
  000e5	e8 00 00 00 00	 call	 ??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<SBoundaryShape> >::construct<SBoundaryShape,SBoundaryShape const &>

; 750  :         _Constructed_first = _Newvec + _Whereoff;
; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ea	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ed	83 c4 10	 add	 esp, 16			; 00000010H
  000f0	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  000f3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000f5	3b d0		 cmp	 edx, eax
  000f7	75 04		 jne	 SHORT $LN4@Emplace_re

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000f9	8b d3		 mov	 edx, ebx

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  000fb	eb 15		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000fd	57		 push	 edi
  000fe	53		 push	 ebx
  000ff	52		 push	 edx
  00100	51		 push	 ecx
  00101	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@YAPAUSBoundaryShape@@QAU1@0PAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Uninitialized_move<SBoundaryShape *,std::allocator<SBoundaryShape> >
  00106	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00109	83 c4 10	 add	 esp, 16			; 00000010H
  0010c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0010f	8b 55 ec	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
$LN5@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00112	57		 push	 edi
  00113	52		 push	 edx
  00114	50		 push	 eax
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@YAPAUSBoundaryShape@@QAU1@0PAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Uninitialized_move<SBoundaryShape *,std::allocator<SBoundaryShape> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  0011b	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0011d	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00120	85 c9		 test	 ecx, ecx
  00122	74 35		 je	 SHORT $LN33@Emplace_re

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00124	57		 push	 edi
  00125	ff 77 04	 push	 DWORD PTR [edi+4]
  00128	51		 push	 ecx
  00129	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Destroy_range<std::allocator<SBoundaryShape> >

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0012e	8b 37		 mov	 esi, DWORD PTR [edi]
  00130	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00135	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00138	2b ce		 sub	 ecx, esi
  0013a	f7 e9		 imul	 ecx
  0013c	c1 fa 03	 sar	 edx, 3
  0013f	8b c2		 mov	 eax, edx
  00141	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00144	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00146	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00149	c1 e0 02	 shl	 eax, 2
  0014c	50		 push	 eax
  0014d	56		 push	 esi
  0014e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00153	8b 75 e4	 mov	 esi, DWORD PTR __Newsize$1$[ebp]
  00156	83 c4 14	 add	 esp, 20			; 00000014H
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 766  :         return _Newvec + _Whereoff;

  00159	8b 45 dc	 mov	 eax, DWORD PTR tv383[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0015c	8d 0c f6	 lea	 ecx, DWORD PTR [esi+esi*8]
  0015f	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  00162	89 1f		 mov	 DWORD PTR [edi], ebx
  00164	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00167	8b 4d e0	 mov	 ecx, DWORD PTR tv384[ebp]
  0016a	03 cb		 add	 ecx, ebx
  0016c	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 767  :     }

  0016f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00172	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00179	59		 pop	 ecx
  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 08 00	 ret	 8
__catch$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00183	8b 45 ec	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00186	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	50		 push	 eax
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@AAEXPAUSBoundaryShape@@0@Z ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00190	ff 75 e8	 push	 DWORD PTR __Newcapacity$[ebp]
  00193	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	ff 75 d4	 push	 DWORD PTR __Newvec$[ebp]
  00199	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USBoundaryShape@@@std@@QAEXQAUSBoundaryShape@@I@Z ; std::allocator<SBoundaryShape>::deallocate

; 762  :         _RERAISE;

  0019e	6a 00		 push	 0
  001a0	6a 00		 push	 0
  001a2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN42@Emplace_re:

; 738  :             _Xlength();

  001a7	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@CAXXZ ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Xlength
$LN43@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  001ac	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN40@Emplace_re:
  001b1	cc		 int	 3
  001b2	cc		 int	 3
  001b3	cc		 int	 3
  001b4	cc		 int	 3
  001b5	cc		 int	 3
  001b6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z ENDP ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Emplace_reallocate<SBoundaryShape const &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z
_TEXT	SEGMENT
__Guard$2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Rightlast$1$ = 12					; size = 4
__Ptr$ = 12						; size = 4
__Rightfirst$1$ = 16					; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SBoundaryShape> >::construct<SBoundaryShape,SBoundaryShape const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00026	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]

; 525  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00029	8b 5d 10	 mov	 ebx, DWORD PTR _<_Args_0>$[ebp]

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00032	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00039	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 525  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00040	8b 03		 mov	 eax, DWORD PTR [ebx]

; 526  :         const pointer _Rightlast  = _Right_data._Mylast;

  00042	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00045	89 45 10	 mov	 DWORD PTR __Rightfirst$1$[ebp], eax
  00048	89 4d 0c	 mov	 DWORD PTR __Rightlast$1$[ebp], ecx

; 527  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 528  :         if (_Rightfirst != _Rightlast) {

  0004b	3b c1		 cmp	 eax, ecx
  0004d	74 4d		 je	 SHORT $LN27@construct

; 529  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0004f	2b c8		 sub	 ecx, eax
  00051	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00056	f7 e9		 imul	 ecx
  00058	d1 fa		 sar	 edx, 1
  0005a	8b c2		 mov	 eax, edx
  0005c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005f	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00061	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00066	77 66		 ja	 SHORT $LN34@construct

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00068	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  0006b	c1 e6 02	 shl	 esi, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1643 :         _Myfirst           = _Newvec;

  00074	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  00076	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 530  :             _Tidy_guard<vector> _Guard{this};

  00079	89 7d f0	 mov	 DWORD PTR __Guard$2[ebp], edi

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  0007c	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0007f	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00082	57		 push	 edi
  00083	50		 push	 eax
  00084	ff 75 0c	 push	 DWORD PTR __Rightlast$1$[ebp]

; 530  :             _Tidy_guard<vector> _Guard{this};

  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0008e	ff 75 10	 push	 DWORD PTR __Rightfirst$1$[ebp]
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@YAPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<SPoint,std::allocator<SPoint> > *,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
  00096	83 c4 14	 add	 esp, 20			; 00000014H

; 531  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00099	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN27@construct:
  0009c	f3 0f 7e 43 0c	 movq	 xmm0, QWORD PTR [ebx+12]
  000a1	66 0f d6 47 0c	 movq	 QWORD PTR [edi+12], xmm0
  000a6	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000a9	89 47 14	 mov	 DWORD PTR [edi+20], eax
  000ac	f3 0f 7e 43 18	 movq	 xmm0, QWORD PTR [ebx+24]
  000b1	66 0f d6 47 18	 movq	 QWORD PTR [edi+24], xmm0
  000b6	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000b9	89 47 20	 mov	 DWORD PTR [edi+32], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 695  :     }

  000bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c6	59		 pop	 ecx
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN34@construct:

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000ce	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN32@construct:
  000d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z$1:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >::~_Tidy_guard<std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SBoundaryShape> >::construct<SBoundaryShape,SBoundaryShape const &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSPoint@@@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAEPAUSPoint@@QAU2@ABU2@@Z
_TEXT	SEGMENT
tv377 = -8						; size = 4
tv376 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSPoint@@@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAEPAUSPoint@@QAU2@ABU2@@Z PROC ; std::vector<SPoint,std::allocator<SPoint> >::_Emplace_reallocate<SPoint const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00009	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	57		 push	 edi
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	2b d7		 sub	 edx, edi

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	f7 ea		 imul	 edx
  0001c	2b cf		 sub	 ecx, edi
  0001e	d1 fa		 sar	 edx, 1
  00020	8b c2		 mov	 eax, edx
  00022	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00025	03 c2		 add	 eax, edx
  00027	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0002a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0002f	f7 e9		 imul	 ecx
  00031	d1 fa		 sar	 edx, 1
  00033	8b da		 mov	 ebx, edx
  00035	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00038	03 da		 add	 ebx, edx

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0003a	81 fb 55 55 55
	15		 cmp	 ebx, 357913941		; 15555555H
  00040	0f 84 ec 00 00
	00		 je	 $LN41@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00046	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00049	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004e	2b cf		 sub	 ecx, edi

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00050	43		 inc	 ebx

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00051	f7 e9		 imul	 ecx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00053	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00058	d1 fa		 sar	 edx, 1
  0005a	8b ca		 mov	 ecx, edx
  0005c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0005f	03 ca		 add	 ecx, edx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00061	8b d1		 mov	 edx, ecx
  00063	d1 ea		 shr	 edx, 1
  00065	2b c2		 sub	 eax, edx
  00067	3b c8		 cmp	 ecx, eax
  00069	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  0006b	8b c3		 mov	 eax, ebx
  0006d	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00072	3b c3		 cmp	 eax, ebx
  00074	0f 42 c3	 cmovb	 eax, ebx
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00077	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0007c	0f 87 b5 00 00
	00		 ja	 $LN42@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00082	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00085	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00088	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00089	89 45 f8	 mov	 DWORD PTR tv377[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0008c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00091	8b f8		 mov	 edi, eax
  00093	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  00099	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0009c	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a2	89 4d fc	 mov	 DWORD PTR tv376[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000a5	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  000a9	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  000ad	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b0	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000b3	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000b6	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000b9	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bb	3b c2		 cmp	 eax, edx
  000bd	75 04		 jne	 SHORT $LN4@Emplace_re

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000bf	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  000c1	eb 18		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000c3	56		 push	 esi
  000c4	57		 push	 edi
  000c5	50		 push	 eax
  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ; std::_Uninitialized_move<SPoint *,std::allocator<SPoint> >

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cc	8b 45 fc	 mov	 eax, DWORD PTR tv376[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000cf	83 c4 10	 add	 esp, 16			; 00000010H
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d5	83 c0 0c	 add	 eax, 12			; 0000000cH

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000d8	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
$LN5@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000db	56		 push	 esi
  000dc	50		 push	 eax
  000dd	52		 push	 edx
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ; std::_Uninitialized_move<SPoint *,std::allocator<SPoint> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000e4	8b 06		 mov	 eax, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000e6	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000e9	85 c0		 test	 eax, eax
  000eb	74 26		 je	 SHORT $LN35@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000ed	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000f0	2b c8		 sub	 ecx, eax
  000f2	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000f7	f7 e9		 imul	 ecx
  000f9	d1 fa		 sar	 edx, 1
  000fb	8b c2		 mov	 eax, edx
  000fd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00100	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00102	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00105	c1 e0 02	 shl	 eax, 2
  00108	50		 push	 eax
  00109	ff 36		 push	 DWORD PTR [esi]
  0010b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00110	83 c4 08	 add	 esp, 8
$LN35@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 766  :         return _Newvec + _Whereoff;

  00113	8b 45 fc	 mov	 eax, DWORD PTR tv376[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00116	8d 0c 5b	 lea	 ecx, DWORD PTR [ebx+ebx*2]
  00119	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  0011c	89 3e		 mov	 DWORD PTR [esi], edi
  0011e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00121	8b 4d f8	 mov	 ecx, DWORD PTR tv377[ebp]
  00124	03 cf		 add	 ecx, edi

; 766  :         return _Newvec + _Whereoff;

  00126	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00127	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 766  :         return _Newvec + _Whereoff;

  0012a	5e		 pop	 esi
  0012b	5b		 pop	 ebx

; 767  :     }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 08 00	 ret	 8
$LN41@Emplace_re:

; 738  :             _Xlength();

  00132	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@CAXXZ ; std::vector<SPoint,std::allocator<SPoint> >::_Xlength
$LN42@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00137	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN39@Emplace_re:
  0013c	cc		 int	 3
??$_Emplace_reallocate@ABUSPoint@@@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAEPAUSPoint@@QAU2@ABU2@@Z ENDP ; std::vector<SPoint,std::allocator<SPoint> >::_Emplace_reallocate<SPoint const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4432 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4433 : #if _ITERATOR_DEBUG_LEVEL == 2
; 4434 :     _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),
; 4435 :         "You cannot concatenate the same moved string to itself. See "
; 4436 :         "N4849 [res.on.arguments]/1.3: If a function argument binds to an rvalue reference "
; 4437 :         "parameter, the implementation may assume that this parameter is a unique reference "
; 4438 :         "to this argument");
; 4439 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 4440 :     return {_String_constructor_concat_tag{}, _Left, _Right};

  00003	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR $T1[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00014	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4441 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@CAXXZ PROC ; std::vector<SPoint,std::allocator<SPoint> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@CAXXZ ENDP ; std::vector<SPoint,std::allocator<SPoint> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@XZ PROC ; std::vector<SPoint,std::allocator<SPoint> >::~vector<SPoint,std::allocator<SPoint> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 39		 je	 SHORT $LN4@vector

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	d1 fa		 sar	 edx, 1
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00021	c1 e0 02	 shl	 eax, 2
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0002b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00031	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00034	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  0003b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00042	5e		 pop	 esi

; 673  :         _Tidy();
; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00043	c3		 ret	 0
??1?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@XZ ENDP ; std::vector<SPoint,std::allocator<SPoint> >::~vector<SPoint,std::allocator<SPoint> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Rightlast$1$ = 8					; size = 4
__Right$ = 8						; size = 4
??0?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<SPoint,std::allocator<SPoint> >::vector<SPoint,std::allocator<SPoint> >, COMDAT
; _this$ = ecx

; 521  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 522  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 523  :         auto& _My_data            = _Mypair._Myval2;
; 524  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 525  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00010	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00017	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 522  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 523  :         auto& _My_data            = _Mypair._Myval2;
; 524  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 525  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0001e	8b 18		 mov	 ebx, DWORD PTR [eax]

; 526  :         const pointer _Rightlast  = _Right_data._Mylast;

  00020	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00023	89 45 08	 mov	 DWORD PTR __Rightlast$1$[ebp], eax

; 527  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 528  :         if (_Rightfirst != _Rightlast) {

  00026	3b d8		 cmp	 ebx, eax
  00028	74 45		 je	 SHORT $LN25@vector

; 529  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0002a	8b c8		 mov	 ecx, eax
  0002c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00031	2b cb		 sub	 ecx, ebx
  00033	f7 e9		 imul	 ecx
  00035	d1 fa		 sar	 edx, 1
  00037	8b c2		 mov	 eax, edx
  00039	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003c	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0003e	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00043	77 32		 ja	 SHORT $LN31@vector
  00045	56		 push	 esi

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00046	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00049	c1 e6 02	 shl	 esi, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00052	57		 push	 edi
  00053	50		 push	 eax
  00054	ff 75 08	 push	 DWORD PTR __Rightlast$1$[ebp]

; 1643 :         _Myfirst           = _Newvec;

  00057	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;
; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00059	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0005c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0005f	53		 push	 ebx

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00060	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00063	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ; std::_Uninitialized_copy<SPoint *,std::allocator<SPoint> >
  00068	83 c4 14	 add	 esp, 20			; 00000014H

; 530  :             _Tidy_guard<vector> _Guard{this};
; 531  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  0006b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006e	5e		 pop	 esi
$LN25@vector:

; 536  :     }

  0006f	8b c7		 mov	 eax, edi
  00071	5f		 pop	 edi
  00072	5b		 pop	 ebx
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
$LN31@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00077	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN29@vector:
  0007c	cc		 int	 3
??0?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<SPoint,std::allocator<SPoint> >::vector<SPoint,std::allocator<SPoint> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCBoundaryShapeManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBoundaryShapeManager@@UAEPAXI@Z PROC		; CBoundaryShapeManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CBoundaryShapeManager@@UAE@XZ ; CBoundaryShapeManager::~CBoundaryShapeManager
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 28		 push	 40			; 00000028H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCBoundaryShapeManager@@UAEPAXI@Z ENDP		; CBoundaryShapeManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@CAXXZ PROC ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@CAXXZ ENDP ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@AAEXPAUSBoundaryShape@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@AAEXPAUSBoundaryShape@@0@Z PROC ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00003	51		 push	 ecx
  00004	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Destroy_range<std::allocator<SBoundaryShape> >
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?_Destroy@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@AAEXPAUSBoundaryShape@@0@Z ENDP ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@USBoundaryShape@@@std@@QAEXQAUSBoundaryShape@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USBoundaryShape@@@std@@QAEXQAUSBoundaryShape@@I@Z PROC ; std::allocator<SBoundaryShape>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	c1 e0 02	 shl	 eax, 2
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00015	83 c4 08	 add	 esp, 8

; 804  :     }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@USBoundaryShape@@@std@@QAEXQAUSBoundaryShape@@I@Z ENDP ; std::allocator<SBoundaryShape>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
;	COMDAT ?PointInShape@CBoundaryShapeManager@@AAE_NAAUSBoundaryShape@@MM@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
tv796 = 8						; size = 4
_sShape$ = 8						; size = 4
_fX$ = 12						; size = 4
_fY$ = 16						; size = 4
?PointInShape@CBoundaryShapeManager@@AAE_NAAUSBoundaryShape@@MM@Z PROC ; CBoundaryShapeManager::PointInShape, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00004	8b 45 08	 mov	 eax, DWORD PTR _sShape$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 171  : {

  00007	53		 push	 ebx
  00008	57		 push	 edi

; 172  : 	bool bInside = false;

  00009	32 db		 xor	 bl, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000b	8b 38		 mov	 edi, DWORD PTR [eax]
  0000d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00010	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00015	2b cf		 sub	 ecx, edi
  00017	89 7d 08	 mov	 DWORD PTR tv796[ebp], edi
  0001a	f7 e9		 imul	 ecx
  0001c	d1 fa		 sar	 edx, 1
  0001e	8b c2		 mov	 eax, edx
  00020	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00023	03 c2		 add	 eax, edx
  00025	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 174  : 	for (DWORD k = 0; k < sShape.m_vContours.size(); ++k)

  00028	0f 84 a8 00 00
	00		 je	 $LN94@PointInSha
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0002e	f3 0f 10 65 10	 movss	 xmm4, DWORD PTR _fY$[ebp]
  00033	f3 0f 10 75 0c	 movss	 xmm6, DWORD PTR _fX$[ebp]
  00038	56		 push	 esi
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@PointInSha:

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00040	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00043	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00048	8b 37		 mov	 esi, DWORD PTR [edi]
  0004a	2b ce		 sub	 ecx, esi
  0004c	f7 e9		 imul	 ecx
  0004e	d1 fa		 sar	 edx, 1
  00050	8b fa		 mov	 edi, edx
  00052	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00055	03 fa		 add	 edi, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 176  : 		for (DWORD i = 0, j = sShape.m_vContours[k].size() - 1; i < sShape.m_vContours[k].size(); j = i++)

  00057	74 69		 je	 SHORT $LN2@PointInSha
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00059	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0005c	33 c9		 xor	 ecx, ecx
  0005e	8d 04 85 f4 ff
	ff ff		 lea	 eax, DWORD PTR [eax*4-12]
$LL7@PointInSha:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 179  : 				 ((sShape.m_vContours[k][j][1] <= fY) && (fY < sShape.m_vContours[k][i][1]))) &&

  00065	f3 0f 10 6c 31
	04		 movss	 xmm5, DWORD PTR [ecx+esi+4]
  0006b	0f 2f e5	 comiss	 xmm4, xmm5
  0006e	72 0b		 jb	 SHORT $LN93@PointInSha
  00070	f3 0f 10 5c 30
	04		 movss	 xmm3, DWORD PTR [eax+esi+4]
  00076	0f 2f dc	 comiss	 xmm3, xmm4
  00079	77 10		 ja	 SHORT $LN92@PointInSha
$LN93@PointInSha:
  0007b	f3 0f 10 5c 30
	04		 movss	 xmm3, DWORD PTR [eax+esi+4]
  00081	0f 2f e3	 comiss	 xmm4, xmm3
  00084	72 32		 jb	 SHORT $LN5@PointInSha
  00086	0f 2f ec	 comiss	 xmm5, xmm4
  00089	76 2d		 jbe	 SHORT $LN5@PointInSha
$LN92@PointInSha:
  0008b	f3 0f 10 14 31	 movss	 xmm2, DWORD PTR [ecx+esi]
  00090	f3 0f 5c dd	 subss	 xmm3, xmm5
  00094	0f 28 cc	 movaps	 xmm1, xmm4
  00097	0f 28 c2	 movaps	 xmm0, xmm2
  0009a	f3 0f 5c cd	 subss	 xmm1, xmm5
  0009e	f3 0f 5c c2	 subss	 xmm0, xmm2
  000a2	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000a6	f3 0f 5e cb	 divss	 xmm1, xmm3
  000aa	f3 0f 58 ca	 addss	 xmm1, xmm2
  000ae	0f 2f ce	 comiss	 xmm1, xmm6
  000b1	76 05		 jbe	 SHORT $LN5@PointInSha

; 180  : 				  (fX < (sShape.m_vContours[k][i][0] - sShape.m_vContours[k][i][0]) * (fY - sShape.m_vContours[k][i][1]) / (sShape.m_vContours[k][j][1] - sShape.m_vContours[k][i][1]) + sShape.m_vContours[k][i][0]))
; 181  : 			{
; 182  : 				bInside = !bInside;

  000b3	84 db		 test	 bl, bl
  000b5	0f 94 c3	 sete	 bl
$LN5@PointInSha:

; 176  : 		for (DWORD i = 0, j = sShape.m_vContours[k].size() - 1; i < sShape.m_vContours[k].size(); j = i++)

  000b8	8b c1		 mov	 eax, ecx
  000ba	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000bd	83 ef 01	 sub	 edi, 1
  000c0	75 a3		 jne	 SHORT $LL7@PointInSha
$LN2@PointInSha:

; 174  : 	for (DWORD k = 0; k < sShape.m_vContours.size(); ++k)

  000c2	8b 7d 08	 mov	 edi, DWORD PTR tv796[ebp]
  000c5	83 c7 0c	 add	 edi, 12			; 0000000cH
  000c8	83 6d fc 01	 sub	 DWORD PTR $T1[ebp], 1
  000cc	89 7d 08	 mov	 DWORD PTR tv796[ebp], edi
  000cf	0f 85 6b ff ff
	ff		 jne	 $LL4@PointInSha

; 183  : 			}
; 184  : 		}
; 185  : 	}
; 186  : 
; 187  : 	return bInside;

  000d5	5e		 pop	 esi
$LN94@PointInSha:
  000d6	5f		 pop	 edi

; 188  : }

  000d7	8a c3		 mov	 al, bl
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 0c 00	 ret	 12			; 0000000cH
?PointInShape@CBoundaryShapeManager@@AAE_NAAUSBoundaryShape@@MM@Z ENDP ; CBoundaryShapeManager::PointInShape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
;	COMDAT ?RandomPoint@CBoundaryShapeManager@@QAE_NAAM0@Z
_TEXT	SEGMENT
tv88 = 8						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
?RandomPoint@CBoundaryShapeManager@@QAE_NAAM0@Z PROC	; CBoundaryShapeManager::RandomPoint, COMDAT
; _this$ = ecx

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00006	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 196  : 	bool bSuccess = false;

  0000b	32 c9		 xor	 cl, cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000d	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00010	2b 53 04	 sub	 edx, DWORD PTR [ebx+4]
  00013	f7 ea		 imul	 edx
  00015	c1 fa 03	 sar	 edx, 3
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 198  : 	if (m_vBoundaries.size() > 0)

  0001f	74 7b		 je	 SHORT $LN10@RandomPoin

; 199  : 	{
; 200  : 		// pick a random boundary shape
; 201  : 		int nIndex = random_range(0, m_vBoundaries.size() - 1);

  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	48		 dec	 eax
  00024	50		 push	 eax
  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 ?random_range@@YAJJJ@Z	; random_range
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0002c	8d 0c c0	 lea	 ecx, DWORD PTR [eax+eax*8]
  0002f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 205  : 		fX = frandom(sShape.m_afMin[0], sShape.m_afMax[0]);

  00032	f3 0f 10 44 88
	18		 movss	 xmm0, DWORD PTR [eax+ecx*4+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00038	8d 3c 88	 lea	 edi, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 205  : 		fX = frandom(sShape.m_afMin[0], sShape.m_afMax[0]);

  0003b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00041	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	e8 00 00 00 00	 call	 ?frandom@@YAMMM@Z	; frandom
  00050	8b 75 08	 mov	 esi, DWORD PTR _fX$[ebp]
  00053	d9 1e		 fstp	 DWORD PTR [esi]

; 206  : 		fY = frandom(sShape.m_afMin[1], sShape.m_afMax[1]);

  00055	f3 0f 10 47 1c	 movss	 xmm0, DWORD PTR [edi+28]
  0005a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00060	f3 0f 10 47 10	 movss	 xmm0, DWORD PTR [edi+16]
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	e8 00 00 00 00	 call	 ?frandom@@YAMMM@Z	; frandom
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _fY$[ebp]

; 207  : 
; 208  : 		// try it
; 209  : 		bSuccess = PointInShape(sShape, fX, fY);

  00072	8b cb		 mov	 ecx, ebx
  00074	d9 5d 08	 fstp	 DWORD PTR tv88[ebp]
  00077	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv88[ebp]
  0007c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00082	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00086	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 ?PointInShape@CBoundaryShapeManager@@AAE_NAAUSBoundaryShape@@MM@Z ; CBoundaryShapeManager::PointInShape

; 210  : 	}
; 211  : 
; 212  : 	return bSuccess;

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 213  : }

  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
$LN10@RandomPoin:

; 210  : 	}
; 211  : 
; 212  : 	return bSuccess;

  0009c	8a c1		 mov	 al, cl
  0009e	5b		 pop	 ebx

; 213  : }

  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
?RandomPoint@CBoundaryShapeManager@@QAE_NAAM0@Z ENDP	; CBoundaryShapeManager::RandomPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
;	COMDAT ?PointInside@CBoundaryShapeManager@@QAE_NMM@Z
_TEXT	SEGMENT
tv186 = -8						; size = 4
_i$1$ = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
?PointInside@CBoundaryShapeManager@@QAE_NMM@Z PROC	; CBoundaryShapeManager::PointInside, COMDAT
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000a	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 160  : 	for (DWORD i = 0; i < m_vBoundaries.size() && !bInside; ++i)

  0000f	33 c9		 xor	 ecx, ecx
  00011	32 db		 xor	 bl, bl
  00013	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00016	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00019	2b 57 04	 sub	 edx, DWORD PTR [edi+4]
  0001c	f7 ea		 imul	 edx
  0001e	c1 fa 03	 sar	 edx, 3
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 160  : 	for (DWORD i = 0; i < m_vBoundaries.size() && !bInside; ++i)

  00028	74 60		 je	 SHORT $LN14@PointInsid
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0002a	33 c0		 xor	 eax, eax
  0002c	89 45 f8	 mov	 DWORD PTR tv186[ebp], eax
  0002f	56		 push	 esi
$LL4@PointInsid:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 160  : 	for (DWORD i = 0; i < m_vBoundaries.size() && !bInside; ++i)

  00030	84 db		 test	 bl, bl
  00032	75 4b		 jne	 SHORT $LN15@PointInsid

; 161  : 		bInside = PointInShape(m_vBoundaries[i], fX, fY);

  00034	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00039	83 ec 08	 sub	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0003c	03 47 04	 add	 eax, DWORD PTR [edi+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 161  : 		bInside = PointInShape(m_vBoundaries[i], fX, fY);

  0003f	8b cf		 mov	 ecx, edi
  00041	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00047	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0004c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?PointInShape@CBoundaryShapeManager@@AAE_NAAUSBoundaryShape@@MM@Z ; CBoundaryShapeManager::PointInShape
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00057	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 161  : 		bInside = PointInShape(m_vBoundaries[i], fX, fY);

  0005a	8a d8		 mov	 bl, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0005c	2b 4f 04	 sub	 ecx, DWORD PTR [edi+4]
  0005f	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 160  : 	for (DWORD i = 0; i < m_vBoundaries.size() && !bInside; ++i)

  00064	ff 45 fc	 inc	 DWORD PTR _i$1$[ebp]
  00067	83 45 f8 24	 add	 DWORD PTR tv186[ebp], 36 ; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0006b	f7 e9		 imul	 ecx
  0006d	c1 fa 03	 sar	 edx, 3
  00070	8b c2		 mov	 eax, edx
  00072	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00075	03 c2		 add	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 160  : 	for (DWORD i = 0; i < m_vBoundaries.size() && !bInside; ++i)

  00077	39 45 fc	 cmp	 DWORD PTR _i$1$[ebp], eax
  0007a	8b 45 f8	 mov	 eax, DWORD PTR tv186[ebp]
  0007d	72 b1		 jb	 SHORT $LL4@PointInsid
$LN15@PointInsid:
  0007f	5e		 pop	 esi
  00080	5f		 pop	 edi

; 162  : 
; 163  : 	return bInside;

  00081	8a c3		 mov	 al, bl

; 164  : }

  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 08 00	 ret	 8
$LN14@PointInsid:
  0008a	5f		 pop	 edi

; 162  : 
; 163  : 	return bInside;

  0008b	8a c3		 mov	 al, bl

; 164  : }

  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?PointInside@CBoundaryShapeManager@@QAE_NMM@Z ENDP	; CBoundaryShapeManager::PointInside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
;	COMDAT ?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z
_TEXT	SEGMENT
_nNumContours$2 = -144					; size = 4
_nNumBoundaries$3 = -140				; size = 4
$T4 = -136						; size = 4
_this$GSCopy$ = -136					; size = 4
_vPoints$3$ = -132					; size = 4
_pFile$1$ = -128					; size = 4
__Masked$5 = -124					; size = 4
__New_ptr$6 = -124					; size = 4
_nNumPoints$7 = -124					; size = 4
_this$GSCopy$1$ = -120					; size = 4
_j$1$ = -116						; size = 4
__New_ptr$8 = -116					; size = 4
$T9 = -112						; size = 4
__Result$1$ = -112					; size = 4
_i$1$ = -112						; size = 4
_bSuccess$ = -106					; size = 1
_bSuccess$1$ = -105					; size = 1
$T10 = -104						; size = 24
_sPoint$11 = -92					; size = 12
$T12 = -80						; size = 24
_vPoints$13 = -68					; size = 12
_sShape$14 = -56					; size = 36
$T15 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pszFilename$ = 8					; size = 4
?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z PROC	; CBoundaryShapeManager::LoadBsfFile, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f9		 mov	 edi, ecx
  00033	89 7d 88	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00036	8b 75 08	 mov	 esi, DWORD PTR _pszFilename$[ebp]

; 52   : 	bool bSuccess = true;

  00039	b0 01		 mov	 al, 1

; 53   : 	try
; 54   : 	{
; 55   : 		FILE* pFile = fopen(pszFilename, "rb");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00040	56		 push	 esi
  00041	89 bd 78 ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00047	88 45 97	 mov	 BYTE PTR _bSuccess$1$[ebp], al
  0004a	88 45 96	 mov	 BYTE PTR _bSuccess$[ebp], al
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00054	e8 00 00 00 00	 call	 _fopen
  00059	83 c4 08	 add	 esp, 8
  0005c	89 45 80	 mov	 DWORD PTR _pFile$1$[ebp], eax

; 56   : 		if (pFile)

  0005f	85 c0		 test	 eax, eax
  00061	0f 84 89 03 00
	00		 je	 $LN15@LoadBsfFil

; 57   : 		{
; 58   : 			// number of boundary shapes
; 59   : 			unsigned int nNumBoundaries;
; 60   : 			if (fread(&nNumBoundaries, sizeof(unsigned int), 1, pFile) == 1)

  00067	50		 push	 eax
  00068	6a 01		 push	 1
  0006a	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _nNumBoundaries$3[ebp]
  00070	6a 04		 push	 4
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _fread
  00078	83 c4 10	 add	 esp, 16			; 00000010H
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	0f 85 46 03 00
	00		 jne	 $LN17@LoadBsfFil

; 62   : 				for (unsigned int i = 0; i < nNumBoundaries && bSuccess; ++i)

  00084	33 c0		 xor	 eax, eax
$LN329@LoadBsfFil:
  00086	89 45 90	 mov	 DWORD PTR _i$1$[ebp], eax
  00089	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _nNumBoundaries$3[ebp]
  0008f	0f 83 48 03 00
	00		 jae	 $LN18@LoadBsfFil
  00095	80 7d 97 00	 cmp	 BYTE PTR _bSuccess$1$[ebp], 0
  00099	0f 84 3e 03 00
	00		 je	 $LN18@LoadBsfFil
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0009f	33 f6		 xor	 esi, esi
  000a1	33 ff		 xor	 edi, edi
  000a3	89 7d c8	 mov	 DWORD PTR _sShape$14[ebp], edi
  000a6	89 75 cc	 mov	 DWORD PTR _sShape$14[ebp+4], esi
  000a9	89 75 d0	 mov	 DWORD PTR _sShape$14[ebp+8], esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 68   : 					if (fread(&nNumContours, sizeof(unsigned int), 1, pFile) == 1)

  000ac	ff 75 80	 push	 DWORD PTR _pFile$1$[ebp]
  000af	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _nNumContours$2[ebp]
  000b5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000b9	6a 01		 push	 1
  000bb	6a 04		 push	 4
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _fread
  000c3	83 c4 10	 add	 esp, 16			; 00000010H
  000c6	83 f8 01	 cmp	 eax, 1
  000c9	0f 85 a0 02 00
	00		 jne	 $LN19@LoadBsfFil

; 70   : 						for (unsigned int j = 0; j < nNumContours && bSuccess; ++j)

  000cf	33 c0		 xor	 eax, eax
$LN328@LoadBsfFil:
  000d1	89 45 8c	 mov	 DWORD PTR _j$1$[ebp], eax
  000d4	3b 85 70 ff ff
	ff		 cmp	 eax, DWORD PTR _nNumContours$2[ebp]
  000da	0f 83 58 02 00
	00		 jae	 $LN6@LoadBsfFil
  000e0	80 7d 97 00	 cmp	 BYTE PTR _bSuccess$1$[ebp], 0
  000e4	0f 84 4e 02 00
	00		 je	 $LN6@LoadBsfFil
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000ea	33 ff		 xor	 edi, edi
  000ec	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _vPoints$13[ebp], 0
  000f3	33 f6		 xor	 esi, esi
  000f5	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _vPoints$3$[ebp], edi
  000fb	89 75 c0	 mov	 DWORD PTR _vPoints$13[ebp+4], esi
  000fe	89 7d c4	 mov	 DWORD PTR _vPoints$13[ebp+8], edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 75   : 							if (fread(&nNumPoints, sizeof(unsigned int), 1, pFile) == 1)

  00101	ff 75 80	 push	 DWORD PTR _pFile$1$[ebp]
  00104	8d 45 84	 lea	 eax, DWORD PTR _nNumPoints$7[ebp]
  00107	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0010b	6a 01		 push	 1
  0010d	6a 04		 push	 4
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _fread
  00115	83 c4 10	 add	 esp, 16			; 00000010H
  00118	83 f8 01	 cmp	 eax, 1
  0011b	0f 85 b2 01 00
	00		 jne	 $LN21@LoadBsfFil
$LL10@LoadBsfFil:

; 76   : 							{
; 77   : 								// read the points
; 78   : 								for (unsigned int k = 0; k < nNumPoints && bSuccess; ++k)

  00121	3b 7d 84	 cmp	 edi, DWORD PTR _nNumPoints$7[ebp]
  00124	0f 83 13 01 00
	00		 jae	 $LN9@LoadBsfFil
  0012a	80 7d 97 00	 cmp	 BYTE PTR _bSuccess$1$[ebp], 0
  0012e	0f 84 09 01 00
	00		 je	 $LN9@LoadBsfFil

; 79   : 								{
; 80   : 									SPoint sPoint;
; 81   : 
; 82   : 									if (fread(sPoint.m_afData, sizeof(float), 3, pFile) == 3)

  00134	ff 75 80	 push	 DWORD PTR _pFile$1$[ebp]
  00137	8d 45 a4	 lea	 eax, DWORD PTR _sPoint$11[ebp]
  0013a	6a 03		 push	 3
  0013c	6a 04		 push	 4
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _fread
  00144	83 c4 10	 add	 esp, 16			; 00000010H
  00147	83 f8 03	 cmp	 eax, 3
  0014a	0f 85 cd 00 00
	00		 jne	 $LN23@LoadBsfFil
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00150	3b b5 7c ff ff
	ff		 cmp	 esi, DWORD PTR _vPoints$3$[ebp]
  00156	74 17		 je	 SHORT $LN58@LoadBsfFil
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00158	f3 0f 7e 45 a4	 movq	 xmm0, QWORD PTR _sPoint$11[ebp]
  0015d	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00161	8b 45 ac	 mov	 eax, DWORD PTR _sPoint$11[ebp+8]
  00164	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00167	83 c6 0c	 add	 esi, 12			; 0000000cH
  0016a	89 75 c0	 mov	 DWORD PTR _vPoints$13[ebp+4], esi

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0016d	eb 19		 jmp	 SHORT $LN57@LoadBsfFil
$LN58@LoadBsfFil:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0016f	8d 45 a4	 lea	 eax, DWORD PTR _sPoint$11[ebp]
  00172	50		 push	 eax
  00173	56		 push	 esi
  00174	8d 4d bc	 lea	 ecx, DWORD PTR _vPoints$13[ebp]
  00177	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSPoint@@@?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAEPAUSPoint@@QAU2@ABU2@@Z ; std::vector<SPoint,std::allocator<SPoint> >::_Emplace_reallocate<SPoint const &>
  0017c	8b 45 c4	 mov	 eax, DWORD PTR _vPoints$13[ebp+8]
  0017f	8b 75 c0	 mov	 esi, DWORD PTR _vPoints$13[ebp+4]
  00182	89 85 7c ff ff
	ff		 mov	 DWORD PTR _vPoints$3$[ebp], eax
$LN57@LoadBsfFil:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 87   : 										if (j == 0 && k == 0)

  00188	83 7d 8c 00	 cmp	 DWORD PTR _j$1$[ebp], 0
  0018c	75 22		 jne	 SHORT $LN25@LoadBsfFil
  0018e	85 ff		 test	 edi, edi
  00190	75 1e		 jne	 SHORT $LN25@LoadBsfFil

; 88   : 										{
; 89   : 											// first point of this shape
; 90   : 											memcpy(sShape.m_afMin, sPoint.m_afData, 3 * sizeof(float));

  00192	f3 0f 7e 45 a4	 movq	 xmm0, QWORD PTR _sPoint$11[ebp]
  00197	47		 inc	 edi
  00198	8b 45 ac	 mov	 eax, DWORD PTR _sPoint$11[ebp+8]
  0019b	66 0f d6 45 d4	 movq	 QWORD PTR _sShape$14[ebp+12], xmm0
  001a0	89 45 dc	 mov	 DWORD PTR _sShape$14[ebp+20], eax

; 91   : 											memcpy(sShape.m_afMax, sPoint.m_afData, 3 * sizeof(float));

  001a3	66 0f d6 45 e0	 movq	 QWORD PTR _sShape$14[ebp+24], xmm0
  001a8	89 45 e8	 mov	 DWORD PTR _sShape$14[ebp+32], eax
  001ab	e9 71 ff ff ff	 jmp	 $LL10@LoadBsfFil
$LN25@LoadBsfFil:

; 92   : 										}
; 93   : 										else
; 94   : 										{
; 95   : 											// check extents
; 96   : 											for (int l = 0; l < 3; ++l)
; 97   : 											{
; 98   : 												if (sPoint.m_afData[l] < sShape.m_afMin[l])

  001b0	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _sShape$14[ebp+12]
  001b5	f3 0f 10 4d a4	 movss	 xmm1, DWORD PTR _sPoint$11[ebp]
  001ba	0f 2f c1	 comiss	 xmm0, xmm1
  001bd	76 07		 jbe	 SHORT $LN27@LoadBsfFil

; 99   : 													sShape.m_afMin[l] = sPoint.m_afData[l];

  001bf	f3 0f 11 4d d4	 movss	 DWORD PTR _sShape$14[ebp+12], xmm1
  001c4	eb 0b		 jmp	 SHORT $LN11@LoadBsfFil
$LN27@LoadBsfFil:

; 100  : 												else if (sPoint.m_afData[l] > sShape.m_afMax[l])

  001c6	0f 2f 4d e0	 comiss	 xmm1, DWORD PTR _sShape$14[ebp+24]
  001ca	76 05		 jbe	 SHORT $LN11@LoadBsfFil

; 101  : 													sShape.m_afMax[l] = sPoint.m_afData[l];

  001cc	f3 0f 11 4d e0	 movss	 DWORD PTR _sShape$14[ebp+24], xmm1
$LN11@LoadBsfFil:

; 92   : 										}
; 93   : 										else
; 94   : 										{
; 95   : 											// check extents
; 96   : 											for (int l = 0; l < 3; ++l)
; 97   : 											{
; 98   : 												if (sPoint.m_afData[l] < sShape.m_afMin[l])

  001d1	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _sShape$14[ebp+16]
  001d6	f3 0f 10 4d a8	 movss	 xmm1, DWORD PTR _sPoint$11[ebp+4]
  001db	0f 2f c1	 comiss	 xmm0, xmm1
  001de	76 07		 jbe	 SHORT $LN316@LoadBsfFil

; 99   : 													sShape.m_afMin[l] = sPoint.m_afData[l];

  001e0	f3 0f 11 4d d8	 movss	 DWORD PTR _sShape$14[ebp+16], xmm1
  001e5	eb 0b		 jmp	 SHORT $LN317@LoadBsfFil
$LN316@LoadBsfFil:

; 100  : 												else if (sPoint.m_afData[l] > sShape.m_afMax[l])

  001e7	0f 2f 4d e4	 comiss	 xmm1, DWORD PTR _sShape$14[ebp+28]
  001eb	76 05		 jbe	 SHORT $LN317@LoadBsfFil

; 101  : 													sShape.m_afMax[l] = sPoint.m_afData[l];

  001ed	f3 0f 11 4d e4	 movss	 DWORD PTR _sShape$14[ebp+28], xmm1
$LN317@LoadBsfFil:

; 92   : 										}
; 93   : 										else
; 94   : 										{
; 95   : 											// check extents
; 96   : 											for (int l = 0; l < 3; ++l)
; 97   : 											{
; 98   : 												if (sPoint.m_afData[l] < sShape.m_afMin[l])

  001f2	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _sShape$14[ebp+20]
  001f7	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _sPoint$11[ebp+8]
  001fc	0f 2f c1	 comiss	 xmm0, xmm1
  001ff	76 0b		 jbe	 SHORT $LN319@LoadBsfFil

; 99   : 													sShape.m_afMin[l] = sPoint.m_afData[l];

  00201	f3 0f 11 4d dc	 movss	 DWORD PTR _sShape$14[ebp+20], xmm1
  00206	47		 inc	 edi
  00207	e9 15 ff ff ff	 jmp	 $LL10@LoadBsfFil
$LN319@LoadBsfFil:

; 100  : 												else if (sPoint.m_afData[l] > sShape.m_afMax[l])

  0020c	0f 2f 4d e8	 comiss	 xmm1, DWORD PTR _sShape$14[ebp+32]
  00210	76 25		 jbe	 SHORT $LN8@LoadBsfFil

; 101  : 													sShape.m_afMax[l] = sPoint.m_afData[l];

  00212	f3 0f 11 4d e8	 movss	 DWORD PTR _sShape$14[ebp+32], xmm1
  00217	47		 inc	 edi
  00218	e9 04 ff ff ff	 jmp	 $LL10@LoadBsfFil
$LN23@LoadBsfFil:

; 107  : 										m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Failed to read point";

  0021d	8b 45 88	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00220	6a 43		 push	 67			; 00000043H
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@GKKDMKOH@Error?5in?5CBoundaryShapeManager?3@
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 107  : 										m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Failed to read point";

  00227	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0022a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 108  : 										bSuccess = false;

  0022f	32 c0		 xor	 al, al
  00231	88 45 97	 mov	 BYTE PTR _bSuccess$1$[ebp], al
  00234	88 45 96	 mov	 BYTE PTR _bSuccess$[ebp], al
$LN8@LoadBsfFil:

; 76   : 							{
; 77   : 								// read the points
; 78   : 								for (unsigned int k = 0; k < nNumPoints && bSuccess; ++k)

  00237	47		 inc	 edi
  00238	e9 e4 fe ff ff	 jmp	 $LL10@LoadBsfFil
$LN9@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0023d	8b 7d cc	 mov	 edi, DWORD PTR _sShape$14[ebp+4]
  00240	3b 7d d0	 cmp	 edi, DWORD PTR _sShape$14[ebp+8]
  00243	74 7c		 je	 SHORT $LN73@LoadBsfFil

; 528  :         if (_Rightfirst != _Rightlast) {

  00245	8b 45 bc	 mov	 eax, DWORD PTR _vPoints$13[ebp]

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00248	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0024e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00255	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 528  :         if (_Rightfirst != _Rightlast) {

  0025c	3b c6		 cmp	 eax, esi
  0025e	74 53		 je	 SHORT $LN103@LoadBsfFil

; 529  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00260	8b ce		 mov	 ecx, esi
  00262	2b c8		 sub	 ecx, eax
  00264	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00269	f7 e9		 imul	 ecx
  0026b	d1 fa		 sar	 edx, 1
  0026d	8b c2		 mov	 eax, edx
  0026f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00272	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00274	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00279	0f 87 db 03 00
	00		 ja	 $LN333@LoadBsfFil

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0027f	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  00282	c1 e7 02	 shl	 edi, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00285	57		 push	 edi
  00286	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0028b	8b c8		 mov	 ecx, eax
  0028d	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1643 :         _Myfirst           = _Newvec;

  00290	8b 45 cc	 mov	 eax, DWORD PTR _sShape$14[ebp+4]
  00293	89 08		 mov	 DWORD PTR [eax], ecx

; 1644 :         _Mylast            = _Newvec;

  00295	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00298	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0029b	8b 7d cc	 mov	 edi, DWORD PTR _sShape$14[ebp+4]

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0029e	57		 push	 edi

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  0029f	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  002a2	ff 37		 push	 DWORD PTR [edi]
  002a4	56		 push	 esi
  002a5	ff 75 bc	 push	 DWORD PTR _vPoints$13[ebp]
  002a8	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUSPoint@@V?$allocator@USPoint@@@std@@@std@@YAPAUSPoint@@QAU1@0PAU1@AAV?$allocator@USPoint@@@0@@Z ; std::_Uninitialized_copy<SPoint *,std::allocator<SPoint> >
  002ad	83 c4 10	 add	 esp, 16			; 00000010H

; 531  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  002b0	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN103@LoadBsfFil:

; 690  :         ++_Mylast;

  002b3	83 c7 0c	 add	 edi, 12			; 0000000cH
  002b6	89 7d cc	 mov	 DWORD PTR _sShape$14[ebp+4], edi

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  002b9	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _vPoints$3$[ebp]
  002bf	eb 2c		 jmp	 SHORT $LN22@LoadBsfFil
$LN73@LoadBsfFil:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  002c1	8d 45 bc	 lea	 eax, DWORD PTR _vPoints$13[ebp]
  002c4	50		 push	 eax
  002c5	57		 push	 edi
  002c6	8d 4d c8	 lea	 ecx, DWORD PTR _sShape$14[ebp]
  002c9	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@QAEPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@1@QAV21@ABV21@@Z ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Emplace_reallocate<std::vector<SPoint,std::allocator<SPoint> > const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 113  : 							}

  002ce	8b 7d c4	 mov	 edi, DWORD PTR _vPoints$13[ebp+8]
  002d1	eb 1a		 jmp	 SHORT $LN22@LoadBsfFil
$LN21@LoadBsfFil:

; 116  : 								m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Failed to read number of points";

  002d3	8b 45 88	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  002d6	6a 4e		 push	 78			; 0000004eH
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@MFJNADHG@Error?5in?5CBoundaryShapeManager?3@
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 116  : 								m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Failed to read number of points";

  002dd	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  002e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 117  : 								bSuccess = false;

  002e5	32 c0		 xor	 al, al
  002e7	88 45 97	 mov	 BYTE PTR _bSuccess$1$[ebp], al
  002ea	88 45 96	 mov	 BYTE PTR _bSuccess$[ebp], al
$LN22@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  002ed	8b 4d bc	 mov	 ecx, DWORD PTR _vPoints$13[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 120  : 						}

  002f0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  002f4	85 c9		 test	 ecx, ecx
  002f6	74 37		 je	 SHORT $LN5@LoadBsfFil

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  002f8	2b f9		 sub	 edi, ecx
  002fa	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002ff	f7 ef		 imul	 edi
  00301	d1 fa		 sar	 edx, 1
  00303	8b c2		 mov	 eax, edx
  00305	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00308	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0030a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0030d	c1 e0 02	 shl	 eax, 2
  00310	50		 push	 eax
  00311	51		 push	 ecx
  00312	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00317	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0031a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _vPoints$13[ebp], 0

; 1698 :             _Mylast  = pointer();

  00321	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _vPoints$13[ebp+4], 0

; 1699 :             _Myend   = pointer();

  00328	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _vPoints$13[ebp+8], 0
$LN5@LoadBsfFil:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 70   : 						for (unsigned int j = 0; j < nNumContours && bSuccess; ++j)

  0032f	8b 45 8c	 mov	 eax, DWORD PTR _j$1$[ebp]
  00332	40		 inc	 eax
  00333	e9 99 fd ff ff	 jmp	 $LN328@LoadBsfFil
$LN6@LoadBsfFil:

; 121  : 						m_vBoundaries.push_back(sShape);

  00338	8b 75 88	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0033b	8d 4d c8	 lea	 ecx, DWORD PTR _sShape$14[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 121  : 						m_vBoundaries.push_back(sShape);

  0033e	83 c6 04	 add	 esi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00341	51		 push	 ecx
  00342	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00345	50		 push	 eax
  00346	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00349	74 15		 je	 SHORT $LN128@LoadBsfFil

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0034b	56		 push	 esi
  0034c	e8 00 00 00 00	 call	 ??$construct@USBoundaryShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USBoundaryShape@@@std@@@std@@SAXAAV?$allocator@USBoundaryShape@@@1@QAUSBoundaryShape@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<SBoundaryShape> >::construct<SBoundaryShape,SBoundaryShape const &>

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00351	8b 7d c8	 mov	 edi, DWORD PTR _sShape$14[ebp]

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00354	83 c4 0c	 add	 esp, 12			; 0000000cH

; 690  :         ++_Mylast;

  00357	83 46 04 24	 add	 DWORD PTR [esi+4], 36	; 00000024H

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0035b	8b 75 cc	 mov	 esi, DWORD PTR _sShape$14[ebp+4]
  0035e	eb 29		 jmp	 SHORT $LN20@LoadBsfFil
$LN128@LoadBsfFil:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00360	8b ce		 mov	 ecx, esi
  00362	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSBoundaryShape@@@?$vector@USBoundaryShape@@V?$allocator@USBoundaryShape@@@std@@@std@@QAEPAUSBoundaryShape@@QAU2@ABU2@@Z ; std::vector<SBoundaryShape,std::allocator<SBoundaryShape> >::_Emplace_reallocate<SBoundaryShape const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 122  : 					}

  00367	8b 7d c8	 mov	 edi, DWORD PTR _sShape$14[ebp]
  0036a	8b 75 cc	 mov	 esi, DWORD PTR _sShape$14[ebp+4]
  0036d	eb 1a		 jmp	 SHORT $LN20@LoadBsfFil
$LN19@LoadBsfFil:

; 125  : 						m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Failed to read number of contours";

  0036f	8b 45 88	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00372	6a 50		 push	 80			; 00000050H
  00374	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@HDPHEENE@Error?5in?5CBoundaryShapeManager?3@
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 125  : 						m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Failed to read number of contours";

  00379	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0037c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 126  : 						bSuccess = false;

  00381	32 c0		 xor	 al, al
  00383	88 45 97	 mov	 BYTE PTR _bSuccess$1$[ebp], al
  00386	88 45 96	 mov	 BYTE PTR _bSuccess$[ebp], al
$LN20@LoadBsfFil:

; 127  : 					}
; 128  : 				}

  00389	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0038d	85 ff		 test	 edi, edi
  0038f	74 30		 je	 SHORT $LN2@LoadBsfFil

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00391	8d 45 c8	 lea	 eax, DWORD PTR _sShape$14[ebp]
  00394	50		 push	 eax
  00395	56		 push	 esi
  00396	57		 push	 edi
  00397	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0039c	8b 4d d0	 mov	 ecx, DWORD PTR _sShape$14[ebp+8]
  0039f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  003a4	2b cf		 sub	 ecx, edi
  003a6	f7 e9		 imul	 ecx
  003a8	d1 fa		 sar	 edx, 1
  003aa	8b c2		 mov	 eax, edx
  003ac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003af	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b1	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003b4	c1 e0 02	 shl	 eax, 2
  003b7	50		 push	 eax
  003b8	57		 push	 edi
  003b9	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  003be	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@LoadBsfFil:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 62   : 				for (unsigned int i = 0; i < nNumBoundaries && bSuccess; ++i)

  003c1	8b 45 90	 mov	 eax, DWORD PTR _i$1$[ebp]
  003c4	40		 inc	 eax
  003c5	e9 bc fc ff ff	 jmp	 $LN329@LoadBsfFil
$LN17@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003ca	6a 52		 push	 82			; 00000052H
  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@HJGPFIJI@Error?5in?5CBoundaryShapeManager?3@
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 132  : 				m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Failed to read number of boundaries";

  003d1	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003d4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 133  : 				bSuccess = false;

  003d9	c6 45 97 00	 mov	 BYTE PTR _bSuccess$1$[ebp], 0
$LN18@LoadBsfFil:

; 134  : 			}
; 135  : 			fclose(pFile);

  003dd	ff 75 80	 push	 DWORD PTR _pFile$1$[ebp]
  003e0	e8 00 00 00 00	 call	 _fclose

; 136  : 		}

  003e5	8a 45 97	 mov	 al, BYTE PTR _bSuccess$1$[ebp]
  003e8	83 c4 04	 add	 esp, 4
  003eb	e9 4c 02 00 00	 jmp	 $LN111@LoadBsfFil
$LN15@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  003f0	8b ce		 mov	 ecx, esi

; 4293 :         _Mypair._Myval2._Mysize = 0;

  003f2	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T12[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  003f9	c7 45 c4 0f 00
	00 00		 mov	 DWORD PTR $T12[ebp+20], 15 ; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00400	c6 45 b0 00	 mov	 BYTE PTR $T12[ebp], 0

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00404	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL324@LoadBsfFil:
  00407	8a 01		 mov	 al, BYTE PTR [ecx]
  00409	41		 inc	 ecx
  0040a	84 c0		 test	 al, al
  0040c	75 f9		 jne	 SHORT $LL324@LoadBsfFil
  0040e	2b ca		 sub	 ecx, edx

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00410	51		 push	 ecx
  00411	56		 push	 esi
  00412	8d 4d b0	 lea	 ecx, DWORD PTR $T12[ebp]
  00415	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0041a	6a 40		 push	 64			; 00000040H
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 139  : 			m_strCurrentError = string("Error in CBoundaryShapeManager::LoadBsfFile(): Could not open ") + string(pszFilename);

  0041c	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00420	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T10[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00427	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR $T10[ebp+20], 15 ; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0042e	c6 45 98 00	 mov	 BYTE PTR $T10[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00432	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00437	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0043e	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  00440	c7 45 a8 3e 00
	00 00		 mov	 DWORD PTR $T10[ebp+16], 62 ; 0000003eH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00447	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0044a	89 4d 84	 mov	 DWORD PTR __New_ptr$6[ebp], ecx

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  0044d	c7 45 ac 3f 00
	00 00		 mov	 DWORD PTR $T10[ebp+20], 63 ; 0000003fH

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00454	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00457	0f 10 05 10 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@+16
  0045e	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  00462	0f 10 05 20 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@+32
  00469	0f 11 41 20	 movups	 XMMWORD PTR [ecx+32], xmm0
  0046d	f3 0f 7e 05 30
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@+48
  00475	66 0f d6 41 30	 movq	 QWORD PTR [ecx+48], xmm0
  0047a	a1 38 00 00 00	 mov	 eax, DWORD PTR ??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@+56
  0047f	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00482	66 a1 3c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0DP@CJLCLEKC@Error?5in?5CBoundaryShapeManager?3@+60
  00488	66 89 41 3c	 mov	 WORD PTR [ecx+60], ax

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  0048c	8d 45 84	 lea	 eax, DWORD PTR __New_ptr$6[ebp]
  0048f	50		 push	 eax
  00490	8d 45 98	 lea	 eax, DWORD PTR $T10[ebp]

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00493	c6 41 3e 00	 mov	 BYTE PTR [ecx+62], 0

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00497	50		 push	 eax
  00498	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 139  : 			m_strCurrentError = string("Error in CBoundaryShapeManager::LoadBsfFile(): Could not open ") + string(pszFilename);

  0049d	8d 45 b0	 lea	 eax, DWORD PTR $T12[ebp]
  004a0	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  004a4	50		 push	 eax
  004a5	8d 45 98	 lea	 eax, DWORD PTR $T10[ebp]
  004a8	50		 push	 eax
  004a9	8d 45 d4	 lea	 eax, DWORD PTR $T15[ebp]
  004ac	50		 push	 eax
  004ad	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004b2	8b 75 88	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  004b5	8b f8		 mov	 edi, eax
  004b7	83 c6 10	 add	 esi, 16			; 00000010H
  004ba	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2587 :         if (this != _STD addressof(_Right)) {

  004bd	3b f7		 cmp	 esi, edi
  004bf	74 46		 je	 SHORT $LN231@LoadBsfFil

; 2153 :         return _BUF_SIZE <= _Myres;

  004c1	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  004c4	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004c7	72 0c		 jb	 SHORT $LN220@LoadBsfFil

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  004c9	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004ca	50		 push	 eax
  004cb	ff 36		 push	 DWORD PTR [esi]
  004cd	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  004d2	83 c4 08	 add	 esp, 8
$LN220@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  004d5	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  004dc	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  004e3	c6 06 00	 mov	 BYTE PTR [esi], 0

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  004e6	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  004e9	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  004ec	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  004f1	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 4293 :         _Mypair._Myval2._Mysize = 0;

  004f6	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  004fd	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00504	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN231@LoadBsfFil:

; 2153 :         return _BUF_SIZE <= _Myres;

  00507	8b 45 e8	 mov	 eax, DWORD PTR $T15[ebp+20]
  0050a	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0050d	72 0d		 jb	 SHORT $LN236@LoadBsfFil

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0050f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00510	50		 push	 eax
  00511	ff 75 d4	 push	 DWORD PTR $T15[ebp]
  00514	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00519	83 c4 08	 add	 esp, 8
$LN236@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  0051c	8b 45 ac	 mov	 eax, DWORD PTR $T10[ebp+20]

; 4308 :         _Mypair._Myval2._Mysize = 0;

  0051f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T15[ebp+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00526	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T15[ebp+20], 15 ; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0052d	c6 45 d4 00	 mov	 BYTE PTR $T15[ebp], 0

; 2153 :         return _BUF_SIZE <= _Myres;

  00531	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00534	72 0d		 jb	 SHORT $LN246@LoadBsfFil

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00536	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00537	50		 push	 eax
  00538	ff 75 98	 push	 DWORD PTR $T10[ebp]
  0053b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00540	83 c4 08	 add	 esp, 8
$LN246@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00543	8b 45 c4	 mov	 eax, DWORD PTR $T12[ebp+20]
  00546	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00549	72 0d		 jb	 SHORT $LN256@LoadBsfFil

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0054b	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0054c	50		 push	 eax
  0054d	ff 75 b0	 push	 DWORD PTR $T12[ebp]
  00550	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00555	83 c4 08	 add	 esp, 8
$LN256@LoadBsfFil:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 140  : 			bSuccess = false;

  00558	32 c0		 xor	 al, al

; 141  : 		}
; 142  : 	}

  0055a	e9 dd 00 00 00	 jmp	 $LN111@LoadBsfFil
__catch$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$0:

; 143  : 
; 144  : 	catch(...)
; 145  : 	{
; 146  : 		m_strCurrentError = "Error in CBoundaryShapeManager::LoadBsfFile(): Unknown exception";

  0055f	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00565	83 c6 10	 add	 esi, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2966 :         if (_Count <= _Mypair._Myval2._Myres) {

  00568	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0056b	83 ff 40	 cmp	 edi, 64			; 00000040H
  0056e	72 37		 jb	 SHORT $LN279@LoadBsfFil

; 2153 :         return _BUF_SIZE <= _Myres;

  00570	83 ff 10	 cmp	 edi, 16			; 00000010H

; 2135 :         value_type* _Result = _Bx._Buf;

  00573	89 75 90	 mov	 DWORD PTR __Result$1$[ebp], esi
  00576	8b ce		 mov	 ecx, esi

; 2153 :         return _BUF_SIZE <= _Myres;

  00578	0f 93 c0	 setae	 al

; 2136 :         if (_Large_string_engaged()) {

  0057b	84 c0		 test	 al, al
  0057d	74 05		 je	 SHORT $LN272@LoadBsfFil

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  0057f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00581	89 4d 90	 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN272@LoadBsfFil:

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00584	6a 40		 push	 64			; 00000040H
  00586	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KDBLFLMN@Error?5in?5CBoundaryShapeManager?3@
  0058b	51		 push	 ecx

; 2968 :             _Mypair._Myval2._Mysize = _Count;

  0058c	c7 46 10 40 00
	00 00		 mov	 DWORD PTR [esi+16], 64	; 00000040H

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00593	e8 00 00 00 00	 call	 _memmove

; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00598	8b 45 90	 mov	 eax, DWORD PTR __Result$1$[ebp]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0059b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0059e	c6 40 40 00	 mov	 BYTE PTR [eax+64], 0

; 2971 :             return *this;

  005a2	e9 8c 00 00 00	 jmp	 $LN281@LoadBsfFil
$LN279@LoadBsfFil:

; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  005a7	8b cf		 mov	 ecx, edi
  005a9	c7 45 84 4f 00
	00 00		 mov	 DWORD PTR __Masked$5[ebp], 79 ; 0000004fH
  005b0	d1 e9		 shr	 ecx, 1
  005b2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  005b7	2b c1		 sub	 eax, ecx
  005b9	3b f8		 cmp	 edi, eax
  005bb	76 07		 jbe	 SHORT $LN287@LoadBsfFil

; 4207 :             return _Max;

  005bd	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  005c2	eb 1a		 jmp	 SHORT $LN330@LoadBsfFil
$LN287@LoadBsfFil:

; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  005c4	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  005c7	83 f8 4f	 cmp	 eax, 79			; 0000004fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  005ca	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  005d0	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  005d6	8d 55 84	 lea	 edx, DWORD PTR __Masked$5[ebp]
  005d9	0f 46 ca	 cmovbe	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  005dc	8b 01		 mov	 eax, DWORD PTR [ecx]
$LN330@LoadBsfFil:

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  005de	89 45 90	 mov	 DWORD PTR $T9[ebp], eax
  005e1	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  005e2	50		 push	 eax
  005e3	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  005e8	8b 4d 90	 mov	 ecx, DWORD PTR $T9[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  005eb	6a 40		 push	 64			; 00000040H
  005ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KDBLFLMN@Error?5in?5CBoundaryShapeManager?3@
  005f2	50		 push	 eax

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  005f3	89 45 8c	 mov	 DWORD PTR __New_ptr$8[ebp], eax

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  005f6	c7 46 10 40 00
	00 00		 mov	 DWORD PTR [esi+16], 64	; 00000040H

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  005fd	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00600	e8 00 00 00 00	 call	 _memcpy

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00605	8b 45 8c	 mov	 eax, DWORD PTR __New_ptr$8[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00608	83 c4 10	 add	 esp, 16			; 00000010H

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0060b	c6 40 40 00	 mov	 BYTE PTR [eax+64], 0

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  0060f	83 ff 10	 cmp	 edi, 16			; 00000010H
  00612	72 12		 jb	 SHORT $LN280@LoadBsfFil

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00614	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00617	50		 push	 eax
  00618	ff 36		 push	 DWORD PTR [esi]
  0061a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4235 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  0061f	8b 45 8c	 mov	 eax, DWORD PTR __New_ptr$8[ebp]
  00622	89 06		 mov	 DWORD PTR [esi], eax

; 4236 :         } else {

  00624	eb 0a		 jmp	 SHORT $LN331@LoadBsfFil
$LN280@LoadBsfFil:

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00626	8d 45 8c	 lea	 eax, DWORD PTR __New_ptr$8[ebp]
  00629	50		 push	 eax
  0062a	56		 push	 esi
  0062b	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN331@LoadBsfFil:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 147  : 	}

  00630	83 c4 08	 add	 esp, 8
$LN281@LoadBsfFil:
  00633	b8 00 00 00 00	 mov	 eax, $LN325@LoadBsfFil
  00638	c3		 ret	 0
$LN325@LoadBsfFil:
  00639	8a 45 96	 mov	 al, BYTE PTR _bSuccess$[ebp]
$LN111@LoadBsfFil:

; 150  : }

  0063c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0063f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00646	59		 pop	 ecx
  00647	5f		 pop	 edi
  00648	5e		 pop	 esi
  00649	5b		 pop	 ebx
  0064a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0064d	33 cd		 xor	 ecx, ebp
  0064f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00654	8b e5		 mov	 esp, ebp
  00656	5d		 pop	 ebp
  00657	c2 04 00	 ret	 4
$LN333@LoadBsfFil:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0065a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN327@LoadBsfFil:
  0065f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$2:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _sShape$14[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SBoundaryShape@@QAE@XZ
__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$3:
  00008	8d 4d bc	 lea	 ecx, DWORD PTR _vPoints$13[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@QAE@XZ ; std::vector<SPoint,std::allocator<SPoint> >::~vector<SPoint,std::allocator<SPoint> >
__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$4:
  00010	8d 4d b0	 lea	 ecx, DWORD PTR $T12[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z$5:
  00018	8d 4d 98	 lea	 ecx, DWORD PTR $T10[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadBsfFile@CBoundaryShapeManager@@QAE_NPBD@Z ENDP	; CBoundaryShapeManager::LoadBsfFile
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
;	COMDAT ??1CBoundaryShapeManager@@UAE@XZ
_TEXT	SEGMENT
??1CBoundaryShapeManager@@UAE@XZ PROC			; CBoundaryShapeManager::~CBoundaryShapeManager, COMDAT
; _this$ = ecx

; 43   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CBoundaryShapeManager@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  0000a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0000d	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00010	72 0d		 jb	 SHORT $LN7@CBoundaryS

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00012	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	50		 push	 eax
  00014	ff 76 10	 push	 DWORD PTR [esi+16]
  00017	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001c	83 c4 08	 add	 esp, 8
$LN7@CBoundaryS:
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 44   : }

  0001f	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00022	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00029	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00030	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	85 c0		 test	 eax, eax
  00038	74 46		 je	 SHORT $LN16@CBoundaryS

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	57		 push	 edi
  0003b	ff 77 04	 push	 DWORD PTR [edi+4]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USBoundaryShape@@@std@@@std@@YAXPAUSBoundaryShape@@QAU1@AAV?$allocator@USBoundaryShape@@@0@@Z ; std::_Destroy_range<std::allocator<SBoundaryShape> >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00044	8b 37		 mov	 esi, DWORD PTR [edi]
  00046	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0004b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0004e	2b ce		 sub	 ecx, esi
  00050	f7 e9		 imul	 ecx
  00052	c1 fa 03	 sar	 edx, 3
  00055	8b c2		 mov	 eax, edx
  00057	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005a	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005c	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  0005f	c1 e0 02	 shl	 eax, 2
  00062	50		 push	 eax
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00069	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0006f	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00072	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  00079	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN16@CBoundaryS:
  00080	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 44   : }

  00081	5e		 pop	 esi
  00082	c3		 ret	 0
??1CBoundaryShapeManager@@UAE@XZ ENDP			; CBoundaryShapeManager::~CBoundaryShapeManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp
;	COMDAT ??0CBoundaryShapeManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBoundaryShapeManager@@QAE@XZ PROC			; CBoundaryShapeManager::CBoundaryShapeManager, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBoundaryShapeManager@@6B@

; 36   : }

  0000a	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 35   : {

  00021	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00024	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0002b	c7 41 24 0f 00
	00 00		 mov	 DWORD PTR [ecx+36], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00032	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\SpeedTreeLib\BoundaryShapeManager.cpp

; 36   : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??0CBoundaryShapeManager@@QAE@XZ ENDP			; CBoundaryShapeManager::CBoundaryShapeManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1SBoundaryShape@@QAE@XZ
_TEXT	SEGMENT
??1SBoundaryShape@@QAE@XZ PROC				; SBoundaryShape::~SBoundaryShape, COMDAT
; _this$ = ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx
  00003	8b 07		 mov	 eax, DWORD PTR [edi]
  00005	85 c0		 test	 eax, eax
  00007	74 44		 je	 SHORT $LN6@SBoundaryS

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00009	57		 push	 edi
  0000a	ff 77 04	 push	 DWORD PTR [edi+4]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001b	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0001d	f7 e9		 imul	 ecx
  0001f	d1 fa		 sar	 edx, 1
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00028	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	ff 37		 push	 DWORD PTR [edi]
  00031	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00036	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003c	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  0003f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  00046	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN6@SBoundaryS:
  0004d	5f		 pop	 edi
  0004e	c3		 ret	 0
??1SBoundaryShape@@QAE@XZ ENDP				; SBoundaryShape::~SBoundaryShape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;
; 1687 :         pointer& _Myfirst = _My_data._Myfirst;
; 1688 :         pointer& _Mylast  = _My_data._Mylast;
; 1689 :         pointer& _Myend   = _My_data._Myend;
; 1690 : 
; 1691 :         _My_data._Orphan_all();
; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 07		 mov	 eax, DWORD PTR [edi]
  00005	85 c0		 test	 eax, eax
  00007	74 44		 je	 SHORT $LN2@Tidy

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00009	57		 push	 edi
  0000a	ff 77 04	 push	 DWORD PTR [edi+4]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001b	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0001d	f7 e9		 imul	 ecx
  0001f	d1 fa		 sar	 edx, 1
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00028	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	ff 37		 push	 DWORD PTR [edi]
  00031	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00036	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003c	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  0003f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  00046	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN2@Tidy:

; 1700 :         }
; 1701 :     }

  0004d	5f		 pop	 edi
  0004e	c3		 ret	 0
?_Tidy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@0@Z PROC ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00003	51		 push	 ecx
  00004	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@@std@@YAXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@0@QAV10@AAV?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@V?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@2@@std@@AAEXPAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@0@Z ENDP ; std::vector<std::vector<SPoint,std::allocator<SPoint> >,std::allocator<std::vector<SPoint,std::allocator<SPoint> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@QAEXQAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@QAEXQAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@I@Z PROC ; std::allocator<std::vector<SPoint,std::allocator<SPoint> > >::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	c1 e0 02	 shl	 eax, 2
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00015	83 c4 08	 add	 esp, 8

; 804  :     }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$vector@USPoint@@V?$allocator@USPoint@@@std@@@std@@@std@@QAEXQAV?$vector@USPoint@@V?$allocator@USPoint@@@std@@@2@I@Z ENDP ; std::allocator<std::vector<SPoint,std::allocator<SPoint> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__New_ptr$1 = 12					; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2964 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 2965 :         // assign [_Ptr, _Ptr + _Count)
; 2966 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b f9		 cmp	 edi, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2135 :         value_type* _Result = _Bx._Buf;

  00016	8b de		 mov	 ebx, esi

; 2153 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN5@assign:

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0001f	57		 push	 edi
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 2967 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2968 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2969 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 2981 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4221 :         if (_New_size > max_size()) {

  0003e	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00044	0f 87 91 00 00
	00		 ja	 $LN36@assign

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b df		 mov	 ebx, edi
  0004c	83 cb 0f	 or	 ebx, 15			; 0000000fH
  0004f	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 07		 jbe	 SHORT $LN19@assign

; 4203 :             return _Max;

  00057	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0005c	eb 1e		 jmp	 SHORT $LN18@assign
$LN19@assign:

; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0005e	8b d1		 mov	 edx, ecx
  00060	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00065	d1 ea		 shr	 edx, 1
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN20@assign

; 4207 :             return _Max;

  0006d	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00072	eb 08		 jmp	 SHORT $LN18@assign
$LN20@assign:

; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00077	3b d8		 cmp	 ebx, eax
  00079	0f 42 d8	 cmovb	 ebx, eax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0007c	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00085	57		 push	 edi
  00086	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00089	89 45 0c	 mov	 DWORD PTR __New_ptr$1[ebp], eax

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0008c	50		 push	 eax

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  0008d	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  00090	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00093	e8 00 00 00 00	 call	 _memcpy

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00098	8b 5d 0c	 mov	 ebx, DWORD PTR __New_ptr$1[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0009b	83 c4 10	 add	 esp, 16			; 00000010H

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  0009e	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000a1	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 19		 jb	 SHORT $LN13@assign

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000aa	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ab	50		 push	 eax
  000ac	ff 36		 push	 DWORD PTR [esi]
  000ae	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2981 :     }

  000b3	83 c4 08	 add	 esp, 8

; 4235 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000b6	89 1e		 mov	 DWORD PTR [esi], ebx

; 2981 :     }

  000b8	8b c6		 mov	 eax, esi
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
$LN13@assign:

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000c3	8d 45 0c	 lea	 eax, DWORD PTR __New_ptr$1[ebp]
  000c6	50		 push	 eax
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2981 :     }

  000cd	83 c4 08	 add	 esp, 8
  000d0	8b c6		 mov	 eax, esi
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
$LN36@assign:

; 4222 :             _Xlen_string(); // result too long

  000db	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN33@assign:
  000e0	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2722 :     ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2153 :         return _BUF_SIZE <= _Myres;

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 0c		 jb	 SHORT $LN4@basic_stri

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000b	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	83 c4 08	 add	 esp, 8
$LN4@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0001e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi

; 2723 :         _Tidy_deallocate();
; 2724 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2725 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2726 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2727 :         _Mypair._Myval2._Myproxy = nullptr;
; 2728 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2729 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2730 :     }

  00029	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
_TEXT	SEGMENT
__Right_size$1$ = -12					; size = 4
__Fancyptr$ = -8					; size = 4
__Left_size$1$ = -4					; size = 4
___formal$ = 8						; size = 1
__New_size$1$ = 12					; size = 4
__Left$ = 12						; size = 4
__New_capacity$1$ = 16					; size = 4
__Right$ = 16						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2469 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2470 :         auto& _My_data    = _Mypair._Myval2;
; 2471 :         auto& _Left_data  = _Left._Mypair._Myval2;
; 2472 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2473 :         _Left_data._Orphan_all();
; 2474 :         _Right_data._Orphan_all();
; 2475 :         const auto _Left_size  = _Left_data._Mysize;

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Left$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi

; 2476 :         const auto _Right_size = _Right_data._Mysize;

  0000e	8b 7d 10	 mov	 edi, DWORD PTR __Right$[ebp]

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00011	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00018	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 2470 :         auto& _My_data    = _Mypair._Myval2;
; 2471 :         auto& _Left_data  = _Left._Mypair._Myval2;
; 2472 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2473 :         _Left_data._Orphan_all();
; 2474 :         _Right_data._Orphan_all();
; 2475 :         const auto _Left_size  = _Left_data._Mysize;

  0001f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 2476 :         const auto _Right_size = _Right_data._Mysize;

  00022	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00025	89 4d fc	 mov	 DWORD PTR __Left_size$1$[ebp], ecx
  00028	89 55 f4	 mov	 DWORD PTR __Right_size$1$[ebp], edx

; 2477 : 
; 2478 :         const auto _Left_capacity  = _Left_data._Myres;
; 2479 :         const auto _Right_capacity = _Right_data._Myres;
; 2480 :         // overflow is OK due to max_size() checks:
; 2481 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);

  0002b	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0002e	89 45 0c	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2482 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;

  00031	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00034	2b c1		 sub	 eax, ecx
  00036	3b d0		 cmp	 edx, eax

; 2483 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {

  00038	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0003b	77 5a		 ja	 SHORT $LN2@basic_stri
  0003d	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  00040	77 55		 ja	 SHORT $LN2@basic_stri

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00042	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00045	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  00048	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  0004d	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00052	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00059	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00060	c6 06 00	 mov	 BYTE PTR [esi], 0

; 2135 :         value_type* _Result = _Bx._Buf;

  00063	8b f3		 mov	 esi, ebx

; 2153 :         return _BUF_SIZE <= _Myres;

  00065	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  00069	72 02		 jb	 SHORT $LN17@basic_stri

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  0006b	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN17@basic_stri:

; 2153 :         return _BUF_SIZE <= _Myres;

  0006d	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  00071	72 02		 jb	 SHORT $LN22@basic_stri

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00073	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN22@basic_stri:

; 2484 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2485 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2486 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});
; 2487 :             const auto _Ptr = _My_data._Myptr();
; 2488 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  00075	8d 42 01	 lea	 eax, DWORD PTR [edx+1]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00078	50		 push	 eax

; 2484 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2485 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2486 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});
; 2487 :             const auto _Ptr = _My_data._Myptr();
; 2488 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  00079	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0007c	57		 push	 edi
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _memcpy

; 2489 :             _My_data._Mysize = _New_size;

  00083	8b 45 0c	 mov	 eax, DWORD PTR __New_size$1$[ebp]

; 2531 :         _Proxy._Release();
; 2532 :     }

  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0008c	8b c3		 mov	 eax, ebx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
$LN2@basic_stri:

; 2490 :             return;
; 2491 :         }
; 2492 : 
; 2493 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;

  00097	2b c2		 sub	 eax, edx
  00099	3b c8		 cmp	 ecx, eax

; 2494 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {

  0009b	77 5a		 ja	 SHORT $LN3@basic_stri

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0009d	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]

; 2508 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

  000a0	8d 42 01	 lea	 eax, DWORD PTR [edx+1]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  000a3	50		 push	 eax

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000a4	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  000a7	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  000ac	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 4293 :         _Mypair._Myval2._Mysize = 0;

  000b1	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  000b8	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000bf	c6 07 00	 mov	 BYTE PTR [edi], 0

; 2495 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2496 :             // At this point, we have tested:
; 2497 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2498 :             // therefore: (by De Morgan's Laws)
; 2499 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2500 :             // therefore: (by the distributive property)
; 2501 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2502 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2503 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2504 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2505 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2506 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2507 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);

  000c2	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  000c4	57		 push	 edi

; 2508 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

  000c5	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _memmove
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2153 :         return _BUF_SIZE <= _Myres;

  000d1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  000d5	72 02		 jb	 SHORT $LN37@basic_stri

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  000d7	8b 36		 mov	 esi, DWORD PTR [esi]
$LN37@basic_stri:

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000d9	ff 75 fc	 push	 DWORD PTR __Left_size$1$[ebp]
  000dc	56		 push	 esi
  000dd	57		 push	 edi
  000de	e8 00 00 00 00	 call	 _memcpy

; 2509 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2510 :             _My_data._Mysize = _New_size;

  000e3	8b 45 0c	 mov	 eax, DWORD PTR __New_size$1$[ebp]

; 2531 :         _Proxy._Release();
; 2532 :     }

  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000ec	8b c3		 mov	 eax, ebx
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 0c 00	 ret	 12			; 0000000cH
$LN3@basic_stri:

; 2511 :             return;
; 2512 :         }
; 2513 : 
; 2514 :         // can't use either buffer, reallocate
; 2515 :         const auto _Max = max_size();
; 2516 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK

  000f7	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000fc	2b c1		 sub	 eax, ecx
  000fe	3b c2		 cmp	 eax, edx
  00100	0f 82 83 00 00
	00		 jb	 $LN70@basic_stri

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00106	8b 45 0c	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  00109	83 c8 0f	 or	 eax, 15			; 0000000fH
  0010c	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00111	76 07		 jbe	 SHORT $LN44@basic_stri

; 4203 :             return _Max;

  00113	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00118	eb 0a		 jmp	 SHORT $LN68@basic_stri
$LN44@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0011a	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0011f	3b c1		 cmp	 eax, ecx
  00121	0f 42 c1	 cmovb	 eax, ecx
$LN68@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2523 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00124	89 45 10	 mov	 DWORD PTR __New_capacity$1$[ebp], eax
  00127	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2523 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  0012e	89 45 f8	 mov	 DWORD PTR __Fancyptr$[ebp], eax

; 2524 :         // nothrow hereafter
; 2525 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  00131	8d 45 f8	 lea	 eax, DWORD PTR __Fancyptr$[ebp]
  00134	50		 push	 eax
  00135	53		 push	 ebx
  00136	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2526 :         _My_data._Mysize = _New_size;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2527 :         _My_data._Myres  = _New_capacity;

  00141	8b 4d 10	 mov	 ecx, DWORD PTR __New_capacity$1$[ebp]
  00144	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00147	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx

; 2153 :         return _BUF_SIZE <= _Myres;

  0014a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  0014e	72 02		 jb	 SHORT $LN52@basic_stri

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00150	8b 36		 mov	 esi, DWORD PTR [esi]
$LN52@basic_stri:

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00152	ff 75 fc	 push	 DWORD PTR __Left_size$1$[ebp]
  00155	56		 push	 esi
  00156	8b 75 f8	 mov	 esi, DWORD PTR __Fancyptr$[ebp]
  00159	56		 push	 esi
  0015a	e8 00 00 00 00	 call	 _memcpy
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2153 :         return _BUF_SIZE <= _Myres;

  00162	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  00166	72 02		 jb	 SHORT $LN59@basic_stri

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00168	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN59@basic_stri:

; 2528 :         const auto _Ptr  = _Unfancy(_Fancyptr);
; 2529 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2530 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  0016d	40		 inc	 eax

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0016e	50		 push	 eax

; 2528 :         const auto _Ptr  = _Unfancy(_Fancyptr);
; 2529 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2530 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  0016f	8b 45 fc	 mov	 eax, DWORD PTR __Left_size$1$[ebp]
  00172	03 c6		 add	 eax, esi

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00174	57		 push	 edi
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _memcpy

; 2531 :         _Proxy._Release();
; 2532 :     }

  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017e	8b c3		 mov	 eax, ebx
  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	5b		 pop	 ebx
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 0c 00	 ret	 12			; 0000000cH
$LN70@basic_stri:

; 2517 :             _Xlen_string();

  00189	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN66@basic_stri:
  0018e	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2201 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
