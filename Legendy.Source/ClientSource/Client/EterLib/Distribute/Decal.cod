; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0SPDTVertex@@QAE@XZ				; SPDTVertex::SPDTVertex
PUBLIC	??0CDecal@@QAE@XZ				; CDecal::CDecal
PUBLIC	??1CDecal@@UAE@XZ				; CDecal::~CDecal
PUBLIC	?Clear@CDecal@@QAEXXZ				; CDecal::Clear
PUBLIC	?Render@CDecal@@UAEXXZ				; CDecal::Render
PUBLIC	?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength
PUBLIC	?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z	; CDecal::AddPolygon
PUBLIC	?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z	; CDecal::ClipMesh
PUBLIC	?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ; CDecal::ClipPolygon
PUBLIC	?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
PUBLIC	??_GCDecal@@UAEPAXI@Z				; CDecal::`scalar deleting destructor'
PUBLIC	??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>
PUBLIC	??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
PUBLIC	??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
PUBLIC	??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CDecal@@6B@					; CDecal::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CDecal@@6B@				; CDecal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDecal@@@8				; CDecal `RTTI Type Descriptor'
PUBLIC	??_R3CDecal@@8					; CDecal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDecal@@8					; CDecal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDecal@@8				; CDecal::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??_ECDecal@@UAEPAXI@Z:PROC			; CDecal::`vector deleting destructor'
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z:PROC ; CStateManager::DrawIndexedPrimitiveUP
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDecal@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDecal@@8 DD FLAT:??_R0?AVCDecal@@@8	; CDecal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDecal@@8
rdata$r	ENDS
;	COMDAT ??_R2CDecal@@8
rdata$r	SEGMENT
??_R2CDecal@@8 DD FLAT:??_R1A@?0A@EA@CDecal@@8		; CDecal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDecal@@8
rdata$r	SEGMENT
??_R3CDecal@@8 DD 00H					; CDecal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDecal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDecal@@@8
data$r	SEGMENT
??_R0?AVCDecal@@@8 DD FLAT:??_7type_info@@6B@		; CDecal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDecal@@', 00H
data$r	ENDS
;	COMDAT ??_R4CDecal@@6B@
rdata$r	SEGMENT
??_R4CDecal@@6B@ DD 00H					; CDecal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDecal@@@8
	DD	FLAT:??_R3CDecal@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CDecal@@6B@
CONST	SEGMENT
??_7CDecal@@6B@ DD FLAT:??_R4CDecal@@6B@		; CDecal::`vftable'
	DD	FLAT:??_ECDecal@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?Render@CDecal@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z PROC ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ENDP ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z PROC ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	57		 push	 edi
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00013	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	83 e7 f0	 and	 edi, -16		; fffffff0H
  0001c	03 7d 10	 add	 edi, DWORD PTR __Dest$[ebp]
  0001f	8b c7		 mov	 eax, edi
  00021	5f		 pop	 edi

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ENDP ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Newvec$1$ = -8					; size = 4
tv431 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b c2		 sub	 eax, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00015	2b fa		 sub	 edi, edx
  00017	c1 f8 04	 sar	 eax, 4
  0001a	c1 ff 04	 sar	 edi, 4
  0001d	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00020	81 ff ff ff ff
	0f		 cmp	 edi, 268435455		; 0fffffffH
  00026	0f 84 b7 00 00
	00		 je	 $LN41@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0002f	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00034	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00036	47		 inc	 edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00037	c1 f9 04	 sar	 ecx, 4

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0003a	8b d1		 mov	 edx, ecx
  0003c	d1 ea		 shr	 edx, 1
  0003e	2b c2		 sub	 eax, edx
  00040	3b c8		 cmp	 ecx, eax
  00042	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00044	8b df		 mov	 ebx, edi
  00046	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00048	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004b	3b df		 cmp	 ebx, edi
  0004d	0f 42 df	 cmovb	 ebx, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00050	81 fb ff ff ff
	0f		 cmp	 ebx, 268435455		; 0fffffffH
  00056	0f 87 8c 00 00
	00		 ja	 $LN42@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e3 04	 shl	 ebx, 4

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	53		 push	 ebx
  00060	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00065	8b 55 fc	 mov	 edx, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00068	83 c4 04	 add	 esp, 4

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006e	c1 e2 04	 shl	 edx, 4
  00071	03 d0		 add	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00073	89 45 f8	 mov	 DWORD PTR __Newvec$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00076	89 55 fc	 mov	 DWORD PTR tv431[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00079	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0007f	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00082	8b 16		 mov	 edx, DWORD PTR [esi]
  00084	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  00087	74 15		 je	 SHORT $LN5@Emplace_re

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	56		 push	 esi
  0008a	50		 push	 eax
  0008b	51		 push	 ecx
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee
; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00092	8b 45 fc	 mov	 eax, DWORD PTR tv431[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00095	83 c4 10	 add	 esp, 16			; 00000010H
  00098	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee
; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	83 c0 10	 add	 eax, 16			; 00000010H
$LN5@Emplace_re:
  0009e	56		 push	 esi
  0009f	50		 push	 eax
  000a0	ff 76 04	 push	 DWORD PTR [esi+4]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000a9	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee
; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000ab	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ae	85 c9		 test	 ecx, ecx
  000b0	74 12		 je	 SHORT $LN35@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b5	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b7	83 e0 f0	 and	 eax, -16		; fffffff0H
  000ba	50		 push	 eax
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c1	83 c4 08	 add	 esp, 8
$LN35@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1680 :         _Myfirst = _Newvec;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR __Newvec$1$[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c7	c1 e7 04	 shl	 edi, 4
  000ca	89 06		 mov	 DWORD PTR [esi], eax
  000cc	03 f8		 add	 edi, eax
  000ce	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d1	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000d4	8b 45 fc	 mov	 eax, DWORD PTR tv431[ebp]
  000d7	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d8	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx

; 767  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 08 00	 ret	 8
$LN41@Emplace_re:

; 738  :             _Xlength();

  000e3	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength
$LN42@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN39@Emplace_re:
  000ed	cc		 int	 3
??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDecal@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDecal@@UAEPAXI@Z PROC				; CDecal::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDecal@@UAE@XZ	; CDecal::~CDecal
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 94 1a 00 00	 push	 6804			; 00001a94H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCDecal@@UAEPAXI@Z ENDP				; CDecal::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z
_TEXT	SEGMENT
$T1 = -108						; size = 12
$T2 = -96						; size = 12
$T3 = -84						; size = 12
$T4 = -72						; size = 12
tv2112 = -60						; size = 4
tv2105 = -56						; size = 4
_c_rv4Plane$GSCopy$1$ = -52				; size = 4
_f$1$ = -48						; size = 4
_f$1$ = -48						; size = 4
_dwCurIndex$1$ = -44					; size = 4
_c_pv3Normal$GSCopy$1$ = -40				; size = 4
_c_pv3NewNormal$GSCopy$1$ = -36				; size = 4
_c_pv3Vertex$GSCopy$1$ = -32				; size = 4
_ft$1$ = -28						; size = 4
_ft$1$ = -28						; size = 4
_dwCount$1$ = -24					; size = 4
tv2113 = -17						; size = 1
_bNegative$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_c_rv4Plane$ = 8					; size = 4
_dwVertexCount$ = 12					; size = 4
_c_pv3Vertex$ = 16					; size = 4
_c_pv3Normal$ = 20					; size = 4
_c_pv3NewVertex$ = 24					; size = 4
_c_pv3NewNormal$ = 28					; size = 4
?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z PROC ; CDecal::ClipPolygonAgainstPlane, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _c_pv3Vertex$[ebp]
  00013	33 d2		 xor	 edx, edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 18	 mov	 ebx, DWORD PTR _c_pv3NewVertex$[ebp]
  0001c	56		 push	 esi

; 152  : 	bool bNegative[10];
; 153  : 
; 154  : 	// Classify vertices
; 155  : 	DWORD dwNegativeCount = 0;
; 156  : 	for (DWORD dwi = 0; dwi < dwVertexCount; ++dwi)

  0001d	8b 75 0c	 mov	 esi, DWORD PTR _dwVertexCount$[ebp]
  00020	89 4d e0	 mov	 DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp], ecx
  00023	8b 4d 14	 mov	 ecx, DWORD PTR _c_pv3Normal$[ebp]
  00026	57		 push	 edi
  00027	89 4d d8	 mov	 DWORD PTR _c_pv3Normal$GSCopy$1$[ebp], ecx
  0002a	33 ff		 xor	 edi, edi
  0002c	8b 4d 1c	 mov	 ecx, DWORD PTR _c_pv3NewNormal$[ebp]
  0002f	89 45 cc	 mov	 DWORD PTR _c_rv4Plane$GSCopy$1$[ebp], eax
  00032	89 4d dc	 mov	 DWORD PTR _c_pv3NewNormal$GSCopy$1$[ebp], ecx
  00035	85 f6		 test	 esi, esi
  00037	74 64		 je	 SHORT $LN3@ClipPolygo
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00039	8b 4d e0	 mov	 ecx, DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp]
  0003c	0f 57 f6	 xorps	 xmm6, xmm6
  0003f	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  00044	83 c1 08	 add	 ecx, 8
  00047	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  0004b	f3 0f 10 60 08	 movss	 xmm4, DWORD PTR [eax+8]
  00050	f3 0f 10 68 0c	 movss	 xmm5, DWORD PTR [eax+12]
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@ClipPolygo:
  00060	f3 0f 10 41 f8	 movss	 xmm0, DWORD PTR [ecx-8]
  00065	f3 0f 10 49 fc	 movss	 xmm1, DWORD PTR [ecx-4]
  0006a	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0006e	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00072	f3 0f 58 c8	 addss	 xmm1, xmm0
  00076	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0007a	f3 0f 59 c4	 mulss	 xmm0, xmm4
  0007e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00082	f3 0f 58 cd	 addss	 xmm1, xmm5
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 158  : 		bool bNeg = (D3DXPlaneDotCoord(&c_rv4Plane, &c_pv3Vertex[dwi]) < 0.0F);

  00086	0f 2f f1	 comiss	 xmm6, xmm1
  00089	0f 97 c0	 seta	 al
  0008c	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 159  : 		bNegative[dwi] = bNeg;

  0008f	88 44 15 f0	 mov	 BYTE PTR _bNegative$[ebp+edx], al
  00093	42		 inc	 edx

; 160  : 		dwNegativeCount += bNeg;

  00094	0f b6 c0	 movzx	 eax, al
  00097	03 f8		 add	 edi, eax
  00099	3b d6		 cmp	 edx, esi
  0009b	72 c3		 jb	 SHORT $LL4@ClipPolygo
$LN3@ClipPolygo:

; 161  : 	}
; 162  : 
; 163  : 	// Discard this polygon if it's completely culled
; 164  : 	if (dwNegativeCount == dwVertexCount)

  0009d	33 c0		 xor	 eax, eax
  0009f	3b fe		 cmp	 edi, esi
  000a1	0f 84 57 03 00
	00		 je	 $LN1@ClipPolygo

; 165  : 		return 0;
; 166  : 
; 167  : 	DWORD dwCount = 0;

  000a7	33 d2		 xor	 edx, edx
  000a9	89 45 e8	 mov	 DWORD PTR _dwCount$1$[ebp], eax
  000ac	89 55 d4	 mov	 DWORD PTR _dwCurIndex$1$[ebp], edx

; 168  : 	for (DWORD dwCurIndex = 0; dwCurIndex < dwVertexCount; ++dwCurIndex)

  000af	85 f6		 test	 esi, esi
  000b1	0f 84 47 03 00
	00		 je	 $LN1@ClipPolygo

; 165  : 		return 0;
; 166  : 
; 167  : 	DWORD dwCount = 0;

  000b7	8b 7d d8	 mov	 edi, DWORD PTR _c_pv3Normal$GSCopy$1$[ebp]
  000ba	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  000bd	89 45 c4	 mov	 DWORD PTR tv2112[ebp], eax
  000c0	8b cf		 mov	 ecx, edi
  000c2	8b 45 e0	 mov	 eax, DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp]
  000c5	2b c8		 sub	 ecx, eax
  000c7	89 4d c8	 mov	 DWORD PTR tv2105[ebp], ecx
  000ca	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
  000cd	0f 1f 00	 npad	 3
$LL7@ClipPolygo:

; 169  : 	{
; 170  : 		// dwPrevIndex is the index of the previous vertex
; 171  : 		DWORD dwPrevIndex = (dwCurIndex != 0) ? dwCurIndex - 1 : dwVertexCount - 1;
; 172  : 
; 173  : 		if (bNegative[dwCurIndex])

  000d0	85 d2		 test	 edx, edx
  000d2	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000d5	0f 44 45 c4	 cmove	 eax, DWORD PTR tv2112[ebp]
  000d9	80 7c 15 f0 00	 cmp	 BYTE PTR _bNegative$[ebp+edx], 0
  000de	8a 4c 05 f0	 mov	 cl, BYTE PTR _bNegative$[ebp+eax]
  000e2	88 4d ef	 mov	 BYTE PTR tv2113[ebp], cl
  000e5	8b 4d dc	 mov	 ecx, DWORD PTR _c_pv3NewNormal$GSCopy$1$[ebp]
  000e8	0f 84 71 01 00
	00		 je	 $LN9@ClipPolygo

; 174  : 		{
; 175  : 			if (!bNegative[dwPrevIndex])

  000ee	80 7d ef 00	 cmp	 BYTE PTR tv2113[ebp], 0
  000f2	0f 85 f0 02 00
	00		 jne	 $LN78@ClipPolygo
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  000f8	8b 55 e0	 mov	 edx, DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 179  : 				const D3DXVECTOR3& v3_1 = c_pv3Vertex[dwPrevIndex];

  000fb	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  000fe	8b 45 cc	 mov	 eax, DWORD PTR _c_rv4Plane$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 181  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00101	f3 0f 10 6e f8	 movss	 xmm5, DWORD PTR [esi-8]
  00106	f3 0f 10 7e fc	 movss	 xmm7, DWORD PTR [esi-4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0010b	f3 0f 10 34 8a	 movss	 xmm6, DWORD PTR [edx+ecx*4]
  00110	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00114	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]
  00119	0f 28 ca	 movaps	 xmm1, xmm2
  0011c	f3 0f 10 44 8a
	04		 movss	 xmm0, DWORD PTR [edx+ecx*4+4]
  00122	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [eax+8]
  00127	f3 0f 59 c4	 mulss	 xmm0, xmm4
  0012b	f3 0f 59 ce	 mulss	 xmm1, xmm6
  0012f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00133	f3 0f 10 44 8a
	08		 movss	 xmm0, DWORD PTR [edx+ecx*4+8]
  00139	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0013d	f3 0f 58 c8	 addss	 xmm1, xmm0
  00141	f3 0f 58 48 0c	 addss	 xmm1, DWORD PTR [eax+12]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 181  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00146	8b c2		 mov	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00148	8b 55 c8	 mov	 edx, DWORD PTR tv2105[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 181  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  0014b	f3 0f 10 44 88
	04		 movss	 xmm0, DWORD PTR [eax+ecx*4+4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00151	f3 0f 11 4d e4	 movss	 DWORD PTR _ft$1$[ebp], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 181  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00156	f3 0f 5c c7	 subss	 xmm0, xmm7
  0015a	0f 28 ce	 movaps	 xmm1, xmm6
  0015d	f3 0f 5c cd	 subss	 xmm1, xmm5
  00161	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00165	f3 0f 10 26	 movss	 xmm4, DWORD PTR [esi]
  00169	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0016d	f3 0f 58 c8	 addss	 xmm1, xmm0
  00171	f3 0f 10 44 88
	08		 movss	 xmm0, DWORD PTR [eax+ecx*4+8]
  00177	f3 0f 5c c4	 subss	 xmm0, xmm4
  0017b	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0017f	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _ft$1$[ebp]
  00184	f3 0f 58 c8	 addss	 xmm1, xmm0

; 182  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00188	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00190	f3 0f 5e d9	 divss	 xmm3, xmm1
  00194	f3 0f 5c c3	 subss	 xmm0, xmm3
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00198	f3 0f 59 eb	 mulss	 xmm5, xmm3
  0019c	f3 0f 59 fb	 mulss	 xmm7, xmm3
  001a0	f3 0f 59 e3	 mulss	 xmm4, xmm3
  001a4	0f 28 d0	 movaps	 xmm2, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 182  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  001a7	f3 0f 11 45 d0	 movss	 DWORD PTR _f$1$[ebp], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001ac	0f 28 c8	 movaps	 xmm1, xmm0
  001af	f3 0f 59 d6	 mulss	 xmm2, xmm6
  001b3	f3 0f 59 44 88
	08		 mulss	 xmm0, DWORD PTR [eax+ecx*4+8]
  001b9	f3 0f 59 4c 88
	04		 mulss	 xmm1, DWORD PTR [eax+ecx*4+4]

; 182  :     z = fz;

  001bf	f3 0f 58 d5	 addss	 xmm2, xmm5

; 181  :     y = fy;

  001c3	f3 0f 58 c4	 addss	 xmm0, xmm4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 181  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  001c7	f3 0f 11 5d e4	 movss	 DWORD PTR _ft$1$[ebp], xmm3
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001cc	f3 0f 10 65 d0	 movss	 xmm4, DWORD PTR _f$1$[ebp]
  001d1	f3 0f 10 6d e4	 movss	 xmm5, DWORD PTR _ft$1$[ebp]

; 180  :     x = fx;

  001d6	f3 0f 58 cf	 addss	 xmm1, xmm7

; 182  :     z = fz;

  001da	f3 0f 11 45 c0	 movss	 DWORD PTR $T4[ebp+8], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 182  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  001df	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp+8]
  001e2	0f 14 d1	 unpcklps xmm2, xmm1
  001e5	66 0f d6 13	 movq	 QWORD PTR [ebx], xmm2
  001e9	89 43 08	 mov	 DWORD PTR [ebx+8], eax
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001ec	8b 45 d8	 mov	 eax, DWORD PTR _c_pv3Normal$GSCopy$1$[ebp]
  001ef	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  001f3	f3 0f 10 57 04	 movss	 xmm2, DWORD PTR [edi+4]
  001f8	f3 0f 10 0c 16	 movss	 xmm1, DWORD PTR [esi+edx]
  001fd	f3 0f 10 1c 88	 movss	 xmm3, DWORD PTR [eax+ecx*4]
  00202	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00206	f3 0f 59 dc	 mulss	 xmm3, xmm4
  0020a	f3 0f 59 d5	 mulss	 xmm2, xmm5

; 182  :     z = fz;

  0020e	f3 0f 58 d8	 addss	 xmm3, xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00212	f3 0f 59 cd	 mulss	 xmm1, xmm5
  00216	f3 0f 10 44 88
	04		 movss	 xmm0, DWORD PTR [eax+ecx*4+4]
  0021c	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 180  :     x = fx;

  00220	f3 0f 58 d0	 addss	 xmm2, xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00224	f3 0f 10 44 88
	08		 movss	 xmm0, DWORD PTR [eax+ecx*4+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 185  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  0022a	8b 4d dc	 mov	 ecx, DWORD PTR _c_pv3NewNormal$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0022d	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 185  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00231	0f 14 da	 unpcklps xmm3, xmm2
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00234	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 185  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00238	66 0f d6 19	 movq	 QWORD PTR [ecx], xmm3
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0023c	f3 0f 11 4d b4	 movss	 DWORD PTR $T3[ebp+8], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 185  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00241	8b 45 b4	 mov	 eax, DWORD PTR $T3[ebp+8]
  00244	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 186  : 				++dwCount;

  00247	8b 45 e8	 mov	 eax, DWORD PTR _dwCount$1$[ebp]
  0024a	40		 inc	 eax

; 187  : 			}
; 188  : 		}

  0024b	8b 55 d4	 mov	 edx, DWORD PTR _dwCurIndex$1$[ebp]
  0024e	83 c3 0c	 add	 ebx, 12			; 0000000cH
  00251	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00254	89 45 e8	 mov	 DWORD PTR _dwCount$1$[ebp], eax
  00257	89 4d dc	 mov	 DWORD PTR _c_pv3NewNormal$GSCopy$1$[ebp], ecx
  0025a	e9 8c 01 00 00	 jmp	 $LN5@ClipPolygo
$LN9@ClipPolygo:

; 189  : 		else
; 190  : 		{
; 191  : 			if (bNegative[dwPrevIndex])

  0025f	80 7d ef 00	 cmp	 BYTE PTR tv2113[ebp], 0
  00263	0f 84 51 01 00
	00		 je	 $LN12@ClipPolygo
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00269	f3 0f 10 76 f8	 movss	 xmm6, DWORD PTR [esi-8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 196  : 				const D3DXVECTOR3& v3_2 = c_pv3Vertex[dwPrevIndex];

  0026e	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00271	8b 45 cc	 mov	 eax, DWORD PTR _c_rv4Plane$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00274	8b 55 e0	 mov	 edx, DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp]

; 202  : 				++dwCount;

  00277	ff 45 e8	 inc	 DWORD PTR _dwCount$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0027a	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0027e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00283	0f 28 ca	 movaps	 xmm1, xmm2
  00286	f3 0f 59 46 fc	 mulss	 xmm0, DWORD PTR [esi-4]
  0028b	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00290	f3 0f 10 2c 8a	 movss	 xmm5, DWORD PTR [edx+ecx*4]
  00295	f3 0f 10 7c 8a
	04		 movss	 xmm7, DWORD PTR [edx+ecx*4+4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0029b	f3 0f 59 ce	 mulss	 xmm1, xmm6
  0029f	f3 0f 58 c8	 addss	 xmm1, xmm0
  002a3	0f 28 c3	 movaps	 xmm0, xmm3
  002a6	f3 0f 59 06	 mulss	 xmm0, DWORD PTR [esi]
  002aa	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  002ae	f3 0f 10 46 fc	 movss	 xmm0, DWORD PTR [esi-4]
  002b3	f3 0f 5c c7	 subss	 xmm0, xmm7
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  002b7	f3 0f 58 48 0c	 addss	 xmm1, DWORD PTR [eax+12]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  002bc	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  002c1	8b c2		 mov	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  002c3	8b 55 c8	 mov	 edx, DWORD PTR tv2105[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  002c6	f3 0f 10 64 88
	08		 movss	 xmm4, DWORD PTR [eax+ecx*4+8]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  002cc	f3 0f 11 4d e4	 movss	 DWORD PTR _ft$1$[ebp], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  002d1	0f 28 ce	 movaps	 xmm1, xmm6
  002d4	f3 0f 5c cd	 subss	 xmm1, xmm5
  002d8	f3 0f 59 ca	 mulss	 xmm1, xmm2
  002dc	f3 0f 58 c8	 addss	 xmm1, xmm0
  002e0	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  002e4	f3 0f 5c c4	 subss	 xmm0, xmm4
  002e8	f3 0f 59 c3	 mulss	 xmm0, xmm3
  002ec	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _ft$1$[ebp]
  002f1	f3 0f 58 c8	 addss	 xmm1, xmm0

; 198  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  002f5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002fd	f3 0f 5e d9	 divss	 xmm3, xmm1
  00301	f3 0f 5c c3	 subss	 xmm0, xmm3
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00305	f3 0f 59 eb	 mulss	 xmm5, xmm3
  00309	f3 0f 59 fb	 mulss	 xmm7, xmm3
  0030d	f3 0f 59 e3	 mulss	 xmm4, xmm3
  00311	0f 28 d0	 movaps	 xmm2, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 198  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00314	f3 0f 11 45 d0	 movss	 DWORD PTR _f$1$[ebp], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00319	0f 28 c8	 movaps	 xmm1, xmm0
  0031c	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00320	f3 0f 59 06	 mulss	 xmm0, DWORD PTR [esi]
  00324	f3 0f 59 4e fc	 mulss	 xmm1, DWORD PTR [esi-4]

; 182  :     z = fz;

  00329	f3 0f 58 d5	 addss	 xmm2, xmm5

; 181  :     y = fy;

  0032d	f3 0f 58 c4	 addss	 xmm0, xmm4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00331	f3 0f 11 5d e4	 movss	 DWORD PTR _ft$1$[ebp], xmm3
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00336	f3 0f 10 65 d0	 movss	 xmm4, DWORD PTR _f$1$[ebp]
  0033b	f3 0f 10 6d e4	 movss	 xmm5, DWORD PTR _ft$1$[ebp]

; 180  :     x = fx;

  00340	f3 0f 58 cf	 addss	 xmm1, xmm7

; 182  :     z = fz;

  00344	f3 0f 11 45 a8	 movss	 DWORD PTR $T2[ebp+8], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 198  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00349	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp+8]
  0034c	0f 14 d1	 unpcklps xmm2, xmm1
  0034f	66 0f d6 13	 movq	 QWORD PTR [ebx], xmm2
  00353	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 202  : 				++dwCount;

  00356	83 c3 0c	 add	 ebx, 12			; 0000000cH
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00359	8b 45 d8	 mov	 eax, DWORD PTR _c_pv3Normal$GSCopy$1$[ebp]
  0035c	f3 0f 10 1f	 movss	 xmm3, DWORD PTR [edi]
  00360	f3 0f 10 0c 16	 movss	 xmm1, DWORD PTR [esi+edx]
  00365	f3 0f 59 dc	 mulss	 xmm3, xmm4
  00369	f3 0f 10 04 88	 movss	 xmm0, DWORD PTR [eax+ecx*4]
  0036e	f3 0f 10 54 88
	04		 movss	 xmm2, DWORD PTR [eax+ecx*4+4]
  00374	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00378	f3 0f 59 d5	 mulss	 xmm2, xmm5

; 182  :     z = fz;

  0037c	f3 0f 58 d8	 addss	 xmm3, xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00380	f3 0f 59 cc	 mulss	 xmm1, xmm4
  00384	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  00389	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 180  :     x = fx;

  0038d	f3 0f 58 d0	 addss	 xmm2, xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00391	f3 0f 10 44 88
	08		 movss	 xmm0, DWORD PTR [eax+ecx*4+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 201  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00397	8b 4d dc	 mov	 ecx, DWORD PTR _c_pv3NewNormal$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0039a	f3 0f 59 c5	 mulss	 xmm0, xmm5
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 201  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  0039e	0f 14 da	 unpcklps xmm3, xmm2
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 181  :     y = fy;

  003a1	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 201  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  003a5	66 0f d6 19	 movq	 QWORD PTR [ecx], xmm3
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 182  :     z = fz;

  003a9	f3 0f 11 4d 9c	 movss	 DWORD PTR $T1[ebp+8], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 201  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  003ae	8b 45 9c	 mov	 eax, DWORD PTR $T1[ebp+8]
  003b1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 202  : 				++dwCount;

  003b4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003b7	8b 55 d4	 mov	 edx, DWORD PTR _dwCurIndex$1$[ebp]
$LN12@ClipPolygo:

; 203  : 			}
; 204  : 
; 205  : 			// Include current vertex
; 206  :  			c_pv3NewVertex[dwCount] = c_pv3Vertex[dwCurIndex];

  003ba	f3 0f 7e 46 f8	 movq	 xmm0, QWORD PTR [esi-8]
  003bf	66 0f d6 03	 movq	 QWORD PTR [ebx], xmm0
  003c3	8b 06		 mov	 eax, DWORD PTR [esi]
  003c5	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 207  :  			c_pv3NewNormal[dwCount] = c_pv3Normal[dwCurIndex];
; 208  : 			++dwCount;

  003c8	83 c3 0c	 add	 ebx, 12			; 0000000cH
  003cb	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  003cf	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  003d3	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003d6	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  003d9	8b 45 e8	 mov	 eax, DWORD PTR _dwCount$1$[ebp]
  003dc	40		 inc	 eax
  003dd	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003e0	89 45 e8	 mov	 DWORD PTR _dwCount$1$[ebp], eax
  003e3	89 4d dc	 mov	 DWORD PTR _c_pv3NewNormal$GSCopy$1$[ebp], ecx
  003e6	eb 03		 jmp	 SHORT $LN5@ClipPolygo
$LN78@ClipPolygo:

; 174  : 		{
; 175  : 			if (!bNegative[dwPrevIndex])

  003e8	8b 45 e8	 mov	 eax, DWORD PTR _dwCount$1$[ebp]
$LN5@ClipPolygo:

; 168  : 	for (DWORD dwCurIndex = 0; dwCurIndex < dwVertexCount; ++dwCurIndex)

  003eb	42		 inc	 edx
  003ec	83 c6 0c	 add	 esi, 12			; 0000000cH
  003ef	83 c7 0c	 add	 edi, 12			; 0000000cH
  003f2	89 55 d4	 mov	 DWORD PTR _dwCurIndex$1$[ebp], edx
  003f5	3b 55 0c	 cmp	 edx, DWORD PTR _dwVertexCount$[ebp]
  003f8	0f 82 d2 fc ff
	ff		 jb	 $LL7@ClipPolygo
$LN1@ClipPolygo:

; 209  : 		}
; 210  : 	}
; 211  : 
; 212  : 	// Return number of vertices in clipped polygon
; 213  : 	return dwCount;
; 214  : }

  003fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00401	5f		 pop	 edi
  00402	5e		 pop	 esi
  00403	33 cd		 xor	 ecx, ebp
  00405	5b		 pop	 ebx
  00406	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040b	8b e5		 mov	 esp, ebp
  0040d	5d		 pop	 ebp
  0040e	c3		 ret	 0
?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ENDP ; CDecal::ClipPolygonAgainstPlane
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z
_TEXT	SEGMENT
_v3TempVertex$ = -220					; size = 108
_v3TempNormal$ = -112					; size = 108
__$ArrayPad$ = -4					; size = 4
_dwVertexCount$ = 8					; size = 4
_c_pv3Vertex$ = 12					; size = 4
_c_pv3Normal$ = 16					; size = 4
_c_pv3NewVertex$ = 20					; size = 4
_c_pv3NewNormal$ = 24					; size = 4
?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z PROC ; CDecal::ClipPolygon, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _c_pv3Normal$[ebp]
  00016	8b 55 0c	 mov	 edx, DWORD PTR _c_pv3Vertex$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 18	 mov	 ebx, DWORD PTR _c_pv3NewNormal$[ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8b 7d 14	 mov	 edi, DWORD PTR _c_pv3NewVertex$[ebp]
  00022	8b f1		 mov	 esi, ecx

; 117  : 	D3DXVECTOR3		v3TempVertex[9];
; 118  : 	D3DXVECTOR3		v3TempNormal[9];
; 119  : 
; 120  : 	// Clip against all six planes
; 121  : 	DWORD dwCount = ClipPolygonAgainstPlane(m_v4LeftPlane, dwVertexCount, c_pv3Vertex, c_pv3Normal, v3TempVertex, v3TempNormal);

  00024	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  00027	51		 push	 ecx
  00028	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	52		 push	 edx
  00031	ff 75 08	 push	 DWORD PTR _dwVertexCount$[ebp]
  00034	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0003d	83 c4 18	 add	 esp, 24			; 00000018H

; 122  : 	if (dwCount != 0)

  00040	85 c0		 test	 eax, eax
  00042	0f 84 92 00 00
	00		 je	 $LN6@ClipPolygo

; 123  : 	{
; 124  : 		dwCount = ClipPolygonAgainstPlane(m_v4RightPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  00048	53		 push	 ebx
  00049	57		 push	 edi
  0004a	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  0004d	51		 push	 ecx
  0004e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  00054	51		 push	 ecx
  00055	50		 push	 eax
  00056	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0005f	83 c4 18	 add	 esp, 24			; 00000018H

; 125  : 		if (dwCount != 0)

  00062	85 c0		 test	 eax, eax
  00064	74 74		 je	 SHORT $LN6@ClipPolygo

; 126  : 		{
; 127  : 			dwCount = ClipPolygonAgainstPlane(m_v4BottomPlane, dwCount, c_pv3NewVertex, c_pv3NewNormal, v3TempVertex, v3TempNormal);

  00066	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  00069	51		 push	 ecx
  0006a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  00070	51		 push	 ecx
  00071	53		 push	 ebx
  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0007d	83 c4 18	 add	 esp, 24			; 00000018H

; 128  : 			if (dwCount != 0)

  00080	85 c0		 test	 eax, eax
  00082	74 56		 je	 SHORT $LN6@ClipPolygo

; 129  : 			{
; 130  : 				dwCount = ClipPolygonAgainstPlane(m_v4TopPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  00084	53		 push	 ebx
  00085	57		 push	 edi
  00086	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  00089	51		 push	 ecx
  0008a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  00090	51		 push	 ecx
  00091	50		 push	 eax
  00092	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0009b	83 c4 18	 add	 esp, 24			; 00000018H

; 131  : 				if (dwCount != 0)

  0009e	85 c0		 test	 eax, eax
  000a0	74 38		 je	 SHORT $LN6@ClipPolygo

; 132  : 				{
; 133  : 					dwCount = ClipPolygonAgainstPlane(m_v4BackPlane, dwCount, c_pv3NewVertex, c_pv3NewNormal, v3TempVertex, v3TempNormal);

  000a2	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  000a5	51		 push	 ecx
  000a6	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  000ac	51		 push	 ecx
  000ad	53		 push	 ebx
  000ae	57		 push	 edi
  000af	50		 push	 eax
  000b0	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  000b9	83 c4 18	 add	 esp, 24			; 00000018H

; 134  : 					if (dwCount != 0)

  000bc	85 c0		 test	 eax, eax
  000be	74 1a		 je	 SHORT $LN6@ClipPolygo

; 135  : 					{
; 136  : 						dwCount = ClipPolygonAgainstPlane(m_v4FrontPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  000c0	53		 push	 ebx
  000c1	57		 push	 edi
  000c2	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  000c5	51		 push	 ecx
  000c6	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  000cc	51		 push	 ecx
  000cd	50		 push	 eax
  000ce	8d 46 5c	 lea	 eax, DWORD PTR [esi+92]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  000d7	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@ClipPolygo:

; 137  : 					}
; 138  : 				}
; 139  : 			}
; 140  : 		}
; 141  : 	}
; 142  : 	return dwCount;
; 143  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	33 cd		 xor	 ecx, ebp
  000e1	5b		 pop	 ebx
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 14 00	 ret	 20			; 00000014H
?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ENDP ; CDecal::ClipPolygon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -240					; size = 4
tv1128 = -236						; size = 4
tv1122 = -236						; size = 4
_v3NewNormal$ = -232					; size = 108
_v3NewVertex$ = -120					; size = 108
__$ArrayPad$ = -4					; size = 4
_dwPrimitiveCount$ = 8					; size = 4
_c_pv3Vertex$ = 12					; size = 4
_c_pv3Normal$ = 16					; size = 4
?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z PROC		; CDecal::ClipMesh, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 f0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+244], eax
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _c_pv3Vertex$[ebp]

; 46   : 	D3DXVECTOR3		v3NewVertex[9];
; 47   : 	D3DXVECTOR3		v3NewNormal[9];
; 48   : 
; 49   : 	// Clip one triangle at a time
; 50   : 	for(DWORD dwi = 0; dwi < dwPrimitiveCount; ++dwi)

  0001f	33 db		 xor	 ebx, ebx
  00021	57		 push	 edi
  00022	89 4c 24 10	 mov	 DWORD PTR _this$GSCopy$1$[esp+256], ecx
  00026	39 5d 08	 cmp	 DWORD PTR _dwPrimitiveCount$[ebp], ebx
  00029	0f 86 cb 01 00
	00		 jbe	 $LN47@ClipMesh
  0002f	8b 7d 10	 mov	 edi, DWORD PTR _c_pv3Normal$[ebp]
  00032	83 c7 18	 add	 edi, 24			; 00000018H
  00035	83 c6 20	 add	 esi, 32			; 00000020H
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@ClipMesh:
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00040	f3 0f 10 66 ec	 movss	 xmm4, DWORD PTR [esi-20]
  00045	f3 0f 5c 66 e0	 subss	 xmm4, DWORD PTR [esi-32]
  0004a	f3 0f 10 56 f0	 movss	 xmm2, DWORD PTR [esi-16]
  0004f	f3 0f 10 76 f4	 movss	 xmm6, DWORD PTR [esi-12]
  00054	f3 0f 5c 76 e8	 subss	 xmm6, DWORD PTR [esi-24]
  00059	f3 0f 10 1e	 movss	 xmm3, DWORD PTR [esi]
  0005d	f3 0f 5c 5e e8	 subss	 xmm3, DWORD PTR [esi-24]
  00062	f3 0f 5c 56 e4	 subss	 xmm2, DWORD PTR [esi-28]
  00067	f3 0f 10 6e fc	 movss	 xmm5, DWORD PTR [esi-4]
  0006c	f3 0f 5c 6e e4	 subss	 xmm5, DWORD PTR [esi-28]
  00071	f3 0f 10 7e f8	 movss	 xmm7, DWORD PTR [esi-8]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00076	0f 28 c6	 movaps	 xmm0, xmm6

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00079	f3 0f 5c 7e e0	 subss	 xmm7, DWORD PTR [esi-32]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0007e	f3 0f 10 49 10	 movss	 xmm1, DWORD PTR [ecx+16]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00083	f3 0f 11 64 24
	14		 movss	 DWORD PTR tv1122[esp+256], xmm4

; 182  :     z = fz;

  00089	0f 28 e2	 movaps	 xmm4, xmm2

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0008c	f3 0f 59 c5	 mulss	 xmm0, xmm5

; 182  :     z = fz;

  00090	f3 0f 59 e3	 mulss	 xmm4, xmm3

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00094	f3 0f 59 f7	 mulss	 xmm6, xmm7
  00098	f3 0f 5c e0	 subss	 xmm4, xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;
; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0009c	f3 0f 59 d7	 mulss	 xmm2, xmm7
  000a0	f3 0f 10 44 24
	14		 movss	 xmm0, DWORD PTR tv1122[esp+256]
  000a6	f3 0f 59 c3	 mulss	 xmm0, xmm3
  000aa	f3 0f 10 5c 24
	14		 movss	 xmm3, DWORD PTR tv1122[esp+256]
  000b0	f3 0f 59 dd	 mulss	 xmm3, xmm5
  000b4	f3 0f 5c f0	 subss	 xmm6, xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000b8	f3 0f 59 cc	 mulss	 xmm1, xmm4
  000bc	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [ecx+20]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000c1	f3 0f 5c da	 subss	 xmm3, xmm2

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000c5	f3 0f 59 e4	 mulss	 xmm4, xmm4

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000c9	f3 0f 59 c6	 mulss	 xmm0, xmm6
  000cd	f3 0f 59 f6	 mulss	 xmm6, xmm6
  000d1	f3 0f 58 c8	 addss	 xmm1, xmm0
  000d5	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  000da	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000de	f3 0f 58 f4	 addss	 xmm6, xmm4
  000e2	f3 0f 59 db	 mulss	 xmm3, xmm3

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000e6	f3 0f 58 c8	 addss	 xmm1, xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000ea	f3 0f 58 f3	 addss	 xmm6, xmm3

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000ee	f3 0f 11 4c 24
	14		 movss	 DWORD PTR tv1128[esp+256], xmm1
  000f4	0f 57 c9	 xorps	 xmm1, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  000f7	0f 5a c6	 cvtps2pd xmm0, xmm6
  000fa	66 0f 2e c8	 ucomisd xmm1, xmm0
  000fe	77 06		 ja	 SHORT $LN49@ClipMesh
  00100	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00104	eb 05		 jmp	 SHORT $LN50@ClipMesh
$LN49@ClipMesh:
  00106	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN50@ClipMesh:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 58   : 		if (D3DXVec3Dot(&m_v3Normal, &v3Cross) > ( m_cfDecalEpsilon ) * D3DXVec3Length(&v3Cross))

  0010b	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+256]
  0010f	f3 0f 10 4c 24
	14		 movss	 xmm1, DWORD PTR tv1128[esp+256]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00115	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 58   : 		if (D3DXVec3Dot(&m_v3Normal, &v3Cross) > ( m_cfDecalEpsilon ) * D3DXVec3Length(&v3Cross))

  00119	f3 0f 59 81 90
	1a 00 00	 mulss	 xmm0, DWORD PTR [ecx+6800]
  00121	0f 2f c8	 comiss	 xmm1, xmm0
  00124	0f 86 c0 00 00
	00		 jbe	 $LN2@ClipMesh

; 59   : 		{
; 60   : 			v3NewVertex[0] = v3_1;

  0012a	8b 46 e8	 mov	 eax, DWORD PTR [esi-24]
  0012d	f3 0f 7e 46 e0	 movq	 xmm0, QWORD PTR [esi-32]
  00132	89 84 24 90 00
	00 00		 mov	 DWORD PTR _v3NewVertex$[esp+264], eax

; 61   : 			v3NewVertex[1] = v3_2;

  00139	8b 46 f4	 mov	 eax, DWORD PTR [esi-12]
  0013c	89 84 24 9c 00
	00 00		 mov	 DWORD PTR _v3NewVertex$[esp+276], eax

; 62   : 			v3NewVertex[2] = v3_3;

  00143	8b 06		 mov	 eax, DWORD PTR [esi]
  00145	89 84 24 a8 00
	00 00		 mov	 DWORD PTR _v3NewVertex$[esp+288], eax

; 63   : 
; 64   : 			v3NewNormal[0] = c_pv3Normal[3 * dwi];

  0014c	8b 47 f0	 mov	 eax, DWORD PTR [edi-16]
  0014f	89 44 24 20	 mov	 DWORD PTR _v3NewNormal$[esp+264], eax

; 65   : 			v3NewNormal[1] = c_pv3Normal[3 * dwi + 1];

  00153	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  00156	89 44 24 2c	 mov	 DWORD PTR _v3NewNormal$[esp+276], eax

; 66   : 			v3NewNormal[2] = c_pv3Normal[3 * dwi + 2];

  0015a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0015d	66 0f d6 84 24
	88 00 00 00	 movq	 QWORD PTR _v3NewVertex$[esp+256], xmm0
  00166	f3 0f 7e 46 ec	 movq	 xmm0, QWORD PTR [esi-20]
  0016b	89 44 24 38	 mov	 DWORD PTR _v3NewNormal$[esp+288], eax

; 67   : 
; 68   : 			DWORD dwCount = ClipPolygon(3, v3NewVertex, v3NewNormal, v3NewVertex, v3NewNormal);

  0016f	8d 44 24 18	 lea	 eax, DWORD PTR _v3NewNormal$[esp+256]
  00173	50		 push	 eax
  00174	66 0f d6 84 24
	98 00 00 00	 movq	 QWORD PTR _v3NewVertex$[esp+272], xmm0
  0017d	8d 84 24 8c 00
	00 00		 lea	 eax, DWORD PTR _v3NewVertex$[esp+260]
  00184	f3 0f 7e 46 f8	 movq	 xmm0, QWORD PTR [esi-8]
  00189	50		 push	 eax
  0018a	66 0f d6 84 24
	a8 00 00 00	 movq	 QWORD PTR _v3NewVertex$[esp+288], xmm0
  00193	8d 44 24 20	 lea	 eax, DWORD PTR _v3NewNormal$[esp+264]
  00197	f3 0f 7e 47 e8	 movq	 xmm0, QWORD PTR [edi-24]
  0019c	50		 push	 eax
  0019d	66 0f d6 44 24
	24		 movq	 QWORD PTR _v3NewNormal$[esp+268], xmm0
  001a3	8d 84 24 94 00
	00 00		 lea	 eax, DWORD PTR _v3NewVertex$[esp+268]
  001aa	f3 0f 7e 47 f4	 movq	 xmm0, QWORD PTR [edi-12]
  001af	66 0f d6 44 24
	30		 movq	 QWORD PTR _v3NewNormal$[esp+280], xmm0
  001b5	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  001b9	50		 push	 eax
  001ba	6a 03		 push	 3
  001bc	66 0f d6 44 24
	44		 movq	 QWORD PTR _v3NewNormal$[esp+300], xmm0
  001c2	e8 00 00 00 00	 call	 ?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ; CDecal::ClipPolygon

; 69   : 			if ((dwCount != 0) && (!AddPolygon(dwCount, v3NewVertex, v3NewNormal))) break;

  001c7	85 c0		 test	 eax, eax
  001c9	74 1b		 je	 SHORT $LN48@ClipMesh
  001cb	8d 4c 24 18	 lea	 ecx, DWORD PTR _v3NewNormal$[esp+256]
  001cf	51		 push	 ecx
  001d0	8d 8c 24 8c 00
	00 00		 lea	 ecx, DWORD PTR _v3NewVertex$[esp+260]
  001d7	51		 push	 ecx
  001d8	8b 4c 24 18	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+264]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 ?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z ; CDecal::AddPolygon
  001e2	84 c0		 test	 al, al
  001e4	74 14		 je	 SHORT $LN47@ClipMesh
$LN48@ClipMesh:

; 46   : 	D3DXVECTOR3		v3NewVertex[9];
; 47   : 	D3DXVECTOR3		v3NewNormal[9];
; 48   : 
; 49   : 	// Clip one triangle at a time
; 50   : 	for(DWORD dwi = 0; dwi < dwPrimitiveCount; ++dwi)

  001e6	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+256]
$LN2@ClipMesh:
  001ea	43		 inc	 ebx
  001eb	83 c6 24	 add	 esi, 36			; 00000024H
  001ee	83 c7 24	 add	 edi, 36			; 00000024H
  001f1	3b 5d 08	 cmp	 ebx, DWORD PTR _dwPrimitiveCount$[ebp]
  001f4	0f 82 46 fe ff
	ff		 jb	 $LL4@ClipMesh
$LN47@ClipMesh:

; 70   :  		}
; 71   : 	}
; 72   : }

  001fa	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+256]
  00201	5f		 pop	 edi
  00202	5e		 pop	 esi
  00203	5b		 pop	 ebx
  00204	33 cc		 xor	 ecx, esp
  00206	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c2 0c 00	 ret	 12			; 0000000cH
?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z ENDP		; CDecal::ClipMesh
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_aTriangleFanStruct$ = -20				; size = 16
_this$1$ = -4						; size = 4
_dwAddCount$ = 8					; size = 4
_c_pv3Vertex$ = 12					; size = 4
___formal$ = 16						; size = 4
?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z PROC	; CDecal::AddPolygon, COMDAT
; _this$ = ecx

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 76   : 	if (m_dwVertexCount + dwAddCount >= MAX_DECAL_VERTICES)

  00006	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _dwAddCount$[ebp]
  0000d	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00013	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00018	72 09		 jb	 SHORT $LN5@AddPolygon

; 77   : 		return false;

  0001a	32 c0		 xor	 al, al
  0001c	5f		 pop	 edi

; 109  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
$LN5@AddPolygon:

; 82   : 	aTriangleFanStruct.m_dwPrimitiveCount = dwAddCount - 2;

  00023	8d 47 fe	 lea	 eax, DWORD PTR [edi-2]
  00026	66 89 55 ec	 mov	 WORD PTR _aTriangleFanStruct$[ebp], dx
  0002a	89 45 f4	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+8], eax

; 83   : 	aTriangleFanStruct.m_dwVBOffset = m_dwVertexCount;
; 84   : 
; 85   : 	m_TriangleFanStructVector.push_back(aTriangleFanStruct);

  0002d	8d 81 84 00 00
	00		 lea	 eax, DWORD PTR [ecx+132]
  00033	89 55 f8	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+12], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00036	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 81   : 	aTriangleFanStruct.m_dwVertexCount = dwAddCount;

  00039	89 7d f0	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0003c	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003f	74 0d		 je	 SHORT $LN10@AddPolygon
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00041	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _aTriangleFanStruct$[ebp]
  00045	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00048	83 40 04 10	 add	 DWORD PTR [eax+4], 16	; 00000010H

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0004c	eb 0f		 jmp	 SHORT $LN9@AddPolygon
$LN10@AddPolygon:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004e	8d 4d ec	 lea	 ecx, DWORD PTR _aTriangleFanStruct$[ebp]
  00051	51		 push	 ecx
  00052	52		 push	 edx
  00053	8b c8		 mov	 ecx, eax
  00055	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN9@AddPolygon:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 87   : 	DWORD dwCount = m_dwVertexCount;

  0005d	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]

; 88   : 
; 89   : 	// Add polygon as a triangle fan
; 90   : 	WORD * wIndex = m_Indices + dwCount;
; 91   : 
; 92   : 	m_dwPrimitiveCount += dwAddCount - 2;

  00060	8d 47 fe	 lea	 eax, DWORD PTR [edi-2]
  00063	01 81 80 00 00
	00		 add	 DWORD PTR [ecx+128], eax
  00069	53		 push	 ebx
  0006a	8d 9a 48 0c 00
	00		 lea	 ebx, DWORD PTR [edx+3144]
  00070	8d 1c 59	 lea	 ebx, DWORD PTR [ecx+ebx*2]

; 93   : 	//float fOne_over_1MinusDecalEpsilon = 1.0f / (1.0f - m_cfDecalEpsilon);
; 94   : 
; 95   : 	// Assign vertex colors
; 96   : 	for (DWORD dwVertexNum = 0; dwVertexNum < dwAddCount; ++dwVertexNum)

  00073	85 ff		 test	 edi, edi
  00075	74 45		 je	 SHORT $LN3@AddPolygon

; 87   : 	DWORD dwCount = m_dwVertexCount;

  00077	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  0007a	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  0007d	56		 push	 esi
  0007e	8b 75 0c	 mov	 esi, DWORD PTR _c_pv3Vertex$[ebp]
  00081	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00087	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@AddPolygon:

; 97   : 	{
; 98   : 		*wIndex++ = (WORD) dwCount;

  00090	66 89 13	 mov	 WORD PTR [ebx], dx
  00093	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]

; 99   : 		m_Vertices[dwCount].position = c_pv3Vertex[dwVertexNum];

  00096	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]

; 100  : 		//const D3DXVECTOR3 & v3Normal = c_pv3Normal[dwVertexNum];
; 101  : 		//float fAlpha = (D3DXVec3Dot(&m_v3Normal, &v3Normal) / D3DXVec3Length(&v3Normal) - m_cfDecalEpsilon) * fOne_over_1MinusDecalEpsilon;
; 102  : 		//m_Vertices[dwCount].diffuse = D3DXCOLOR(1.0f, 1.0f, 1.0f, (fAlpha > 0.0f) ? fAlpha : 0.0f);
; 103  : 		m_Vertices[dwCount].diffuse = 0xFFFFFFFF;
; 104  : 		++dwCount;

  0009a	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
  0009d	66 0f d6 41 dc	 movq	 QWORD PTR [ecx-36], xmm0
  000a2	8d 76 0c	 lea	 esi, DWORD PTR [esi+12]
  000a5	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  000a8	42		 inc	 edx
  000a9	89 41 e4	 mov	 DWORD PTR [ecx-28], eax
  000ac	c7 41 e8 ff ff
	ff ff		 mov	 DWORD PTR [ecx-24], -1
  000b3	83 ef 01	 sub	 edi, 1
  000b6	75 d8		 jne	 SHORT $LL4@AddPolygon
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000bb	5e		 pop	 esi
$LN3@AddPolygon:

; 105  : 	}
; 106  : 
; 107  : 	m_dwVertexCount = dwCount;
; 108  : 	return true;

  000bc	5b		 pop	 ebx
  000bd	89 51 7c	 mov	 DWORD PTR [ecx+124], edx
  000c0	b0 01		 mov	 al, 1
  000c2	5f		 pop	 edi

; 109  : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 0c 00	 ret	 12			; 0000000cH
?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z ENDP	; CDecal::AddPolygon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ?Render@CDecal@@UAEXXZ
_TEXT	SEGMENT
_matWorld$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
?Render@CDecal@@UAEXXZ PROC				; CDecal::Render, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 226  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  00012	8d 45 bc	 lea	 eax, DWORD PTR _matWorld$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+56], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 226  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  0001c	50		 push	 eax
  0001d	8b f1		 mov	 esi, ecx
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0001f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+52], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 226  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0002c	68 00 01 00 00	 push	 256			; 00000100H
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+48], 0
  00038	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+44], 0
  0003f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+36], 0
  00046	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+32], 0
  0004d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+28], 0
  00054	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+24], 0
  0005b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+16], 0
  00062	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+12], 0
  00069	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+8], 0
  00070	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+4], 0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00077	c7 45 f8 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp+60], 1065353216 ; 3f800000H
  0007e	c7 45 e4 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp+40], 1065353216 ; 3f800000H
  00085	c7 45 d0 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp+20], 1065353216 ; 3f800000H
  0008c	c7 45 bc 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp], 1065353216 ; 3f800000H
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 226  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  00093	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 227  : 
; 228  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0009e	68 42 01 00 00	 push	 322			; 00000142H
  000a3	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000a8	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 230  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  000ae	33 db		 xor	 ebx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000b0	2b 86 84 00 00
	00		 sub	 eax, DWORD PTR [esi+132]
  000b6	c1 f8 04	 sar	 eax, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 230  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  000b9	85 c0		 test	 eax, eax
  000bb	74 56		 je	 SHORT $LN3@Render

; 223  : {

  000bd	57		 push	 edi
  000be	8d 86 90 00 00
	00		 lea	 eax, DWORD PTR [esi+144]
  000c4	33 ff		 xor	 edi, edi
$LL4@Render:

; 231  : 		STATEMANAGER.DrawIndexedPrimitiveUP(D3DPT_TRIANGLEFAN,

  000c6	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  000cc	6a 18		 push	 24			; 00000018H
  000ce	50		 push	 eax
  000cf	6a 65		 push	 101			; 00000065H
  000d1	0f b7 14 0f	 movzx	 edx, WORD PTR [edi+ecx]
  000d5	8d 86 90 18 00
	00		 lea	 eax, DWORD PTR [esi+6288]
  000db	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  000de	50		 push	 eax
  000df	ff 74 0f 08	 push	 DWORD PTR [edi+ecx+8]
  000e3	ff 74 0f 04	 push	 DWORD PTR [edi+ecx+4]
  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ed	52		 push	 edx
  000ee	6a 06		 push	 6
  000f0	e8 00 00 00 00	 call	 ?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z ; CStateManager::DrawIndexedPrimitiveUP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000f5	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 230  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  000fb	8d 7f 10	 lea	 edi, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000fe	2b 86 84 00 00
	00		 sub	 eax, DWORD PTR [esi+132]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 230  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  00104	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00105	c1 f8 04	 sar	 eax, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 230  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  00108	3b d8		 cmp	 ebx, eax
  0010a	8d 86 90 00 00
	00		 lea	 eax, DWORD PTR [esi+144]
  00110	72 b4		 jb	 SHORT $LL4@Render
  00112	5f		 pop	 edi
$LN3@Render:

; 232  : 		m_TriangleFanStructVector[dwi].m_wMinIndex,
; 233  : 		m_TriangleFanStructVector[dwi].m_dwVertexCount,
; 234  : 		m_TriangleFanStructVector[dwi].m_dwPrimitiveCount,
; 235  : 		m_Indices + m_TriangleFanStructVector[dwi].m_wMinIndex,
; 236  : 		D3DFMT_INDEX16,
; 237  : 		m_Vertices,
; 238  : 		sizeof(TPDTVertex));
; 239  : }

  00113	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	5e		 pop	 esi
  00117	33 cd		 xor	 ecx, ebp
  00119	5b		 pop	 ebx
  0011a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
?Render@CDecal@@UAEXXZ ENDP				; CDecal::Render
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ?Clear@CDecal@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = -12						; size = 12
?Clear@CDecal@@QAEXXZ PROC				; CDecal::Clear, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	0f 57 c9	 xorps	 xmm1, xmm1
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+8], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 25   : 	m_v3Center = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00010	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp+8]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	0f 14 c1	 unpcklps xmm0, xmm1
  00019	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  0001e	0f 57 c0	 xorps	 xmm0, xmm0
  00021	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 26   : 	m_v3Normal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00024	0f 14 c9	 unpcklps xmm1, xmm1
  00027	66 0f d6 49 10	 movq	 QWORD PTR [ecx+16], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+8], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 26   : 	m_v3Normal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00033	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp+8]
  00036	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 27   : 
; 28   : 	m_v4LeftPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  00039	0f 11 41 1c	 movups	 XMMWORD PTR [ecx+28], xmm0

; 29   : 	m_v4RightPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 30   : 	m_v4TopPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 31   : 	m_v4BottomPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 32   : 	m_v4FrontPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 33   : 	m_v4BackPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 34   : 
; 35   : 	m_dwVertexCount = 0;
; 36   : 	m_dwPrimitiveCount = 0;
; 37   : 
; 38   : 	m_TriangleFanStructVector.clear();
; 39   : 
; 40   : 	memset(m_Vertices, 0, sizeof(m_Vertices));
; 41   : 	memset(m_Indices, 0, sizeof(m_Indices));

  0003d	68 00 1a 00 00	 push	 6656			; 00001a00H
  00042	0f 11 41 2c	 movups	 XMMWORD PTR [ecx+44], xmm0
  00046	6a 00		 push	 0
  00048	0f 11 41 4c	 movups	 XMMWORD PTR [ecx+76], xmm0
  0004c	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], 0
  00053	0f 11 41 3c	 movups	 XMMWORD PTR [ecx+60], xmm0
  00057	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], 0
  00061	0f 11 41 5c	 movups	 XMMWORD PTR [ecx+92], xmm0
  00065	0f 11 41 6c	 movups	 XMMWORD PTR [ecx+108], xmm0
  00069	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  0006f	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax
  00075	8d 81 90 00 00
	00		 lea	 eax, DWORD PTR [ecx+144]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _memset
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 42   : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?Clear@CDecal@@QAEXXZ ENDP				; CDecal::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ??1CDecal@@UAE@XZ
_TEXT	SEGMENT
??1CDecal@@UAE@XZ PROC					; CDecal::~CDecal, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDecal@@6B@

; 20   : 	Clear();

  00009	e8 00 00 00 00	 call	 ?Clear@CDecal@@QAEXXZ	; CDecal::Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0000e	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00014	85 c9		 test	 ecx, ecx
  00016	74 33		 je	 SHORT $LN6@CDecal

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00018	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  0001e	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	83 e0 f0	 and	 eax, -16		; fffffff0H
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0002a	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00034	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00037	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0

; 1699 :             _Myend   = pointer();

  00041	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0
$LN6@CDecal:
  0004b	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 21   : }

  0004c	c3		 ret	 0
??1CDecal@@UAE@XZ ENDP					; CDecal::~CDecal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp
;	COMDAT ??0CDecal@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDecal@@QAE@XZ PROC					; CDecal::CDecal, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDecal@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00010	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  0001a	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0
  00024	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Decal.cpp

; 13   : CDecal::CDecal():m_cfDecalEpsilon(0.25f)

  0002e	c7 86 90 1a 00
	00 00 00 80 3e	 mov	 DWORD PTR [esi+6800], 1048576000 ; 3e800000H

; 15   : 	Clear();

  00038	e8 00 00 00 00	 call	 ?Clear@CDecal@@QAEXXZ	; CDecal::Clear

; 16   : }

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??0CDecal@@QAE@XZ ENDP					; CDecal::CDecal
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SPDTVertex@@QAE@XZ
_TEXT	SEGMENT
??0SPDTVertex@@QAE@XZ PROC				; SPDTVertex::SPDTVertex, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SPDTVertex@@QAE@XZ ENDP				; SPDTVertex::SPDTVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
