; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
PUBLIC	??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CAttributeInstance>::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCAttributeInstance@@@@8 DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCAttributeInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCAttributeInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ ; CDynamicPool<CAttributeInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
PUBLIC	??0CAttributeInstance@@QAE@XZ			; CAttributeInstance::CAttributeInstance
PUBLIC	??1CAttributeInstance@@UAE@XZ			; CAttributeInstance::~CAttributeInstance
PUBLIC	?Clear@CAttributeInstance@@QAEXXZ		; CAttributeInstance::Clear
PUBLIC	?IsEmpty@CAttributeInstance@@QBEHXZ		; CAttributeInstance::IsEmpty
PUBLIC	?GetDataFileName@CAttributeInstance@@QBEPBDXZ	; CAttributeInstance::GetDataFileName
PUBLIC	?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z ; CAttributeInstance::SetObjectPointer
PUBLIC	?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ; CAttributeInstance::RefreshObject
PUBLIC	?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ; CAttributeInstance::GetObjectPointer
PUBLIC	?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z ; CAttributeInstance::Picking
PUBLIC	?IsInHeight@CAttributeInstance@@QAEHMM@Z	; CAttributeInstance::IsInHeight
PUBLIC	?GetHeight@CAttributeInstance@@QAEHMMPAM@Z	; CAttributeInstance::GetHeight
PUBLIC	?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
PUBLIC	?CreateSystem@CAttributeInstance@@SAXI@Z	; CAttributeInstance::CreateSystem
PUBLIC	?DestroySystem@CAttributeInstance@@SAXXZ	; CAttributeInstance::DestroySystem
PUBLIC	?New@CAttributeInstance@@SAPAV1@XZ		; CAttributeInstance::New
PUBLIC	?Delete@CAttributeInstance@@SAXPAV1@@Z		; CAttributeInstance::Delete
PUBLIC	??_GCAttributeInstance@@UAEPAXI@Z		; CAttributeInstance::`scalar deleting destructor'
PUBLIC	??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
PUBLIC	?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ; CDynamicPool<CAttributeInstance>::Delete
PUBLIC	?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly
PUBLIC	?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
PUBLIC	??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >
PUBLIC	??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
PUBLIC	??_7CAttributeInstance@@6B@			; CAttributeInstance::`vftable'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CAttributeInstance@@6B@			; CAttributeInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAttributeInstance@@@8			; CAttributeInstance `RTTI Type Descriptor'
PUBLIC	??_R3CAttributeInstance@@8			; CAttributeInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAttributeInstance@@8			; CAttributeInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAttributeInstance@@8		; CAttributeInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?GetHeightDataCount@CAttributeData@@QBEKXZ:PROC	; CAttributeData::GetHeightDataCount
EXTRN	?GetHeightDataPointer@CAttributeData@@QBEHKPAPBUSHeightData@@@Z:PROC ; CAttributeData::GetHeightDataPointer
EXTRN	?GetMaximizeRadius@CAttributeData@@QAEMXZ:PROC	; CAttributeData::GetMaximizeRadius
EXTRN	??_ECAttributeInstance@@UAEPAXI@Z:PROC		; CAttributeInstance::`vector deleting destructor'
EXTRN	?IsInTriangle2D@@YA_NMMMMMMMM@Z:PROC		; IsInTriangle2D
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memmove:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CAttributeInstance@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CAttributeInstance@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CAttributeInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAttributeInstance@@8 DD FLAT:??_R0?AVCAttributeInstance@@@8 ; CAttributeInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CAttributeInstance@@8
rdata$r	SEGMENT
??_R2CAttributeInstance@@8 DD FLAT:??_R1A@?0A@EA@CAttributeInstance@@8 ; CAttributeInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CAttributeInstance@@8
rdata$r	SEGMENT
??_R3CAttributeInstance@@8 DD 00H			; CAttributeInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAttributeInstance@@@8
data$r	SEGMENT
??_R0?AVCAttributeInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CAttributeInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAttributeInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4CAttributeInstance@@6B@
rdata$r	SEGMENT
??_R4CAttributeInstance@@6B@ DD 00H			; CAttributeInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAttributeInstance@@@8
	DD	FLAT:??_R3CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CAttributeInstance@@6B@
CONST	SEGMENT
??_7CAttributeInstance@@6B@ DD FLAT:??_R4CAttributeInstance@@6B@ ; CAttributeInstance::`vftable'
	DD	FLAT:??_ECAttributeInstance@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCAttributeInstance@@@@6B@ ; CAttributeInstance::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CRef@VCAttributeData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAttributeInstance@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CAttributeInstance@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAttributeInstance@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00009	56		 push	 esi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 18		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00011	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00015	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00019	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1509 :         ++_Last;

  0001c	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0001f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1509 :         ++_Last;

  00022	83 c0 0c	 add	 eax, 12			; 0000000cH

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00025	3b ce		 cmp	 ecx, esi
  00027	75 e8		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:
  00029	5e		 pop	 esi

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  0000a	57		 push	 edi

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b cf		 cmp	 ecx, edi
  00010	74 57		 je	 SHORT $LN3@Uninitiali

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00012	8b d6		 mov	 edx, esi
  00014	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00017	2b d1		 sub	 edx, ecx
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00026	8d 40 0c	 lea	 eax, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00029	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00030	c7 44 02 f4 00
	00 00 00	 mov	 DWORD PTR [edx+eax-12], 0

; 386  :         _Myfirst = _Right._Myfirst;

  00038	8b 48 ec	 mov	 ecx, DWORD PTR [eax-20]
  0003b	89 0e		 mov	 DWORD PTR [esi], ecx

; 387  :         _Mylast  = _Right._Mylast;

  0003d	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00040	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00043	83 c6 0c	 add	 esi, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 388  :         _Myend   = _Right._Myend;

  00046	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  00049	89 4c 02 f4	 mov	 DWORD PTR [edx+eax-12], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0004d	8d 48 f8	 lea	 ecx, DWORD PTR [eax-8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 390  :         _Right._Myfirst = pointer();

  00050	c7 40 ec 00 00
	00 00		 mov	 DWORD PTR [eax-20], 0

; 391  :         _Right._Mylast  = pointer();

  00057	c7 40 f0 00 00
	00 00		 mov	 DWORD PTR [eax-16], 0

; 392  :         _Right._Myend   = pointer();

  0005e	c7 40 f4 00 00
	00 00		 mov	 DWORD PTR [eax-12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00065	3b cf		 cmp	 ecx, edi
  00067	75 b7		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1503 :         _Destroy_range(_First, _Last, _Al);

  00069	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0006c	56		 push	 esi
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();

  00076	8b c6		 mov	 eax, esi
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi

; 1664 :     }
; 1665 : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >, COMDAT

; 1824 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1825 :     // value-initialize _Count objects to raw _First, using _Al
; 1826 :     using _Ptrty = typename _Alloc::value_type*;
; 1827 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1828 :         auto _PFirst = _Unfancy(_First);
; 1829 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1830 :         return _First + _Count;
; 1831 :     } else {
; 1832 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1833 :         for (; 0 < _Count; --_Count) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 1825 :     // value-initialize _Count objects to raw _First, using _Al
; 1826 :     using _Ptrty = typename _Alloc::value_type*;
; 1827 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1828 :         auto _PFirst = _Unfancy(_First);
; 1829 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1830 :         return _First + _Count;
; 1831 :     } else {
; 1832 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1833 :         for (; 0 < _Count; --_Count) {

  00009	85 c0		 test	 eax, eax
  0000b	74 08		 je	 SHORT $LN16@Uninitiali
  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1838 :     }
; 1839 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN16@Uninitiali:

; 1834 :             _Backout._Emplace_back();
; 1835 :         }
; 1836 : 
; 1837 :         return _Backout._Release();

  00015	8b c1		 mov	 eax, ecx

; 1838 :     }
; 1839 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 1824 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1825 :     // value-initialize _Count objects to raw _First, using _Al
; 1826 :     using _Ptrty = typename _Alloc::value_type*;
; 1827 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1828 :         auto _PFirst = _Unfancy(_First);
; 1829 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1830 :         return _First + _Count;
; 1831 :     } else {
; 1832 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1833 :         for (; 0 < _Count; --_Count) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 1825 :     // value-initialize _Count objects to raw _First, using _Al
; 1826 :     using _Ptrty = typename _Alloc::value_type*;
; 1827 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1828 :         auto _PFirst = _Unfancy(_First);
; 1829 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1830 :         return _First + _Count;
; 1831 :     } else {
; 1832 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1833 :         for (; 0 < _Count; --_Count) {

  0000a	85 c0		 test	 eax, eax
  0000c	74 1e		 je	 SHORT $LN3@Uninitiali
  0000e	66 90		 npad	 2
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00016	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00024	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1825 :     // value-initialize _Count objects to raw _First, using _Al
; 1826 :     using _Ptrty = typename _Alloc::value_type*;
; 1827 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1828 :         auto _PFirst = _Unfancy(_First);
; 1829 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1830 :         return _First + _Count;
; 1831 :     } else {
; 1832 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1833 :         for (; 0 < _Count; --_Count) {

  00027	83 e8 01	 sub	 eax, 1
  0002a	75 e4		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1503 :         _Destroy_range(_First, _Last, _Al);

  0002c	ff 75 10	 push	 DWORD PTR __Al$[ebp]
  0002f	56		 push	 esi
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1834 :             _Backout._Emplace_back();
; 1835 :         }
; 1836 : 
; 1837 :         return _Backout._Release();

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 1838 :     }
; 1839 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
tv319 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1183 :         if (_Newsize > max_size()) {

  00005	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	81 fe 55 55 55
	15		 cmp	 esi, 357913941		; 15555555H
  00011	0f 87 9c 00 00
	00		 ja	 $LN36@Resize_rea

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00017	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001f	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00021	f7 e9		 imul	 ecx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00023	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	d1 fa		 sar	 edx, 1
  0002a	8b ca		 mov	 ecx, edx
  0002c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0002f	03 ca		 add	 ecx, edx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00031	8b d1		 mov	 edx, ecx
  00033	d1 ea		 shr	 edx, 1
  00035	2b c2		 sub	 eax, edx
  00037	3b c8		 cmp	 ecx, eax
  00039	77 10		 ja	 SHORT $LN34@Resize_rea

; 1620 :             return _Newsize; // geometric growth would overflow
; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0003b	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003e	3b c6		 cmp	 eax, esi
  00040	72 09		 jb	 SHORT $LN34@Resize_rea
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00042	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00047	77 6f		 ja	 SHORT $LN37@Resize_rea
  00049	eb 02		 jmp	 SHORT $LN18@Resize_rea
$LN34@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0004b	8b c6		 mov	 eax, esi
$LN18@Resize_rea:
  0004d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00050	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00053	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00054	89 45 08	 mov	 DWORD PTR tv319[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00057	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0005c	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005d	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0005f	53		 push	 ebx
  00060	ff 77 04	 push	 DWORD PTR [edi+4]
  00063	ff 37		 push	 DWORD PTR [edi]
  00065	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  0006a	8b 07		 mov	 eax, DWORD PTR [edi]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0006c	83 c4 14	 add	 esp, 20			; 00000014H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  0006f	85 c0		 test	 eax, eax
  00071	74 26		 je	 SHORT $LN29@Resize_rea

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00073	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00076	2b c8		 sub	 ecx, eax
  00078	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007d	f7 e9		 imul	 ecx
  0007f	d1 fa		 sar	 edx, 1
  00081	8b c2		 mov	 eax, edx
  00083	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00086	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00088	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0008b	c1 e0 02	 shl	 eax, 2
  0008e	50		 push	 eax
  0008f	ff 37		 push	 DWORD PTR [edi]
  00091	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00096	83 c4 08	 add	 esp, 8
$LN29@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00099	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0009c	89 1f		 mov	 DWORD PTR [edi], ebx
  0009e	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  000a1	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000a4	8b 45 08	 mov	 eax, DWORD PTR tv319[ebp]
  000a7	03 c3		 add	 eax, ebx
  000a9	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx

; 1208 :     }

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
$LN36@Resize_rea:

; 1184 :             _Xlength();

  000b3	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
$LN37@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000b8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN33@Resize_rea:
  000bd	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
tv302 = -8						; size = 4
__Newvec$1$ = -4					; size = 4
__Oldsize$1$ = 8					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1183 :         if (_Newsize > max_size()) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	81 fb 55 55 55
	15		 cmp	 ebx, 357913941		; 15555555H
  00014	0f 87 e0 00 00
	00		 ja	 $LN38@Resize_rea

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0001a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00022	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00024	f7 e9		 imul	 ecx

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00026	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00029	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0002b	d1 fa		 sar	 edx, 1
  0002d	8b c2		 mov	 eax, edx
  0002f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00032	03 c2		 add	 eax, edx
  00034	89 45 08	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00037	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0003c	f7 e9		 imul	 ecx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0003e	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00043	d1 fa		 sar	 edx, 1
  00045	8b ca		 mov	 ecx, edx
  00047	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0004a	03 ca		 add	 ecx, edx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0004c	8b d1		 mov	 edx, ecx
  0004e	d1 ea		 shr	 edx, 1
  00050	2b c2		 sub	 eax, edx
  00052	3b c8		 cmp	 ecx, eax
  00054	77 14		 ja	 SHORT $LN36@Resize_rea

; 1620 :             return _Newsize; // geometric growth would overflow
; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00056	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00059	3b c3		 cmp	 eax, ebx
  0005b	72 0d		 jb	 SHORT $LN36@Resize_rea
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0005d	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00062	0f 87 97 00 00
	00		 ja	 $LN39@Resize_rea
  00068	eb 02		 jmp	 SHORT $LN18@Resize_rea
$LN36@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0006a	8b c3		 mov	 eax, ebx
$LN18@Resize_rea:
  0006c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0006f	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00072	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00073	89 45 f8	 mov	 DWORD PTR tv302[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00076	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0007e	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00080	8b c3		 mov	 eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00082	89 75 fc	 mov	 DWORD PTR __Newvec$1$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00085	2b c1		 sub	 eax, ecx

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00087	57		 push	 edi
  00088	50		 push	 eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1193 : 
; 1194 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);
; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00089	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0008c	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00095	57		 push	 edi
  00096	56		 push	 esi
  00097	ff 77 04	 push	 DWORD PTR [edi+4]
  0009a	ff 37		 push	 DWORD PTR [edi]
  0009c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000a1	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000a3	83 c4 20	 add	 esp, 32			; 00000020H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000a6	85 c9		 test	 ecx, ecx
  000a8	74 34		 je	 SHORT $LN29@Resize_rea

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  000aa	57		 push	 edi
  000ab	ff 77 04	 push	 DWORD PTR [edi+4]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b4	8b 37		 mov	 esi, DWORD PTR [edi]
  000b6	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000bb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000be	2b ce		 sub	 ecx, esi
  000c0	f7 e9		 imul	 ecx
  000c2	d1 fa		 sar	 edx, 1
  000c4	8b c2		 mov	 eax, edx
  000c6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c9	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000cb	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000ce	c1 e0 02	 shl	 eax, 2
  000d1	50		 push	 eax
  000d2	56		 push	 esi
  000d3	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000d8	8b 75 fc	 mov	 esi, DWORD PTR __Newvec$1$[ebp]
  000db	83 c4 14	 add	 esp, 20			; 00000014H
$LN29@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000de	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  000e1	89 37		 mov	 DWORD PTR [edi], esi
  000e3	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e6	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000e9	8b 45 f8	 mov	 eax, DWORD PTR tv302[ebp]
  000ec	03 c6		 add	 eax, esi
  000ee	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx

; 1208 :     }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c2 08 00	 ret	 8
$LN38@Resize_rea:

; 1184 :             _Xlength();

  000fa	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
$LN39@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000ff	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN35@Resize_rea:
  00104	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z PROC ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CAttributeInstance *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 959  :         for (; _First != _Last; ++_First) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 48		 je	 SHORT $LN3@Destroy_ra
  0000f	57		 push	 edi
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00010	8b 3e		 mov	 edi, DWORD PTR [esi]
  00012	85 ff		 test	 edi, edi
  00014	74 39		 je	 SHORT $LN14@Destroy_ra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	2b cf		 sub	 ecx, edi
  00020	f7 e9		 imul	 ecx
  00022	d1 fa		 sar	 edx, 1
  00024	8b c2		 mov	 eax, edx
  00026	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00029	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002e	c1 e0 02	 shl	 eax, 2
  00031	50		 push	 eax
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003e	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN14@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  0004f	83 c6 0c	 add	 esi, 12			; 0000000cH
  00052	3b f3		 cmp	 esi, ebx
  00054	75 ba		 jne	 SHORT $LL4@Destroy_ra
  00056	5f		 pop	 edi
$LN3@Destroy_ra:
  00057	5e		 pop	 esi

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00058	5b		 pop	 ebx
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
tv436 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv435 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 be 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00045	8b c7		 mov	 eax, edi
  00047	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00049	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004c	3b c7		 cmp	 eax, edi
  0004e	0f 42 c7	 cmovb	 eax, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 8f 00 00
	00		 ja	 $LN40@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00060	89 45 f4	 mov	 DWORD PTR tv436[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00063	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006d	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00073	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00076	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	3b da		 cmp	 ebx, edx
  00084	75 07		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00086	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0008b	eb 17		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008d	56		 push	 esi
  0008e	57		 push	 edi
  0008f	53		 push	 ebx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009e	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000a4	56		 push	 esi
  000a5	50		 push	 eax
  000a6	52		 push	 edx
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000b2	85 c9		 test	 ecx, ecx
  000b4	74 12		 je	 SHORT $LN33@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	83 e0 fc	 and	 eax, -4			; fffffffcH
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c5	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000cb	8b c3		 mov	 eax, ebx

; 1680 :         _Myfirst = _Newvec;

  000cd	89 3e		 mov	 DWORD PTR [esi], edi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000cf	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  000d2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv436[ebp]
  000d8	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000da	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000db	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 767  :     }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000eb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f0	cc		 int	 3
??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CAttributeInstance::ms_kPool'', COMDAT

; 6    : CDynamicPool<CAttributeInstance> CAttributeInstance::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CAttributeInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv254 = 8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 1252 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1253 :         auto& _My_data    = _Mypair._Myval2;
; 1254 :         pointer& _Myfirst = _My_data._Myfirst;
; 1255 :         pointer& _Mylast  = _My_data._Mylast;
; 1256 : 
; 1257 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  0000b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000e	2b 3e		 sub	 edi, DWORD PTR [esi]
  00010	c1 ff 02	 sar	 edi, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00013	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00018	77 4c		 ja	 SHORT $LN26@Reallocate

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0001a	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0001d	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  0001e	89 45 08	 mov	 DWORD PTR tv254[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00021	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00026	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00027	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00029	53		 push	 ebx
  0002a	ff 76 04	 push	 DWORD PTR [esi+4]
  0002d	ff 36		 push	 DWORD PTR [esi]
  0002f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00034	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00036	83 c4 14	 add	 esp, 20			; 00000014H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00039	85 c9		 test	 ecx, ecx
  0003b	74 12		 je	 SHORT $LN20@Reallocate

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0003d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00040	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00042	83 e0 fc	 and	 eax, -4			; fffffffcH
  00045	50		 push	 eax
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0004c	83 c4 08	 add	 esp, 8
$LN20@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0004f	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00052	89 1e		 mov	 DWORD PTR [esi], ebx
  00054	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00057	8b 45 08	 mov	 eax, DWORD PTR tv254[ebp]
  0005a	03 c3		 add	 eax, ebx
  0005c	5f		 pop	 edi
  0005d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx

; 1269 :     }

  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
$LN26@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00066	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN24@Reallocate:
  0006b	cc		 int	 3
?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z PROC ; CDynamicPool<CAttributeInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 			delete pkData;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkData$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN3@Delete
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN3@Delete:

; 111  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ENDP ; CDynamicPool<CAttributeInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ PROC	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 27		 je	 SHORT $LN6@CDynamicPo

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00013	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e0 fc	 and	 eax, -4			; fffffffcH
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00026	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00029	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1699 :             _Myend   = pointer();

  00030	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN6@CDynamicPo:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00037	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 27		 je	 SHORT $LN13@CDynamicPo

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0003e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00041	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00043	83 e0 fc	 and	 eax, -4			; fffffffcH
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0004d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00057	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1699 :             _Myend   = pointer();

  0005e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN13@CDynamicPo:
  00065	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 26   : 		}

  00066	c3		 ret	 0
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ENDP	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCAttributeInstance@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCAttributeInstance@@UAEPAXI@Z PROC			; CAttributeInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CAttributeInstance@@UAE@XZ ; CAttributeInstance::~CAttributeInstance
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 5c		 push	 92			; 0000005cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCAttributeInstance@@UAEPAXI@Z ENDP			; CAttributeInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Delete@CAttributeInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkInst$ = 8						; size = 4
?Delete@CAttributeInstance@@SAXPAV1@@Z PROC		; CAttributeInstance::Delete, COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00003	a1 14 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 188  : 	ms_kPool.Free(pkInst);

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  0000b	89 4d 08	 mov	 DWORD PTR _pkData$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0000e	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+24
  00014	74 0b		 je	 SHORT $LN8@Delete

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00018	83 05 14 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 189  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN8@Delete:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	8d 4d 08	 lea	 ecx, DWORD PTR _pkData$[ebp]
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  0002b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 189  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Delete@CAttributeInstance@@SAXPAV1@@Z ENDP		; CAttributeInstance::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?New@CAttributeInstance@@SAPAV1@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pkNewData$2 = -4					; size = 4
?New@CAttributeInstance@@SAPAV1@XZ PROC			; CAttributeInstance::New, COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00004	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20
  0000a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16, ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00010	75 61		 jne	 SHORT $LN4@New

; 65   : 				T* pkNewData=new T;

  00012	56		 push	 esi
  00013	6a 5c		 push	 92			; 0000005cH
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00020	85 c0		 test	 eax, eax
  00022	74 0b		 je	 SHORT $LN6@New
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??0CAttributeInstance@@QAE@XZ ; CAttributeInstance::CAttributeInstance
  0002b	8b f0		 mov	 esi, eax
  0002d	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  0002f	33 f6		 xor	 esi, esi
$LN7@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00031	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 65   : 				T* pkNewData=new T;

  00036	89 75 fc	 mov	 DWORD PTR _pkNewData$2[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00039	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+12
  0003f	74 16		 je	 SHORT $LN14@New

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00041	89 30		 mov	 DWORD PTR [eax], esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 183  : 	return ms_kPool.Alloc();

  00043	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00045	83 05 08 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0004c	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+32
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 183  : 	return ms_kPool.Alloc();

  00052	5e		 pop	 esi

; 184  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN14@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00057	8d 4d fc	 lea	 ecx, DWORD PTR _pkNewData$2[ebp]
  0005a	51		 push	 ecx
  0005b	50		 push	 eax
  0005c	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
  00061	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  00066	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+32
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 183  : 	return ms_kPool.Alloc();

  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi

; 184  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN4@New:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00073	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1559 :         return _My_data._Mylast[-1];

  00076	83 c1 fc	 add	 ecx, -4			; fffffffcH

; 1338 :         --_Mylast;

  00079	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20, ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 184  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?New@CAttributeInstance@@SAPAV1@XZ ENDP			; CAttributeInstance::New
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?DestroySystem@CAttributeInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CAttributeInstance@@SAXXZ PROC		; CAttributeInstance::DestroySystem, COMDAT

; 177  : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 177  : {

  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 234  :     const auto _ULast = _Get_unwrapped(_Last);

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000e	3b f7		 cmp	 esi, edi
  00010	74 2a		 je	 SHORT $LN30@DestroySys
$LL20@DestroySys:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 110  : 			delete pkData;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN18@DestroySys
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 01		 push	 1
  0001c	ff 10		 call	 DWORD PTR [eax]
$LN18@DestroySys:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001e	83 c6 04	 add	 esi, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL20@DestroySys
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 51   : 			m_kVct_pkData.clear();

  00025	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
  0002a	a3 08 00 00 00	 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8, eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 179  : }

  0002f	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  00034	5f		 pop	 edi
  00035	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20, eax
  0003a	5e		 pop	 esi
  0003b	c3		 ret	 0
$LN30@DestroySys:
  0003c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  00041	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 51   : 			m_kVct_pkData.clear();

  00042	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 179  : }

  00048	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20, eax
  0004d	5e		 pop	 esi
  0004e	c3		 ret	 0
?DestroySystem@CAttributeInstance@@SAXXZ ENDP		; CAttributeInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?CreateSystem@CAttributeInstance@@SAXI@Z
_TEXT	SEGMENT
_uCapacity$ = 8						; size = 4
?CreateSystem@CAttributeInstance@@SAXI@Z PROC		; CAttributeInstance::CreateSystem, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+12
  00008	2b 05 04 00 00
	00		 sub	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 172  : {

  0000e	56		 push	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 57   : 			m_uInitCapacity=uCapacity;

  0000f	8b 75 08	 mov	 esi, DWORD PTR _uCapacity$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	c1 f8 02	 sar	 eax, 2
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Pool.h

; 57   : 			m_uInitCapacity=uCapacity;

  00015	89 35 1c 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+28, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  0001b	3b f0		 cmp	 esi, eax
  0001d	76 13		 jbe	 SHORT $LN6@CreateSyst

; 1307 :             if (_Newcapacity > max_size()) {

  0001f	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00025	77 33		 ja	 SHORT $LN19@CreateSyst

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  00027	56		 push	 esi
  00028	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
  0002d	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly
$LN6@CreateSyst:

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00032	a1 18 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+24
  00037	2b 05 10 00 00
	00		 sub	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  0003d	c1 f8 02	 sar	 eax, 2

; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00040	3b f0		 cmp	 esi, eax
  00042	76 13		 jbe	 SHORT $LN13@CreateSyst

; 1307 :             if (_Newcapacity > max_size()) {

  00044	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0004a	77 0e		 ja	 SHORT $LN19@CreateSyst

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0004c	56		 push	 esi
  0004d	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  00052	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly
$LN13@CreateSyst:
  00057	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 174  : }

  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN19@CreateSyst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1308 :                 _Xlength();

  0005a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
$LN20@CreateSyst:
  0005f	cc		 int	 3
?CreateSystem@CAttributeInstance@@SAXI@Z ENDP		; CAttributeInstance::CreateSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetHeight@CAttributeInstance@@QAEHMMPAM@Z
_TEXT	SEGMENT
_pfHeight$GSCopy$1$ = -40				; size = 4
_bFlag$1$ = -36						; size = 4
_this$GSCopy$1$ = -32					; size = 4
_i$1$ = -28						; size = 4
_j$1$ = -24						; size = 4
tv929 = -20						; size = 4
_v3Cross$1 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_pfHeight$ = 16						; size = 4
?GetHeight@CAttributeInstance@@QAEHMMPAM@Z PROC		; CAttributeInstance::GetHeight, COMDAT
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _pfHeight$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	89 45 d8	 mov	 DWORD PTR _pfHeight$GSCopy$1$[ebp], eax
  00019	89 75 e0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 68   : 	if(IsEmpty())

  0001c	e8 00 00 00 00	 call	 ?IsEmpty@CAttributeInstance@@QBEHXZ ; CAttributeInstance::IsEmpty
  00021	85 c0		 test	 eax, eax
  00023	0f 85 f8 02 00
	00		 jne	 $LN54@GetHeight

; 69   : 		return FALSE;
; 70   : 
; 71   : 	fy *= -1.0f;

  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]

; 72   : 
; 73   : 	if (!IsInHeight(fx, fy))

  0002e	83 ec 08	 sub	 esp, 8
  00031	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf800000
  00039	8b ce		 mov	 ecx, esi
  0003b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00041	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
  00046	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0004b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00050	e8 00 00 00 00	 call	 ?IsInHeight@CAttributeInstance@@QAEHMM@Z ; CAttributeInstance::IsInHeight
  00055	85 c0		 test	 eax, eax
  00057	0f 84 c4 02 00
	00		 je	 $LN54@GetHeight
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0005d	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 78   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00060	33 c0		 xor	 eax, eax
  00062	89 45 e4	 mov	 DWORD PTR _i$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00065	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 76   : 	BOOL bFlag = FALSE;

  0006a	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0006b	8b 5e 4c	 mov	 ebx, DWORD PTR [esi+76]
  0006e	2b cb		 sub	 ecx, ebx
  00070	f7 e9		 imul	 ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 76   : 	BOOL bFlag = FALSE;

  00072	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00073	d1 fa		 sar	 edx, 1
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 76   : 	BOOL bFlag = FALSE;

  00075	33 ff		 xor	 edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00077	8b c2		 mov	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 76   : 	BOOL bFlag = FALSE;

  00079	89 7d dc	 mov	 DWORD PTR _bFlag$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0007c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007f	03 c2		 add	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 78   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00081	0f 84 85 02 00
	00		 je	 $LN3@GetHeight
  00087	33 f6		 xor	 esi, esi
  00089	89 75 ec	 mov	 DWORD PTR tv929[ebp], esi
  0008c	0f 1f 40 00	 npad	 4
$LL4@GetHeight:

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  00090	33 c9		 xor	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00092	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  00097	89 4d e8	 mov	 DWORD PTR _j$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0009a	8b fb		 mov	 edi, ebx
  0009c	8b 4c 33 04	 mov	 ecx, DWORD PTR [ebx+esi+4]
  000a0	2b 0c 33	 sub	 ecx, DWORD PTR [ebx+esi]
  000a3	f7 e9		 imul	 ecx
  000a5	d1 fa		 sar	 edx, 1
  000a7	8b c2		 mov	 eax, edx
  000a9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ac	03 c2		 add	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  000ae	0f 84 29 02 00
	00		 je	 $LN2@GetHeight
  000b4	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fx$[ebp]
  000b9	33 f6		 xor	 esi, esi
  000bb	0f 1f 44 00 00	 npad	 5
$LL7@GetHeight:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  000c0	8b 7d ec	 mov	 edi, DWORD PTR tv929[ebp]
  000c3	8b 3c 3b	 mov	 edi, DWORD PTR [ebx+edi]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 88   : 			fy<c_rv3Vertex0.y && fy<c_rv3Vertex1.y && fy<c_rv3Vertex2.y ||

  000c6	f3 0f 10 24 37	 movss	 xmm4, DWORD PTR [edi+esi]
  000cb	0f 2f e1	 comiss	 xmm4, xmm1
  000ce	76 1a		 jbe	 SHORT $LN12@GetHeight
  000d0	f3 0f 10 44 37
	0c		 movss	 xmm0, DWORD PTR [edi+esi+12]
  000d6	0f 2f c1	 comiss	 xmm0, xmm1
  000d9	76 0f		 jbe	 SHORT $LN12@GetHeight
  000db	f3 0f 10 44 37
	18		 movss	 xmm0, DWORD PTR [edi+esi+24]
  000e1	0f 2f c1	 comiss	 xmm0, xmm1
  000e4	0f 87 be 01 00
	00		 ja	 $LN5@GetHeight
$LN12@GetHeight:
  000ea	0f 2f cc	 comiss	 xmm1, xmm4
  000ed	76 12		 jbe	 SHORT $LN13@GetHeight
  000ef	0f 2f 4c 37 0c	 comiss	 xmm1, DWORD PTR [edi+esi+12]
  000f4	76 0b		 jbe	 SHORT $LN13@GetHeight
  000f6	0f 2f 4c 37 18	 comiss	 xmm1, DWORD PTR [edi+esi+24]
  000fb	0f 87 a7 01 00
	00		 ja	 $LN5@GetHeight
$LN13@GetHeight:
  00101	f3 0f 10 5c 37
	04		 movss	 xmm3, DWORD PTR [edi+esi+4]
  00107	f3 0f 10 55 0c	 movss	 xmm2, DWORD PTR _fy$[ebp]
  0010c	0f 2f da	 comiss	 xmm3, xmm2
  0010f	76 1a		 jbe	 SHORT $LN14@GetHeight
  00111	f3 0f 10 44 37
	10		 movss	 xmm0, DWORD PTR [edi+esi+16]
  00117	0f 2f c2	 comiss	 xmm0, xmm2
  0011a	76 0f		 jbe	 SHORT $LN14@GetHeight
  0011c	f3 0f 10 44 37
	1c		 movss	 xmm0, DWORD PTR [edi+esi+28]
  00122	0f 2f c2	 comiss	 xmm0, xmm2
  00125	0f 87 7d 01 00
	00		 ja	 $LN5@GetHeight
$LN14@GetHeight:
  0012b	0f 2f d3	 comiss	 xmm2, xmm3
  0012e	76 12		 jbe	 SHORT $LN10@GetHeight
  00130	0f 2f 54 37 10	 comiss	 xmm2, DWORD PTR [edi+esi+16]
  00135	76 0b		 jbe	 SHORT $LN10@GetHeight
  00137	0f 2f 54 37 1c	 comiss	 xmm2, DWORD PTR [edi+esi+28]
  0013c	0f 87 66 01 00
	00		 ja	 $LN5@GetHeight
$LN10@GetHeight:

; 89   : 			fy>c_rv3Vertex0.y && fy>c_rv3Vertex1.y && fy>c_rv3Vertex2.y
; 90   : 			)
; 91   : 			continue;
; 92   : 
; 93   : 		if (IsInTriangle2D(c_rv3Vertex0.x, c_rv3Vertex0.y,

  00142	f3 0f 10 44 37
	1c		 movss	 xmm0, DWORD PTR [edi+esi+28]
  00148	83 ec 20	 sub	 esp, 32			; 00000020H
  0014b	f3 0f 11 54 24
	1c		 movss	 DWORD PTR [esp+28], xmm2
  00151	f3 0f 11 4c 24
	18		 movss	 DWORD PTR [esp+24], xmm1
  00157	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  0015d	f3 0f 10 44 37
	18		 movss	 xmm0, DWORD PTR [edi+esi+24]
  00163	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  00169	f3 0f 10 44 37
	10		 movss	 xmm0, DWORD PTR [edi+esi+16]
  0016f	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00175	f3 0f 10 44 37
	0c		 movss	 xmm0, DWORD PTR [edi+esi+12]
  0017b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00181	f3 0f 11 5c 24
	04		 movss	 DWORD PTR [esp+4], xmm3
  00187	f3 0f 11 24 24	 movss	 DWORD PTR [esp], xmm4
  0018c	e8 00 00 00 00	 call	 ?IsInTriangle2D@@YA_NMMMMMMMM@Z ; IsInTriangle2D
  00191	83 c4 20	 add	 esp, 32			; 00000020H
  00194	84 c0		 test	 al, al
  00196	0f 84 07 01 00
	00		 je	 $LN56@GetHeight
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0019c	f3 0f 10 64 37
	1c		 movss	 xmm4, DWORD PTR [edi+esi+28]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 102  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  001a2	8d 45 f0	 lea	 eax, DWORD PTR _v3Cross$1[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001a5	f3 0f 10 54 37
	20		 movss	 xmm2, DWORD PTR [edi+esi+32]
  001ab	f3 0f 5c 64 37
	04		 subss	 xmm4, DWORD PTR [edi+esi+4]
  001b1	f3 0f 5c 54 37
	08		 subss	 xmm2, DWORD PTR [edi+esi+8]
  001b7	f3 0f 10 74 37
	10		 movss	 xmm6, DWORD PTR [edi+esi+16]
  001bd	f3 0f 10 5c 37
	14		 movss	 xmm3, DWORD PTR [edi+esi+20]
  001c3	f3 0f 5c 74 37
	04		 subss	 xmm6, DWORD PTR [edi+esi+4]
  001c9	f3 0f 5c 5c 37
	08		 subss	 xmm3, DWORD PTR [edi+esi+8]
  001cf	f3 0f 10 6c 37
	18		 movss	 xmm5, DWORD PTR [edi+esi+24]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  001d5	0f 28 c4	 movaps	 xmm0, xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001d8	f3 0f 5c 2c 37	 subss	 xmm5, DWORD PTR [edi+esi]
  001dd	f3 0f 10 7c 37
	0c		 movss	 xmm7, DWORD PTR [edi+esi+12]

; 182  :     z = fz;

  001e3	0f 28 ca	 movaps	 xmm1, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001e6	f3 0f 5c 3c 37	 subss	 xmm7, DWORD PTR [edi+esi]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  001eb	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 102  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  001ef	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 182  :     z = fz;

  001f0	f3 0f 59 ce	 mulss	 xmm1, xmm6
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 102  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  001f4	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  001f5	f3 0f 59 d7	 mulss	 xmm2, xmm7
  001f9	f3 0f 5c c8	 subss	 xmm1, xmm0
  001fd	f3 0f 59 e7	 mulss	 xmm4, xmm7
  00201	0f 28 c5	 movaps	 xmm0, xmm5

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00204	f3 0f 59 ee	 mulss	 xmm5, xmm6
  00208	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0020c	f3 0f 5c e5	 subss	 xmm4, xmm5

; 1280 : 
; 1281 :     *pOut = v;

  00210	f3 0f 11 4d f0	 movss	 DWORD PTR _v3Cross$1[ebp], xmm1
  00215	f3 0f 5c c2	 subss	 xmm0, xmm2
  00219	f3 0f 11 65 f8	 movss	 DWORD PTR _v3Cross$1[ebp+8], xmm4
  0021e	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Cross$1[ebp+4], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 102  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  00223	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 103  : 
; 104  : 			if (0.0f != v3Cross.z)

  00228	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _v3Cross$1[ebp+8]
  0022d	0f 57 c0	 xorps	 xmm0, xmm0
  00230	0f 2e c4	 ucomiss xmm0, xmm4
  00233	9f		 lahf
  00234	f6 c4 44	 test	 ah, 68			; 00000044H
  00237	7b 6a		 jnp	 SHORT $LN56@GetHeight

; 105  : 			{
; 106  : 				float fd = (v3Cross.x*c_rv3Vertex0.x + v3Cross.y*c_rv3Vertex0.y + v3Cross.z*c_rv3Vertex0.z);

  00239	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v3Cross$1[ebp+4]

; 107  : 				float fm = (v3Cross.x*fx + v3Cross.y*fy);
; 108  : 				*pfHeight = fMAX((fd - fm) / v3Cross.z, *pfHeight);

  0023e	83 ec 08	 sub	 esp, 8
  00241	f3 0f 10 04 37	 movss	 xmm0, DWORD PTR [edi+esi]
  00246	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _v3Cross$1[ebp]
  0024b	f3 0f 10 5c 37
	04		 movss	 xmm3, DWORD PTR [edi+esi+4]
  00251	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00255	8b 5d d8	 mov	 ebx, DWORD PTR _pfHeight$GSCopy$1$[ebp]
  00258	f3 0f 59 55 08	 mulss	 xmm2, DWORD PTR _fx$[ebp]
  0025d	f3 0f 59 d9	 mulss	 xmm3, xmm1
  00261	f3 0f 59 4d 0c	 mulss	 xmm1, DWORD PTR _fy$[ebp]
  00266	f3 0f 58 d8	 addss	 xmm3, xmm0
  0026a	0f 28 c4	 movaps	 xmm0, xmm4
  0026d	f3 0f 59 44 37
	08		 mulss	 xmm0, DWORD PTR [edi+esi+8]
  00273	f3 0f 58 d1	 addss	 xmm2, xmm1
  00277	f3 0f 58 d8	 addss	 xmm3, xmm0
  0027b	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  0027f	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00285	f3 0f 5c da	 subss	 xmm3, xmm2
  00289	f3 0f 5e dc	 divss	 xmm3, xmm4
  0028d	f3 0f 11 1c 24	 movss	 DWORD PTR [esp], xmm3
  00292	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  00297	d9 1b		 fstp	 DWORD PTR [ebx]
  00299	83 c4 08	 add	 esp, 8

; 109  : 
; 110  : 				bFlag = TRUE;

  0029c	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _bFlag$1$[ebp], 1
$LN56@GetHeight:

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  002a3	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fx$[ebp]
$LN5@GetHeight:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  002a8	8b 45 e0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  002ab	83 c6 24	 add	 esi, 36			; 00000024H
  002ae	83 45 e8 03	 add	 DWORD PTR _j$1$[ebp], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  002b2	8b 78 4c	 mov	 edi, DWORD PTR [eax+76]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002b5	8b df		 mov	 ebx, edi
  002b7	8b 45 ec	 mov	 eax, DWORD PTR tv929[ebp]
  002ba	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  002be	2b 0c 07	 sub	 ecx, DWORD PTR [edi+eax]
  002c1	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002c6	f7 e9		 imul	 ecx
  002c8	d1 fa		 sar	 edx, 1
  002ca	8b c2		 mov	 eax, edx
  002cc	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002cf	03 c2		 add	 eax, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  002d1	39 45 e8	 cmp	 DWORD PTR _j$1$[ebp], eax
  002d4	0f 82 e6 fd ff
	ff		 jb	 $LL7@GetHeight
  002da	8b 75 ec	 mov	 esi, DWORD PTR tv929[ebp]
$LN2@GetHeight:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002dd	8b 45 e0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 78   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  002e0	83 c6 0c	 add	 esi, 12			; 0000000cH
  002e3	ff 45 e4	 inc	 DWORD PTR _i$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002e6	8b df		 mov	 ebx, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 78   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  002e8	89 75 ec	 mov	 DWORD PTR tv929[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002eb	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  002ee	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002f3	2b cf		 sub	 ecx, edi
  002f5	f7 e9		 imul	 ecx
  002f7	d1 fa		 sar	 edx, 1
  002f9	8b ca		 mov	 ecx, edx
  002fb	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  002fe	03 ca		 add	 ecx, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 78   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00300	39 4d e4	 cmp	 DWORD PTR _i$1$[ebp], ecx
  00303	0f 82 87 fd ff
	ff		 jb	 $LL4@GetHeight
  00309	8b 7d dc	 mov	 edi, DWORD PTR _bFlag$1$[ebp]
$LN3@GetHeight:

; 111  : 			}
; 112  : 		}
; 113  : 	}
; 114  : 
; 115  : 	return bFlag;

  0030c	8b c7		 mov	 eax, edi
  0030e	5f		 pop	 edi
  0030f	5b		 pop	 ebx
  00310	5e		 pop	 esi

; 116  : }

  00311	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00314	33 cd		 xor	 ecx, ebp
  00316	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031b	8b e5		 mov	 esp, ebp
  0031d	5d		 pop	 ebp
  0031e	c2 0c 00	 ret	 12			; 0000000cH
$LN54@GetHeight:
  00321	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00324	33 c0		 xor	 eax, eax
  00326	33 cd		 xor	 ecx, ebp
  00328	5e		 pop	 esi
  00329	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032e	8b e5		 mov	 esp, ebp
  00330	5d		 pop	 ebp
  00331	c2 0c 00	 ret	 12			; 0000000cH
?GetHeight@CAttributeInstance@@QAEHMMPAM@Z ENDP		; CAttributeInstance::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?IsInHeight@CAttributeInstance@@QAEHMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?IsInHeight@CAttributeInstance@@QAEHMM@Z PROC		; CAttributeInstance::IsInHeight, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 124  : 	float fdx = m_matGlobal._41 - fx;

  0000a	f3 0f 10 4e 3c	 movss	 xmm1, DWORD PTR [esi+60]

; 125  : 	float fdy = m_matGlobal._42 - fy;

  0000f	f3 0f 10 46 40	 movss	 xmm0, DWORD PTR [esi+64]
  00014	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fy$[ebp]
  00019	f3 0f 5c 4d 08	 subss	 xmm1, DWORD PTR _fx$[ebp]

; 126  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  0001e	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00022	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00026	f3 0f 58 c1	 addss	 xmm0, xmm1
  0002a	0f 57 c9	 xorps	 xmm1, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	66 0f 2e c8	 ucomisd xmm1, xmm0
  00034	77 18		 ja	 SHORT $LN6@IsInHeight
  00036	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 126  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  0003a	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0003c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 126  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  00040	0f 2f 46 08	 comiss	 xmm0, DWORD PTR [esi+8]
  00044	0f 96 c0	 setbe	 al

; 127  : 		return FALSE;
; 128  : 
; 129  : 	return TRUE;
; 130  : }

  00047	5e		 pop	 esi
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN6@IsInHeight:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0004e	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00053	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 126  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  00057	33 c0		 xor	 eax, eax
  00059	0f 2f 46 08	 comiss	 xmm0, DWORD PTR [esi+8]

; 127  : 		return FALSE;
; 128  : 
; 129  : 	return TRUE;
; 130  : }

  0005d	5e		 pop	 esi
  0005e	0f 96 c0	 setbe	 al
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
?IsInHeight@CAttributeInstance@@QAEHMM@Z ENDP		; CAttributeInstance::IsInHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z
_TEXT	SEGMENT
tv3012 = -56						; size = 4
tv2973 = -52						; size = 4
tv2976 = -48						; size = 4
tv3072 = -44						; size = 4
tv3007 = -40						; size = 4
tv2972 = -40						; size = 4
tv3028 = -36						; size = 4
tv2975 = -32						; size = 4
_ny$1$ = -28						; size = 4
_nx$1$ = -24						; size = 4
tv3029 = -20						; size = 4
tv3025 = -16						; size = 4
tv3026 = -12						; size = 4
tv3024 = -8						; size = 4
_bPicked$1$ = -1					; size = 1
_v$ = 8							; size = 4
_dir$ = 12						; size = 4
_out_x$ = 16						; size = 4
_out_y$ = 20						; size = 4
?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z PROC ; CAttributeInstance::Picking, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 12   : 	if (IsEmpty())

  00009	e8 00 00 00 00	 call	 ?IsEmpty@CAttributeInstance@@QBEHXZ ; CAttributeInstance::IsEmpty
  0000e	85 c0		 test	 eax, eax
  00010	74 09		 je	 SHORT $LN8@Picking

; 13   : 		return FALSE;

  00012	32 c0		 xor	 al, al
  00014	5e		 pop	 esi

; 64   : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
$LN8@Picking:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0001b	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0001e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00023	57		 push	 edi
  00024	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	2b cf		 sub	 ecx, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 16   : 	bool bPicked = false;

  0002c	c6 45 ff 00	 mov	 BYTE PTR _bPicked$1$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00030	f7 e9		 imul	 ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 17   : 	float nx = 0;

  00032	f3 0f 11 45 e8	 movss	 DWORD PTR _nx$1$[ebp], xmm0

; 18   : 	float ny = 0;

  00037	f3 0f 11 45 e4	 movss	 DWORD PTR _ny$1$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0003c	d1 fa		 sar	 edx, 1
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00043	03 c2		 add	 eax, edx
  00045	89 45 d4	 mov	 DWORD PTR tv3072[ebp], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00048	0f 84 b5 03 00
	00		 je	 $LN106@Picking
  0004e	66 90		 npad	 2
$LL4@Picking:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00050	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00053	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00058	8b 37		 mov	 esi, DWORD PTR [edi]
  0005a	2b ce		 sub	 ecx, esi
  0005c	f7 e9		 imul	 ecx
  0005e	d1 fa		 sar	 edx, 1
  00060	8b ca		 mov	 ecx, edx
  00062	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00065	03 ca		 add	 ecx, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 21   : 		for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  00067	0f 84 62 03 00
	00		 je	 $LN2@Picking
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006d	49		 dec	 ecx
  0006e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00073	f7 e1		 mul	 ecx
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00078	83 c6 14	 add	 esi, 20			; 00000014H
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  0007e	d1 ea		 shr	 edx, 1
  00080	42		 inc	 edx
$LL7@Picking:
  00081	f3 0f 10 6e f0	 movss	 xmm5, DWORD PTR [esi-16]
  00086	f3 0f 10 66 f4	 movss	 xmm4, DWORD PTR [esi-12]
  0008b	f3 0f 10 76 08	 movss	 xmm6, DWORD PTR [esi+8]
  00090	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00094	f3 0f 5c f5	 subss	 xmm6, xmm5
  00098	f3 0f 10 46 ec	 movss	 xmm0, DWORD PTR [esi-20]
  0009d	f3 0f 10 7e 04	 movss	 xmm7, DWORD PTR [esi+4]
  000a2	f3 0f 10 5e f8	 movss	 xmm3, DWORD PTR [esi-8]
  000a7	f3 0f 5c f8	 subss	 xmm7, xmm0
  000ab	f3 0f 10 56 fc	 movss	 xmm2, DWORD PTR [esi-4]
  000b0	f3 0f 5c d8	 subss	 xmm3, xmm0
  000b4	f3 0f 11 45 d0	 movss	 DWORD PTR tv2976[ebp], xmm0
  000b9	f3 0f 5c d5	 subss	 xmm2, xmm5
  000bd	f3 0f 11 4d c8	 movss	 DWORD PTR tv3012[ebp], xmm1

; 182  :     z = fz;

  000c2	0f 28 c6	 movaps	 xmm0, xmm6

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000c5	f3 0f 5c cc	 subss	 xmm1, xmm4
  000c9	f3 0f 11 6d e0	 movss	 DWORD PTR tv2975[ebp], xmm5
  000ce	f3 0f 10 6e 0c	 movss	 xmm5, DWORD PTR [esi+12]
  000d3	f3 0f 5c ec	 subss	 xmm5, xmm4
  000d7	f3 0f 11 5d d8	 movss	 DWORD PTR tv3007[ebp], xmm3
  000dc	f3 0f 11 65 cc	 movss	 DWORD PTR tv2973[ebp], xmm4

; 182  :     z = fz;

  000e1	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000e5	f3 0f 11 45 f8	 movss	 DWORD PTR tv3024[ebp], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  000ea	0f 28 c5	 movaps	 xmm0, xmm5
  000ed	f3 0f 59 c2	 mulss	 xmm0, xmm2
  000f1	f3 0f 10 5d f8	 movss	 xmm3, DWORD PTR tv3024[ebp]
  000f6	f3 0f 5c d8	 subss	 xmm3, xmm0
  000fa	0f 28 c5	 movaps	 xmm0, xmm5
  000fd	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR tv3007[ebp]
  00102	f3 0f 11 45 f0	 movss	 DWORD PTR tv3025[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00107	0f 28 c7	 movaps	 xmm0, xmm7
  0010a	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0010e	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR tv3025[ebp]
  00113	f3 0f 11 5d f8	 movss	 DWORD PTR tv3024[ebp], xmm3
  00118	f3 0f 5c c8	 subss	 xmm1, xmm0
  0011c	0f 28 c7	 movaps	 xmm0, xmm7
  0011f	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00123	f3 0f 11 45 f4	 movss	 DWORD PTR tv3026[ebp], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00128	0f 28 c6	 movaps	 xmm0, xmm6
  0012b	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR tv3007[ebp]
  00130	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR tv3026[ebp]
  00135	f3 0f 11 4d f0	 movss	 DWORD PTR tv3025[ebp], xmm1
  0013a	f3 0f 5c d0	 subss	 xmm2, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0013e	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00143	f3 0f 5c 46 f0	 subss	 xmm0, DWORD PTR [esi-16]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00148	f3 0f 11 55 f4	 movss	 DWORD PTR tv3026[ebp], xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0014d	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  00151	f3 0f 5c 56 ec	 subss	 xmm2, DWORD PTR [esi-20]

; 182  :     z = fz;

  00156	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 31   : 			t = - D3DXVec3Dot(&(v-cv0),&n)/D3DXVec3Dot(&dir,&n);

  0015a	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0015f	f3 0f 59 d3	 mulss	 xmm2, xmm3
  00163	f3 0f 58 d0	 addss	 xmm2, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00167	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0016c	f3 0f 5c c4	 subss	 xmm0, xmm4

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00170	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR tv3026[ebp]
  00175	f3 0f 58 d0	 addss	 xmm2, xmm0
  00179	0f 28 c3	 movaps	 xmm0, xmm3
  0017c	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 31   : 			t = - D3DXVec3Dot(&(v-cv0),&n)/D3DXVec3Dot(&dir,&n);

  00180	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00187	f3 0f 58 c8	 addss	 xmm1, xmm0
  0018b	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv3026[ebp]
  00190	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00195	f3 0f 58 c8	 addss	 xmm1, xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00199	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 31   : 			t = - D3DXVec3Dot(&(v-cv0),&n)/D3DXVec3Dot(&dir,&n);

  0019e	f3 0f 5e d1	 divss	 xmm2, xmm1
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001a2	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  001a6	f3 0f 59 c2	 mulss	 xmm0, xmm2
  001aa	f3 0f 59 ca	 mulss	 xmm1, xmm2

; 180  :     x = fx;

  001ae	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 182  :     z = fz;

  001b3	f3 0f 58 09	 addss	 xmm1, DWORD PTR [ecx]

; 180  :     x = fx;

  001b7	f3 0f 11 45 ec	 movss	 DWORD PTR tv3029[ebp], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001bc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001c1	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001c5	0f 28 e1	 movaps	 xmm4, xmm1
  001c8	f3 0f 10 55 ec	 movss	 xmm2, DWORD PTR tv3029[ebp]
  001cd	f3 0f 5c 66 ec	 subss	 xmm4, DWORD PTR [esi-20]

; 181  :     y = fy;

  001d2	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001d7	f3 0f 5c 56 f0	 subss	 xmm2, DWORD PTR [esi-16]

; 182  :     z = fz;

  001dc	f3 0f 11 4d dc	 movss	 DWORD PTR tv3028[ebp], xmm1

; 181  :     y = fy;

  001e1	f3 0f 11 45 d8	 movss	 DWORD PTR tv2972[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001e6	0f 28 c8	 movaps	 xmm1, xmm0
  001e9	f3 0f 5c 4e f4	 subss	 xmm1, DWORD PTR [esi-12]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  001ee	0f 28 c7	 movaps	 xmm0, xmm7
  001f1	0f 28 dd	 movaps	 xmm3, xmm5
  001f4	f3 0f 59 dc	 mulss	 xmm3, xmm4
  001f8	f3 0f 59 ea	 mulss	 xmm5, xmm2
  001fc	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00200	f3 0f 59 fa	 mulss	 xmm7, xmm2
  00204	f3 0f 5c d8	 subss	 xmm3, xmm0

; 182  :     z = fz;

  00208	0f 28 c6	 movaps	 xmm0, xmm6
  0020b	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0020f	f3 0f 59 f4	 mulss	 xmm6, xmm4

; 1280 : 
; 1281 :     *pOut = v;

  00213	f3 0f 59 5d f0	 mulss	 xmm3, DWORD PTR tv3025[ebp]
  00218	f3 0f 5c c5	 subss	 xmm0, xmm5
  0021c	f3 0f 5c fe	 subss	 xmm7, xmm6

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00220	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR tv3024[ebp]
  00225	f3 0f 59 7d f4	 mulss	 xmm7, DWORD PTR tv3026[ebp]
  0022a	f3 0f 58 d8	 addss	 xmm3, xmm0
  0022e	0f 57 c0	 xorps	 xmm0, xmm0
  00231	f3 0f 58 df	 addss	 xmm3, xmm7
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 37   : 			if (D3DXVec3Dot(&temp,&n)<0) continue;

  00235	0f 2f c3	 comiss	 xmm0, xmm3
  00238	0f 87 85 01 00
	00		 ja	 $LN5@Picking
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0023e	f3 0f 10 6e f8	 movss	 xmm5, DWORD PTR [esi-8]
  00243	f3 0f 5c 6e 04	 subss	 xmm5, DWORD PTR [esi+4]
  00248	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  0024c	f3 0f 5c 4e 0c	 subss	 xmm1, DWORD PTR [esi+12]
  00251	f3 0f 10 7d dc	 movss	 xmm7, DWORD PTR tv3028[ebp]
  00256	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR tv2972[ebp]
  0025b	f3 0f 5c 7e 04	 subss	 xmm7, DWORD PTR [esi+4]
  00260	f3 0f 5c 56 0c	 subss	 xmm2, DWORD PTR [esi+12]
  00265	f3 0f 10 66 fc	 movss	 xmm4, DWORD PTR [esi-4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0026a	0f 28 c5	 movaps	 xmm0, xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0026d	f3 0f 5c 66 08	 subss	 xmm4, DWORD PTR [esi+8]
  00272	f3 0f 10 75 ec	 movss	 xmm6, DWORD PTR tv3029[ebp]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00277	0f 28 d9	 movaps	 xmm3, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0027a	f3 0f 5c 76 08	 subss	 xmm6, DWORD PTR [esi+8]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0027f	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00283	f3 0f 59 df	 mulss	 xmm3, xmm7
  00287	f3 0f 59 ce	 mulss	 xmm1, xmm6
  0028b	f3 0f 5c d8	 subss	 xmm3, xmm0
  0028f	f3 0f 59 ee	 mulss	 xmm5, xmm6

; 182  :     z = fz;

  00293	0f 28 c4	 movaps	 xmm0, xmm4

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00296	f3 0f 59 e7	 mulss	 xmm4, xmm7

; 182  :     z = fz;

  0029a	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 1281 :     *pOut = v;

  0029e	f3 0f 59 5d f0	 mulss	 xmm3, DWORD PTR tv3025[ebp]
  002a3	f3 0f 5c ec	 subss	 xmm5, xmm4
  002a7	f3 0f 5c c1	 subss	 xmm0, xmm1

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  002ab	f3 0f 59 6d f4	 mulss	 xmm5, DWORD PTR tv3026[ebp]
  002b0	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR tv3024[ebp]
  002b5	f3 0f 58 d8	 addss	 xmm3, xmm0
  002b9	0f 57 c0	 xorps	 xmm0, xmm0
  002bc	f3 0f 58 dd	 addss	 xmm3, xmm5
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 39   : 			if (D3DXVec3Dot(&temp,&n)<0) continue;

  002c0	0f 2f c3	 comiss	 xmm0, xmm3
  002c3	0f 87 fa 00 00
	00		 ja	 $LN5@Picking
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002c9	f3 0f 10 75 d8	 movss	 xmm6, DWORD PTR tv2972[ebp]
  002ce	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR tv2975[ebp]
  002d3	f3 0f 5c 46 fc	 subss	 xmm0, DWORD PTR [esi-4]
  002d8	f3 0f 5c 36	 subss	 xmm6, DWORD PTR [esi]
  002dc	f3 0f 10 65 cc	 movss	 xmm4, DWORD PTR tv2973[ebp]
  002e1	f3 0f 5c 65 c8	 subss	 xmm4, DWORD PTR tv3012[ebp]
  002e6	f3 0f 10 7d dc	 movss	 xmm7, DWORD PTR tv3028[ebp]
  002eb	f3 0f 10 55 ec	 movss	 xmm2, DWORD PTR tv3029[ebp]
  002f0	0f 28 df	 movaps	 xmm3, xmm7
  002f3	f3 0f 5c 56 fc	 subss	 xmm2, DWORD PTR [esi-4]
  002f8	f3 0f 10 6d d0	 movss	 xmm5, DWORD PTR tv2976[ebp]

; 182  :     z = fz;

  002fd	0f 28 ce	 movaps	 xmm1, xmm6

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00300	f3 0f 5c 6e f8	 subss	 xmm5, DWORD PTR [esi-8]
  00305	f3 0f 5c 5e f8	 subss	 xmm3, DWORD PTR [esi-8]

; 182  :     z = fz;

  0030a	f3 0f 59 c8	 mulss	 xmm1, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0030e	f3 0f 11 45 e0	 movss	 DWORD PTR tv2975[ebp], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00313	0f 28 c4	 movaps	 xmm0, xmm4
  00316	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0031a	f3 0f 59 f5	 mulss	 xmm6, xmm5
  0031e	f3 0f 5c c8	 subss	 xmm1, xmm0
  00322	f3 0f 59 e3	 mulss	 xmm4, xmm3

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00326	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR tv2975[ebp]
  0032b	f3 0f 59 ea	 mulss	 xmm5, xmm2
  0032f	f3 0f 5c e6	 subss	 xmm4, xmm6
  00333	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00337	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR tv3024[ebp]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0033c	f3 0f 5c e8	 subss	 xmm5, xmm0
  00340	0f 57 c0	 xorps	 xmm0, xmm0

; 1280 : 
; 1281 :     *pOut = v;

  00343	f3 0f 59 65 f0	 mulss	 xmm4, DWORD PTR tv3025[ebp]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00348	f3 0f 59 6d f4	 mulss	 xmm5, DWORD PTR tv3026[ebp]
  0034d	f3 0f 58 cc	 addss	 xmm1, xmm4
  00351	f3 0f 58 cd	 addss	 xmm1, xmm5
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 41   : 			if (D3DXVec3Dot(&temp,&n)<0) continue;

  00355	0f 2f c1	 comiss	 xmm0, xmm1
  00358	77 69		 ja	 SHORT $LN5@Picking

; 42   : 
; 43   : 			if (bPicked)

  0035a	80 7d ff 00	 cmp	 BYTE PTR _bPicked$1$[ebp], 0
  0035e	74 4d		 je	 SHORT $LN12@Picking

; 44   : 			{
; 45   : 				if ((v.x-x.x)*(v.x-x.x)+(v.y-x.y)*(v.y-x.y)<(v.x-nx)*(v.x-nx)+(v.y-ny)*(v.y-ny))

  00360	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  00364	f3 0f 10 59 04	 movss	 xmm3, DWORD PTR [ecx+4]
  00369	f3 0f 5c d7	 subss	 xmm2, xmm7
  0036d	f3 0f 10 65 ec	 movss	 xmm4, DWORD PTR tv3029[ebp]
  00372	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00376	f3 0f 5c dc	 subss	 xmm3, xmm4
  0037a	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0037f	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _ny$1$[ebp]
  00384	f3 0f 5c 4d e8	 subss	 xmm1, DWORD PTR _nx$1$[ebp]
  00389	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0038d	f3 0f 59 db	 mulss	 xmm3, xmm3
  00391	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00395	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00399	f3 0f 58 da	 addss	 xmm3, xmm2
  0039d	f3 0f 58 c1	 addss	 xmm0, xmm1
  003a1	0f 2f c3	 comiss	 xmm0, xmm3
  003a4	76 16		 jbe	 SHORT $LN13@Picking

; 46   : 				{
; 47   : 					nx=x.x;
; 48   : 					ny=x.y;

  003a6	f3 0f 11 65 e4	 movss	 DWORD PTR _ny$1$[ebp], xmm4

; 49   : 				}
; 50   : 			}

  003ab	eb 0a		 jmp	 SHORT $LN107@Picking
$LN12@Picking:

; 51   : 			else
; 52   : 			{
; 53   : 				nx = x.x;
; 54   : 				ny = x.y;

  003ad	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR tv3029[ebp]
  003b2	f3 0f 11 45 e4	 movss	 DWORD PTR _ny$1$[ebp], xmm0
$LN107@Picking:

; 55   : 			}
; 56   : 			bPicked = true;

  003b7	f3 0f 11 7d e8	 movss	 DWORD PTR _nx$1$[ebp], xmm7
$LN13@Picking:
  003bc	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  003bf	c6 45 ff 01	 mov	 BYTE PTR _bPicked$1$[ebp], 1
$LN5@Picking:

; 21   : 		for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  003c3	83 c6 24	 add	 esi, 36			; 00000024H
  003c6	83 ea 01	 sub	 edx, 1
  003c9	0f 85 b2 fc ff
	ff		 jne	 $LL7@Picking
$LN2@Picking:

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  003cf	83 c7 0c	 add	 edi, 12			; 0000000cH
  003d2	83 6d d4 01	 sub	 DWORD PTR tv3072[ebp], 1
  003d6	0f 85 74 fc ff
	ff		 jne	 $LL4@Picking

; 57   : 	}
; 58   : 	if (bPicked)

  003dc	8a 45 ff	 mov	 al, BYTE PTR _bPicked$1$[ebp]
  003df	84 c0		 test	 al, al
  003e1	74 23		 je	 SHORT $LN15@Picking

; 59   : 	{
; 60   : 		out_x = nx;

  003e3	8b 4d 10	 mov	 ecx, DWORD PTR _out_x$[ebp]
  003e6	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _nx$1$[ebp]

; 61   : 		out_y = ny;
; 62   : 	}
; 63   : 	return bPicked;

  003eb	5f		 pop	 edi
  003ec	5e		 pop	 esi
  003ed	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  003f1	8b 4d 14	 mov	 ecx, DWORD PTR _out_y$[ebp]
  003f4	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _ny$1$[ebp]
  003f9	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 64   : }

  003fd	8b e5		 mov	 esp, ebp
  003ff	5d		 pop	 ebp
  00400	c2 10 00	 ret	 16			; 00000010H
$LN106@Picking:

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00403	8a 45 ff	 mov	 al, BYTE PTR _bPicked$1$[ebp]
$LN15@Picking:

; 61   : 		out_y = ny;
; 62   : 	}
; 63   : 	return bPicked;

  00406	5f		 pop	 edi
  00407	5e		 pop	 esi

; 64   : }

  00408	8b e5		 mov	 esp, ebp
  0040a	5d		 pop	 ebp
  0040b	c2 10 00	 ret	 16			; 00000010H
?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z ENDP ; CAttributeInstance::Picking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ
_TEXT	SEGMENT
?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ PROC ; CAttributeInstance::GetObjectPointer, COMDAT
; _this$ = ecx

; 120  : 	return m_roAttributeData.GetPointer();

  00000	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]

; 121  : }

  00003	c3		 ret	 0
?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ENDP ; CAttributeInstance::GetObjectPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_dwHeightDataCount$1$ = -20				; size = 4
tv487 = -16						; size = 4
_i$1$ = -16						; size = 4
_c_pHeightData$1 = -12					; size = 4
_this$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Oldsize$1$ = 8					; size = 4
__Oldlast$1$ = 8					; size = 4
_c_rmatGlobal$ = 8					; size = 4
$T2 = 11						; size = 1
$T3 = 11						; size = 1
?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z PROC ; CAttributeInstance::RefreshObject, COMDAT
; _this$ = ecx

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 140  : 	assert(!m_roAttributeData.IsNull());
; 141  : 
; 142  : 	m_matGlobal = c_rmatGlobal;

  00006	8b 45 08	 mov	 eax, DWORD PTR _c_rmatGlobal$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	57		 push	 edi
  00011	89 75 f8	 mov	 DWORD PTR _this$1$[ebp], esi

; 143  : 
; 144  : 	// Height
; 145  : 	m_fHeightRadius = m_roAttributeData->GetMaximizeRadius();

  00014	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00017	0f 11 46 0c	 movups	 XMMWORD PTR [esi+12], xmm0
  0001b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0001f	0f 11 46 1c	 movups	 XMMWORD PTR [esi+28], xmm0
  00023	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [eax+32]
  00027	0f 11 46 2c	 movups	 XMMWORD PTR [esi+44], xmm0
  0002b	0f 10 40 30	 movups	 xmm0, XMMWORD PTR [eax+48]
  0002f	0f 11 46 3c	 movups	 XMMWORD PTR [esi+60], xmm0
  00033	e8 00 00 00 00	 call	 ?GetMaximizeRadius@CAttributeData@@QAEMXZ ; CAttributeData::GetMaximizeRadius

; 147  : 	DWORD dwHeightDataCount = m_roAttributeData->GetHeightDataCount();

  00038	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0003b	d9 5e 08	 fstp	 DWORD PTR [esi+8]
  0003e	e8 00 00 00 00	 call	 ?GetHeightDataCount@CAttributeData@@QBEKXZ ; CAttributeData::GetHeightDataCount

; 148  : 	m_v3HeightDataVector.clear();

  00043	83 c6 4c	 add	 esi, 76			; 0000004cH
  00046	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00048	56		 push	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 147  : 	DWORD dwHeightDataCount = m_roAttributeData->GetHeightDataCount();

  00049	89 5d ec	 mov	 DWORD PTR _dwHeightDataCount$1$[ebp], ebx

; 148  : 	m_v3HeightDataVector.clear();

  0004c	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004f	ff 76 04	 push	 DWORD PTR [esi+4]
  00052	ff 36		 push	 DWORD PTR [esi]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1390 :         _Mylast = _Myfirst;

  00059	8b 06		 mov	 eax, DWORD PTR [esi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0005e	8b c8		 mov	 ecx, eax

; 1390 :         _Mylast = _Myfirst;

  00060	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00063	2b 0e		 sub	 ecx, DWORD PTR [esi]

; 1390 :         _Mylast = _Myfirst;

  00065	89 45 08	 mov	 DWORD PTR __Oldlast$1$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00068	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0006d	f7 e9		 imul	 ecx
  0006f	d1 fa		 sar	 edx, 1
  00071	8b fa		 mov	 edi, edx
  00073	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00076	03 fa		 add	 edi, edx

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00078	3b df		 cmp	 ebx, edi
  0007a	73 1f		 jae	 SHORT $LN17@RefreshObj

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  0007c	8b 16		 mov	 edx, DWORD PTR [esi]
  0007e	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00081	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00084	53		 push	 ebx
  00085	ff 75 08	 push	 DWORD PTR __Oldlast$1$[ebp]

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00088	8d 34 82	 lea	 esi, DWORD PTR [edx+eax*4]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0008b	56		 push	 esi
  0008c	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1220 :             _Mylast = _Newlast;

  00091	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 1221 :             return;

  00094	8b f3		 mov	 esi, ebx
  00096	8b 5d ec	 mov	 ebx, DWORD PTR _dwHeightDataCount$1$[ebp]
  00099	eb 3a		 jmp	 SHORT $LN54@RefreshObj
$LN17@RefreshObj:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  0009b	76 3b		 jbe	 SHORT $LN18@RefreshObj

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0009d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a0	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000a5	2b 0e		 sub	 ecx, DWORD PTR [esi]
  000a7	f7 e9		 imul	 ecx
  000a9	d1 fa		 sar	 edx, 1
  000ab	8b c2		 mov	 eax, edx
  000ad	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000b0	03 c2		 add	 eax, edx

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  000b2	3b d8		 cmp	 ebx, eax
  000b4	76 0e		 jbe	 SHORT $LN19@RefreshObj

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  000b6	8d 45 0b	 lea	 eax, DWORD PTR $T3[ebp]
  000b9	8b ce		 mov	 ecx, esi
  000bb	50		 push	 eax
  000bc	53		 push	 ebx
  000bd	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000c2	eb 14		 jmp	 SHORT $LN18@RefreshObj
$LN19@RefreshObj:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;
; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c4	8b c3		 mov	 eax, ebx

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c6	56		 push	 esi

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c7	2b c7		 sub	 eax, edi

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c9	50		 push	 eax
  000ca	ff 75 08	 push	 DWORD PTR __Oldlast$1$[ebp]
  000cd	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d2	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN54@RefreshObj:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 150  : 	for (DWORD i = 0; i < dwHeightDataCount; ++i)

  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@RefreshObj:
  000d8	33 c0		 xor	 eax, eax
  000da	89 45 f0	 mov	 DWORD PTR _i$1$[ebp], eax
  000dd	85 db		 test	 ebx, ebx
  000df	0f 84 e7 00 00
	00		 je	 $LN3@RefreshObj
  000e5	33 db		 xor	 ebx, ebx
$LL4@RefreshObj:

; 151  : 	{
; 152  : 		const THeightData * c_pHeightData;
; 153  : 		if (!m_roAttributeData->GetHeightDataPointer(i, &c_pHeightData))

  000e7	8d 4d f4	 lea	 ecx, DWORD PTR _c_pHeightData$1[ebp]
  000ea	51		 push	 ecx
  000eb	50		 push	 eax
  000ec	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  000ef	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  000f2	e8 00 00 00 00	 call	 ?GetHeightDataPointer@CAttributeData@@QBEHKPAPBUSHeightData@@@Z ; CAttributeData::GetHeightDataPointer
  000f7	85 c0		 test	 eax, eax
  000f9	0f 84 b7 00 00
	00		 je	 $LN2@RefreshObj
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  000ff	8b 45 f4	 mov	 eax, DWORD PTR _c_pHeightData$1[ebp]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00102	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00105	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  00108	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0010d	f7 e9		 imul	 ecx

; 1504 :         return _My_data._Myfirst[_Pos];

  0010f	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00111	d1 fa		 sar	 edx, 1
  00113	8b fa		 mov	 edi, edx
  00115	c1 ef 1f	 shr	 edi, 31			; 0000001fH
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 157  : 		m_v3HeightDataVector[i].clear();

  00118	8b 04 19	 mov	 eax, DWORD PTR [ecx+ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0011b	03 fa		 add	 edi, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 157  : 		m_v3HeightDataVector[i].clear();

  0011d	89 44 19 04	 mov	 DWORD PTR [ecx+ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00121	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH

; 1504 :         return _My_data._Myfirst[_Pos];

  00126	8b 36		 mov	 esi, DWORD PTR [esi]
  00128	03 f3		 add	 esi, ebx

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0012a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0012d	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0012f	f7 e9		 imul	 ecx
  00131	d1 fa		 sar	 edx, 1
  00133	8b c2		 mov	 eax, edx
  00135	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00138	03 c2		 add	 eax, edx
  0013a	89 45 08	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  0013d	3b f8		 cmp	 edi, eax
  0013f	73 0a		 jae	 SHORT $LN34@RefreshObj

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00141	8b 16		 mov	 edx, DWORD PTR [esi]
  00143	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00146	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1221 :             return;

  00149	eb 3b		 jmp	 SHORT $LN55@RefreshObj
$LN34@RefreshObj:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  0014b	76 3c		 jbe	 SHORT $LN35@RefreshObj

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0014d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00150	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00155	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00157	f7 e9		 imul	 ecx
  00159	d1 fa		 sar	 edx, 1
  0015b	8b c2		 mov	 eax, edx
  0015d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00160	03 c2		 add	 eax, edx

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00162	3b f8		 cmp	 edi, eax
  00164	76 0e		 jbe	 SHORT $LN36@RefreshObj

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00166	8d 45 0b	 lea	 eax, DWORD PTR $T2[ebp]
  00169	8b ce		 mov	 ecx, esi
  0016b	50		 push	 eax
  0016c	57		 push	 edi
  0016d	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  00172	eb 15		 jmp	 SHORT $LN35@RefreshObj
$LN36@RefreshObj:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;
; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00174	8b c7		 mov	 eax, edi
  00176	2b 45 08	 sub	 eax, DWORD PTR __Oldsize$1$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00179	56		 push	 esi
  0017a	50		 push	 eax
  0017b	ff 76 04	 push	 DWORD PTR [esi+4]
  0017e	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >
  00183	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN55@RefreshObj:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 159  : 		for (DWORD j = 0; j < dwVertexCount; ++j)

  00186	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN35@RefreshObj:
  00189	85 ff		 test	 edi, edi
  0018b	74 29		 je	 SHORT $LN2@RefreshObj
  0018d	33 f6		 xor	 esi, esi
  0018f	90		 npad	 1
$LL7@RefreshObj:

; 161  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  00190	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00193	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00196	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  00197	8b 45 f4	 mov	 eax, DWORD PTR _c_pHeightData$1[ebp]
  0019a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0019d	03 c6		 add	 eax, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 161  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  0019f	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  001a0	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  001a3	8b 04 03	 mov	 eax, DWORD PTR [ebx+eax]
  001a6	03 c6		 add	 eax, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 161  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
  001ae	83 c6 0c	 add	 esi, 12			; 0000000cH
  001b1	83 ef 01	 sub	 edi, 1
  001b4	75 da		 jne	 SHORT $LL7@RefreshObj
$LN2@RefreshObj:

; 150  : 	for (DWORD i = 0; i < dwHeightDataCount; ++i)

  001b6	8b 45 f0	 mov	 eax, DWORD PTR _i$1$[ebp]
  001b9	83 c3 0c	 add	 ebx, 12			; 0000000cH
  001bc	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  001bf	40		 inc	 eax
  001c0	89 45 f0	 mov	 DWORD PTR _i$1$[ebp], eax
  001c3	3b 45 ec	 cmp	 eax, DWORD PTR _dwHeightDataCount$1$[ebp]
  001c6	0f 82 1b ff ff
	ff		 jb	 $LL4@RefreshObj
$LN3@RefreshObj:
  001cc	5f		 pop	 edi

; 162  : 		}
; 163  : 	}
; 164  : }

  001cd	5e		 pop	 esi
  001ce	5b		 pop	 ebx
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c2 04 00	 ret	 4
?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ENDP ; CAttributeInstance::RefreshObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z
_TEXT	SEGMENT
_pAttributeData$ = 8					; size = 4
?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z PROC ; CAttributeInstance::SetObjectPointer, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 134  : 	Clear();

  00007	e8 00 00 00 00	 call	 ?Clear@CAttributeInstance@@QAEXXZ ; CAttributeInstance::Clear
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h

; 69   : 			m_pObject = pObject;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pAttributeData$[ebp]
  0000f	8b 7e 58	 mov	 edi, DWORD PTR [esi+88]
  00012	89 4e 58	 mov	 DWORD PTR [esi+88], ecx

; 70   : 
; 71   : 			if (m_pObject)

  00015	85 c9		 test	 ecx, ecx
  00017	74 05		 je	 SHORT $LN4@SetObjectP

; 72   : 				m_pObject->AddReference();

  00019	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN4@SetObjectP:

; 73   : 
; 74   : 			if (pOldObject)

  0001e	85 ff		 test	 edi, edi
  00020	74 07		 je	 SHORT $LN5@SetObjectP

; 75   : 				pOldObject->Release();

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN5@SetObjectP:
  00029	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 136  : }

  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z ENDP ; CAttributeInstance::SetObjectPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetDataFileName@CAttributeInstance@@QBEPBDXZ
_TEXT	SEGMENT
?GetDataFileName@CAttributeInstance@@QBEPBDXZ PROC	; CAttributeInstance::GetDataFileName, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 3668 :         return _Mypair._Myval2._Myptr();

  00000	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00003	83 c0 0c	 add	 eax, 12			; 0000000cH

; 2153 :         return _BUF_SIZE <= _Myres;

  00006	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2145 :         if (_Large_string_engaged()) {

  0000a	72 02		 jb	 SHORT $LN8@GetDataFil
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 168  : 	return m_roAttributeData->GetFileName();

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN8@GetDataFil:

; 169  : }

  0000e	c3		 ret	 0
?GetDataFileName@CAttributeInstance@@QBEPBDXZ ENDP	; CAttributeInstance::GetDataFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?IsEmpty@CAttributeInstance@@QBEHXZ
_TEXT	SEGMENT
?IsEmpty@CAttributeInstance@@QBEHXZ PROC		; CAttributeInstance::IsEmpty, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00000	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 193  : 	if (!m_v3HeightDataVector.empty())

  00003	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00005	3b 51 50	 cmp	 edx, DWORD PTR [ecx+80]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 193  : 	if (!m_v3HeightDataVector.empty())

  00008	0f 94 c0	 sete	 al

; 194  : 		return FALSE;
; 195  : 
; 196  : 	return TRUE;
; 197  : }

  0000b	c3		 ret	 0
?IsEmpty@CAttributeInstance@@QBEHXZ ENDP		; CAttributeInstance::IsEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Clear@CAttributeInstance@@QAEXXZ
_TEXT	SEGMENT
?Clear@CAttributeInstance@@QAEXXZ PROC			; CAttributeInstance::Clear, COMDAT
; _this$ = ecx

; 200  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 203  : 	D3DXMatrixIdentity(&m_matGlobal);
; 204  : 
; 205  : 	m_v3HeightDataVector.clear();

  00004	8d 77 4c	 lea	 esi, DWORD PTR [edi+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00007	56		 push	 esi
  00008	ff 76 04	 push	 DWORD PTR [esi+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 201  : 	m_fHeightRadius = 0.0f;

  0000b	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00012	ff 36		 push	 DWORD PTR [esi]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 202  : 	m_fCollisionRadius = 0.0f;

  00014	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0001b	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  00022	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], 0
  00029	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
  00030	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  00037	c7 47 30 00 00
	00 00		 mov	 DWORD PTR [edi+48], 0
  0003e	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0
  00045	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  0004c	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
  00053	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0
  0005a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  00061	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  00068	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0006f	c7 47 48 00 00
	80 3f		 mov	 DWORD PTR [edi+72], 1065353216 ; 3f800000H
  00076	c7 47 34 00 00
	80 3f		 mov	 DWORD PTR [edi+52], 1065353216 ; 3f800000H
  0007d	c7 47 20 00 00
	80 3f		 mov	 DWORD PTR [edi+32], 1065353216 ; 3f800000H
  00084	c7 47 0c 00 00
	80 3f		 mov	 DWORD PTR [edi+12], 1065353216 ; 3f800000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0008b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1390 :         _Mylast = _Myfirst;

  00090	8b 06		 mov	 eax, DWORD PTR [esi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  00095	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00098	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]

; 68   : 
; 69   : 			m_pObject = pObject;

  0009b	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi

; 70   : 
; 71   : 			if (m_pObject)
; 72   : 				m_pObject->AddReference();
; 73   : 
; 74   : 			if (pOldObject)

  000a4	85 c9		 test	 ecx, ecx
  000a6	0f 85 00 00 00
	00		 jne	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 208  : }

  000ac	c3		 ret	 0
?Clear@CAttributeInstance@@QAEXXZ ENDP			; CAttributeInstance::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ??1CAttributeInstance@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAttributeInstance@@UAE@XZ PROC			; CAttributeInstance::~CAttributeInstance, COMDAT
; _this$ = ecx

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAttributeInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CAttributeInstance@@6B@
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h

; 53   : 			if (m_pObject)

  0002c	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]

; 37   : 		{

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 			if (m_pObject)

  00036	85 c9		 test	 ecx, ecx
  00038	74 0c		 je	 SHORT $LN7@CAttribute

; 54   : 			{
; 55   : 				m_pObject->Release();

  0003a	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0003f	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
$LN7@CAttribute:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00046	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 215  : }

  00049	8d 7e 4c	 lea	 edi, DWORD PTR [esi+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0004c	85 c0		 test	 eax, eax
  0004e	74 45		 je	 SHORT $LN12@CAttribute

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00050	57		 push	 edi
  00051	ff 77 04	 push	 DWORD PTR [edi+4]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005a	8b 37		 mov	 esi, DWORD PTR [edi]
  0005c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00061	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00064	2b ce		 sub	 ecx, esi
  00066	f7 e9		 imul	 ecx
  00068	d1 fa		 sar	 edx, 1
  0006a	8b c2		 mov	 eax, edx
  0006c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0006f	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00071	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00074	c1 e0 02	 shl	 eax, 2
  00077	50		 push	 eax
  00078	56		 push	 esi
  00079	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0007e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00084	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00087	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  0008e	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN12@CAttribute:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 215  : }

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
  000a9	cc		 int	 3
  000aa	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAttributeInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAttributeInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAttributeInstance@@UAE@XZ ENDP			; CAttributeInstance::~CAttributeInstance
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp
;	COMDAT ??0CAttributeInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAttributeInstance@@QAE@XZ PROC			; CAttributeInstance::CAttributeInstance, COMDAT
; _this$ = ecx

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CAttributeInstance@@6B@

; 212  : }

  0000a	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000c	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0
  00013	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0
  0001a	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 211  : {

  00021	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\Ref.h

; 20   : 		CRef() : m_pObject(NULL)

  00024	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\AttributeInstance.cpp

; 212  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0CAttributeInstance@@QAE@XZ ENDP			; CAttributeInstance::CAttributeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
