; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	?jpeg_save@@YAHPAEHHHPBD@Z			; jpeg_save
PUBLIC	?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z	; jpeg_save_to_file
PUBLIC	?jpeg_save_to_mem@@YAHPAEHHH0H@Z		; jpeg_save_to_mem
PUBLIC	?jpeg_load@@YAHPBDPAPAEPAH2@Z			; jpeg_load
PUBLIC	?jpeg_load_from_mem@@YAHPAEH0HH@Z		; jpeg_load_from_mem
PUBLIC	?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_init_source
PUBLIC	?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ; mem_fill_input_buffer
PUBLIC	?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ; mem_skip_input_data
PUBLIC	?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ; mem_resync_to_restart
PUBLIC	?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_term_source
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_06GLDDLHNF@malloc@			; `string'
PUBLIC	??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@	; `string'
PUBLIC	??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@	; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_08CJBHLKCB@fill?5?$CFd?6@			; `string'
PUBLIC	??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@	; `string'
PUBLIC	??_C@_0L@MJDMKOIM@resync?5?$CFd?6@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@ ; `string'
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_exit:PROC
EXTRN	_perror:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	_jpeg_std_error:PROC
EXTRN	_jpeg_CreateCompress:PROC
EXTRN	_jpeg_CreateDecompress:PROC
EXTRN	_jpeg_destroy_compress:PROC
EXTRN	_jpeg_destroy_decompress:PROC
EXTRN	_jpeg_stdio_src:PROC
EXTRN	_jpeg_set_defaults:PROC
EXTRN	_jpeg_set_quality:PROC
EXTRN	_jpeg_start_compress:PROC
EXTRN	_jpeg_write_scanlines:PROC
EXTRN	_jpeg_finish_compress:PROC
EXTRN	_jpeg_read_header:PROC
EXTRN	_jpeg_start_decompress:PROC
EXTRN	_jpeg_read_scanlines:PROC
EXTRN	_jpeg_finish_decompress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?fi@@3PAU_iobuf@@A DD 01H DUP (?)			; fi
?buffer@@3PAEA DD 01H DUP (?)				; buffer
?dest@@3PAEA DD	01H DUP (?)				; dest
?len@@3HA DD	01H DUP (?)				; len
?destlen@@3HA DD 01H DUP (?)				; destlen
?dataX@@3PAEA DD 01H DUP (?)				; dataX
?sizeX@@3HA DD	01H DUP (?)				; sizeX
_BSS	ENDS
;	COMDAT ??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@
CONST	SEGMENT
??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@ DB 'Error: Can'
	DB	'''t convert YCCK to RGB.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@ DB 'Couldn''t open fil'
	DB	'e %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MJDMKOIM@resync?5?$CFd?6@
CONST	SEGMENT
??_C@_0L@MJDMKOIM@resync?5?$CFd?6@ DB 'resync %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@
CONST	SEGMENT
??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@ DB 'skip %d +%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CJBHLKCB@fill?5?$CFd?6@
CONST	SEGMENT
??_C@_08CJBHLKCB@fill?5?$CFd?6@ DB 'fill %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@
CONST	SEGMENT
??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@ DB 'jpeg mem overflow!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@
CONST	SEGMENT
??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@ DB 'Out of memory!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLDDLHNF@malloc@
CONST	SEGMENT
??_C@_06GLDDLHNF@malloc@ DB 'malloc', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z PROC	; mem_term_source, COMDAT

; 249  :     struct jpeg_source_mgr* mgr = cinfo->src;
; 250  :     //printf("term %d\n", size - mgr->bytes_in_buffer);
; 251  : }

  00000	c2 00 00	 ret	 0
?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ENDP	; mem_term_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
_desired$ = 12						; size = 4
?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z PROC ; mem_resync_to_restart, COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 240  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 241  :     printf("resync %d\n", sizeX - mgr->bytes_in_buffer);

  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sizeX@@3HA
  0000f	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MJDMKOIM@resync?5?$CFd?6@
  00018	e8 00 00 00 00	 call	 _printf

; 242  :     mgr->next_input_byte = dataX;

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dataX@@3PAEA
  00022	83 c4 08	 add	 esp, 8
  00025	89 06		 mov	 DWORD PTR [esi], eax

; 243  :     mgr->bytes_in_buffer = sizeX;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sizeX@@3HA
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 244  :     return 1;

  0002f	b0 01		 mov	 al, 1
  00031	5e		 pop	 esi

; 245  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ENDP ; mem_resync_to_restart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
_num_bytes$ = 12					; size = 4
?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z PROC ; mem_skip_input_data, COMDAT

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 230  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi

; 231  :     printf("skip %d +%d\n", sizeX - mgr->bytes_in_buffer, num_bytes);

  00008	8b 7d 0c	 mov	 edi, DWORD PTR _num_bytes$[ebp]
  0000b	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sizeX@@3HA
  00013	57		 push	 edi
  00014	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@
  0001d	e8 00 00 00 00	 call	 _printf
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  :     if(num_bytes<=0)

  00025	85 ff		 test	 edi, edi
  00027	7e 05		 jle	 SHORT $LN1@mem_skip_i

; 233  : 	return;
; 234  :     mgr->next_input_byte += num_bytes;

  00029	01 3e		 add	 DWORD PTR [esi], edi

; 235  :     mgr->bytes_in_buffer -= num_bytes;

  0002b	29 7e 04	 sub	 DWORD PTR [esi+4], edi
$LN1@mem_skip_i:

; 236  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ENDP ; mem_skip_input_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z PROC ; mem_fill_input_buffer, COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  :     struct jpeg_source_mgr* mgr = cinfo->src;
; 224  :     printf("fill %d\n", sizeX - mgr->bytes_in_buffer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sizeX@@3HA
  0000c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_08CJBHLKCB@fill?5?$CFd?6@
  00018	e8 00 00 00 00	 call	 _printf
  0001d	83 c4 08	 add	 esp, 8

; 225  :     return 0;

  00020	32 c0		 xor	 al, al

; 226  : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ENDP ; mem_fill_input_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z PROC	; mem_init_source, COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 215  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 216  :     mgr->next_input_byte = dataX;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dataX@@3PAEA
  0000e	89 01		 mov	 DWORD PTR [ecx], eax

; 217  :     mgr->bytes_in_buffer = sizeX;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sizeX@@3HA
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 218  :     //printf("init %d\n", size - mgr->bytes_in_buffer);
; 219  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ENDP	; mem_init_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; mem_term_destination, COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :   struct jpeg_destination_mgr*dmgr =

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 73   :       (struct jpeg_destination_mgr*)(cinfo->dest);
; 74   :   len = destlen - dmgr->free_in_buffer;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?destlen@@3HA
  0000e	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?len@@3HA, eax

; 75   :   dmgr->free_in_buffer = 0;

  00016	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 76   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; mem_term_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z PROC ; mem_empty_output_buffer, COMDAT

; 66   :     printf("jpeg mem overflow!\n");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@
  00005	e8 00 00 00 00	 call	 _printf
  0000a	83 c4 04	 add	 esp, 4

; 67   :     exit(1);

  0000d	6a 01		 push	 1
  0000f	e8 00 00 00 00	 call	 _exit
$LN3@mem_empty_:
  00014	cc		 int	 3
?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ENDP ; mem_empty_output_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; mem_init_destination, COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   :   struct jpeg_destination_mgr*dmgr =

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 59   :       (struct jpeg_destination_mgr*)(cinfo->dest);
; 60   :   dmgr->next_output_byte = dest;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dest@@3PAEA
  0000e	89 01		 mov	 DWORD PTR [ecx], eax

; 61   :   dmgr->free_in_buffer = destlen;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?destlen@@3HA
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; mem_init_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; file_term_destination, COMDAT

; 47   : { struct jpeg_destination_mgr*dmgr =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 48   :       (struct jpeg_destination_mgr*)(cinfo->dest);
; 49   :   if(fi)

  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?fi@@3PAU_iobuf@@A
  0000f	85 c0		 test	 eax, eax
  00011	74 1a		 je	 SHORT $LN2@file_term_

; 50   :     fwrite(buffer, OUTBUFFER_SIZE-dmgr->free_in_buffer, 1, fi);

  00013	50		 push	 eax
  00014	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00019	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  0001c	6a 01		 push	 1
  0001e	50		 push	 eax
  0001f	ff 35 00 00 00
	00		 push	 DWORD PTR ?buffer@@3PAEA
  00025	e8 00 00 00 00	 call	 _fwrite
  0002a	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@file_term_:

; 51   :   free(buffer);

  0002d	ff 35 00 00 00
	00		 push	 DWORD PTR ?buffer@@3PAEA
  00033	e8 00 00 00 00	 call	 _free
  00038	83 c4 04	 add	 esp, 4

; 52   :   buffer = 0;
; 53   :   dmgr->free_in_buffer = 0;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00042	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?buffer@@3PAEA, 0
  0004c	5e		 pop	 esi

; 54   : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; file_term_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z PROC ; file_empty_output_buffer, COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   :   struct jpeg_destination_mgr*dmgr =

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 38   :       (struct jpeg_destination_mgr*)(cinfo->dest);
; 39   :   if(fi)

  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?fi@@3PAU_iobuf@@A
  0000f	85 c0		 test	 eax, eax
  00011	74 16		 je	 SHORT $LN2@file_empty

; 40   :     fwrite(buffer, OUTBUFFER_SIZE, 1, fi);

  00013	50		 push	 eax
  00014	6a 01		 push	 1
  00016	68 00 80 00 00	 push	 32768			; 00008000H
  0001b	ff 35 00 00 00
	00		 push	 DWORD PTR ?buffer@@3PAEA
  00021	e8 00 00 00 00	 call	 _fwrite
  00026	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@file_empty:

; 41   :   dmgr->next_output_byte = buffer;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?buffer@@3PAEA
  0002e	89 06		 mov	 DWORD PTR [esi], eax

; 42   :   dmgr->free_in_buffer = OUTBUFFER_SIZE;
; 43   :   return 1;

  00030	b0 01		 mov	 al, 1
  00032	c7 46 04 00 80
	00 00		 mov	 DWORD PTR [esi+4], 32768 ; 00008000H
  00039	5e		 pop	 esi

; 44   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ENDP ; file_empty_output_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; file_init_destination, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :   struct jpeg_destination_mgr*dmgr =

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi

; 24   :       (struct jpeg_destination_mgr*)(cinfo->dest);
; 25   :   buffer = (JOCTET*)malloc(OUTBUFFER_SIZE);

  00007	68 00 80 00 00	 push	 32768			; 00008000H
  0000c	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0000f	e8 00 00 00 00	 call	 _malloc
  00014	83 c4 04	 add	 esp, 4
  00017	a3 00 00 00 00	 mov	 DWORD PTR ?buffer@@3PAEA, eax

; 26   :   if(!buffer) {

  0001c	85 c0		 test	 eax, eax
  0001e	74 0c		 je	 SHORT $LN6@file_init_

; 30   :   }
; 31   :   dmgr->next_output_byte = buffer;

  00020	89 06		 mov	 DWORD PTR [esi], eax

; 32   :   dmgr->free_in_buffer = OUTBUFFER_SIZE;

  00022	c7 46 04 00 80
	00 00		 mov	 DWORD PTR [esi+4], 32768 ; 00008000H
  00029	5e		 pop	 esi

; 33   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN6@file_init_:

; 27   :       perror("malloc");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_06GLDDLHNF@malloc@
  00031	e8 00 00 00 00	 call	 _perror

; 28   :       printf("Out of memory!\n");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@
  0003b	e8 00 00 00 00	 call	 _printf
  00040	83 c4 08	 add	 esp, 8

; 29   :       exit(1);

  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 _exit
$LN4@file_init_:
  0004a	cc		 int	 3
?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; file_init_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_load_from_mem@@YAHPAEH0HH@Z
_TEXT	SEGMENT
_mgr$ = -624						; size = 28
_j$1 = -596						; size = 4
_cinfo$ = -592						; size = 456
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
__data$ = 8						; size = 4
__size$ = 12						; size = 4
_dest$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?jpeg_load_from_mem@@YAHPAEH0HH@Z PROC			; jpeg_load_from_mem, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 02 00
	00		 sub	 esp, 624		; 00000270H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR __data$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 14	 mov	 ebx, DWORD PTR _width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _dest$[ebp]
  0001e	57		 push	 edi

; 255  :     struct jpeg_decompress_struct cinfo;
; 256  :     struct jpeg_error_mgr jerr;
; 257  :     struct jpeg_source_mgr mgr;
; 258  :     int y;
; 259  : 	//int x;
; 260  : 
; 261  :     dataX = _data;

  0001f	a3 00 00 00 00	 mov	 DWORD PTR ?dataX@@3PAEA, eax

; 262  :     sizeX = _size;

  00024	8b 45 0c	 mov	 eax, DWORD PTR __size$[ebp]

; 263  : 
; 264  :     jpeg_create_decompress(&cinfo);

  00027	68 c8 01 00 00	 push	 456			; 000001c8H
  0002c	a3 00 00 00 00	 mov	 DWORD PTR ?sizeX@@3HA, eax
  00031	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00037	6a 5a		 push	 90			; 0000005aH
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _jpeg_CreateDecompress

; 265  : 
; 266  :     mgr.next_input_byte = dataX;

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dataX@@3PAEA
  00044	89 85 90 fd ff
	ff		 mov	 DWORD PTR _mgr$[ebp], eax

; 267  :     mgr.bytes_in_buffer = sizeX;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sizeX@@3HA
  0004f	89 85 94 fd ff
	ff		 mov	 DWORD PTR _mgr$[ebp+4], eax

; 268  :     mgr.init_source        =mem_init_source ;
; 269  :     mgr.fill_input_buffer  =mem_fill_input_buffer ;
; 270  :     mgr.skip_input_data    =mem_skip_input_data ;
; 271  :     mgr.resync_to_restart  =mem_resync_to_restart ;
; 272  :     mgr.term_source        =mem_term_source ;
; 273  : 
; 274  :     cinfo.err = jpeg_std_error(&jerr);

  00055	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  0005b	50		 push	 eax
  0005c	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_init_source
  00066	c7 85 9c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ; mem_fill_input_buffer
  00070	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ; mem_skip_input_data
  0007a	c7 85 a4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+20], OFFSET ?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ; mem_resync_to_restart
  00084	c7 85 a8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+24], OFFSET ?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_term_source
  0008e	e8 00 00 00 00	 call	 _jpeg_std_error
  00093	89 85 b0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 275  :     cinfo.src = &mgr;

  00099	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  0009f	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 276  : 
; 277  :     jpeg_read_header(&cinfo, TRUE);

  000a5	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000ab	6a 01		 push	 1
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _jpeg_read_header

; 278  :     jpeg_start_decompress(&cinfo);

  000b3	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _jpeg_start_decompress

; 279  : 
; 280  :     for(y=0;y<height;y++) {

  000bf	8b 7d 18	 mov	 edi, DWORD PTR _height$[ebp]
  000c2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c5	85 ff		 test	 edi, edi
  000c7	7e 2c		 jle	 SHORT $LN3@jpeg_load_

; 254  : {

  000c9	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  000cc	0f 1f 40 00	 npad	 4
$LL4@jpeg_load_:

; 281  : 	unsigned char*j = &dest[width*y*3];
; 282  : 	jpeg_read_scanlines(&cinfo,&j,1);

  000d0	6a 01		 push	 1
  000d2	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _j$1[ebp]
  000d8	89 b5 ac fd ff
	ff		 mov	 DWORD PTR _j$1[ebp], esi
  000de	50		 push	 eax
  000df	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _jpeg_read_scanlines
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	03 f3		 add	 esi, ebx
  000f0	83 ef 01	 sub	 edi, 1
  000f3	75 db		 jne	 SHORT $LL4@jpeg_load_
$LN3@jpeg_load_:

; 283  :     }
; 284  : 
; 285  :     jpeg_finish_decompress(&cinfo);

  000f5	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _jpeg_finish_decompress

; 286  :     jpeg_destroy_decompress(&cinfo);

  00101	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 287  :     return 1;
; 288  : }

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	83 c4 08	 add	 esp, 8
  00113	33 cd		 xor	 ecx, ebp
  00115	b8 01 00 00 00	 mov	 eax, 1
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
?jpeg_load_from_mem@@YAHPAEH0HH@Z ENDP			; jpeg_load_from_mem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_load@@YAHPBDPAPAEPAH2@Z
_TEXT	SEGMENT
_fi$1$ = -632						; size = 4
_height$1$ = -628					; size = 4
_width$1$ = -624					; size = 4
tv1252 = -620						; size = 4
_dest$GSCopy$1$ = -616					; size = 4
_y$1$ = -612						; size = 4
tv1247 = -608						; size = 4
tv1244 = -604						; size = 4
__height$GSCopy$1$ = -604				; size = 4
_scanline$1$ = -600					; size = 4
_js$1 = -596						; size = 4
_cinfo$ = -592						; size = 456
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_dest$ = 12						; size = 4
__width$ = 16						; size = 4
__height$ = 20						; size = 4
?jpeg_load@@YAHPBDPAPAEPAH2@Z PROC			; jpeg_load, COMDAT

; 297  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 02 00
	00		 sub	 esp, 632		; 00000278H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 10	 mov	 ebx, DWORD PTR __width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0001e	57		 push	 edi
  0001f	89 85 98 fd ff
	ff		 mov	 DWORD PTR _dest$GSCopy$1$[ebp], eax
  00025	8b 45 14	 mov	 eax, DWORD PTR __height$[ebp]

; 298  :     struct jpeg_decompress_struct cinfo;
; 299  :     struct jpeg_error_mgr jerr;
; 300  :     //struct jpeg_source_mgr mgr;
; 301  : 
; 302  :     FILE*fi = fopen(filename, "rb");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0002d	56		 push	 esi
  0002e	89 85 a4 fd ff
	ff		 mov	 DWORD PTR __height$GSCopy$1$[ebp], eax
  00034	e8 00 00 00 00	 call	 _fopen
  00039	8b f8		 mov	 edi, eax
  0003b	83 c4 08	 add	 esp, 8
  0003e	89 bd 88 fd ff
	ff		 mov	 DWORD PTR _fi$1$[ebp], edi

; 303  :     if(!fi) {

  00044	85 ff		 test	 edi, edi
  00046	75 2c		 jne	 SHORT $LN17@jpeg_load

; 304  :         fprintf(stderr, "Couldn't open file %s\n", filename);

  00048	56		 push	 esi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@
  0004e	6a 02		 push	 2
  00050	e8 00 00 00 00	 call	 ___acrt_iob_func
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _fprintf
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 305  : 	return 0;

  00061	33 c0		 xor	 eax, eax
  00063	5f		 pop	 edi

; 369  : }

  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN17@jpeg_load:

; 306  :     }
; 307  : 
; 308  :     cinfo.err = jpeg_std_error(&jerr);

  00074	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _jpeg_std_error

; 309  :     jpeg_create_decompress(&cinfo);

  00080	68 c8 01 00 00	 push	 456			; 000001c8H
  00085	89 85 b0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  0008b	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00091	6a 5a		 push	 90			; 0000005aH
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _jpeg_CreateDecompress

; 310  :     jpeg_stdio_src(&cinfo, fi);

  00099	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0009f	57		 push	 edi
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _jpeg_stdio_src

; 311  :     jpeg_read_header(&cinfo, TRUE);

  000a6	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000ac	6a 01		 push	 1
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _jpeg_read_header

; 312  :     jpeg_start_decompress(&cinfo);

  000b4	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _jpeg_start_decompress

; 313  : 
; 314  :     U8*scanline = (U8 *)malloc(4 * cinfo.output_width);

  000c0	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+92]
  000c6	c1 e0 02	 shl	 eax, 2
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _malloc

; 315  : 
; 316  :     int width = *_width = cinfo.output_width;

  000cf	8b bd 0c fe ff
	ff		 mov	 edi, DWORD PTR _cinfo$[ebp+92]
  000d5	8b f0		 mov	 esi, eax

; 317  :     int height = *_height = cinfo.output_height;

  000d7	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR __height$GSCopy$1$[ebp]
  000dd	89 3b		 mov	 DWORD PTR [ebx], edi
  000df	8b 9d 10 fe ff
	ff		 mov	 ebx, DWORD PTR _cinfo$[ebp+96]
  000e5	89 b5 a8 fd ff
	ff		 mov	 DWORD PTR _scanline$1$[ebp], esi
  000eb	89 19		 mov	 DWORD PTR [ecx], ebx

; 318  :     *dest = (unsigned char*)malloc(width*height*4);

  000ed	8b cb		 mov	 ecx, ebx
  000ef	0f af cf	 imul	 ecx, edi
  000f2	89 bd 90 fd ff
	ff		 mov	 DWORD PTR _width$1$[ebp], edi
  000f8	89 9d 8c fd ff
	ff		 mov	 DWORD PTR _height$1$[ebp], ebx
  000fe	c1 e1 02	 shl	 ecx, 2
  00101	51		 push	 ecx
  00102	e8 00 00 00 00	 call	 _malloc
  00107	8b 95 98 fd ff
	ff		 mov	 edx, DWORD PTR _dest$GSCopy$1$[ebp]
  0010d	83 c4 2c	 add	 esp, 44			; 0000002cH

; 319  : 
; 320  :     int y;
; 321  :     for (y=0;y<height;y++) {

  00110	c7 85 9c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$1$[ebp], 0
  0011a	89 02		 mov	 DWORD PTR [edx], eax
  0011c	85 db		 test	 ebx, ebx
  0011e	0f 8e 19 02 00
	00		 jle	 $LN3@jpeg_load

; 306  :     }
; 307  : 
; 308  :     cinfo.err = jpeg_std_error(&jerr);

  00124	33 c9		 xor	 ecx, ecx
  00126	89 8d a4 fd ff
	ff		 mov	 DWORD PTR tv1244[ebp], ecx
  0012c	0f 1f 40 00	 npad	 4
$LL4@jpeg_load:

; 322  : 	int x;
; 323  : 	U8 *js = scanline;
; 324  :         RGBA*line = &((RGBA*)(*dest))[y*width];

  00130	8b 1a		 mov	 ebx, DWORD PTR [edx]

; 325  : 
; 326  : 	jpeg_read_scanlines(&cinfo, &js, 1);

  00132	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _js$1[ebp]
  00138	6a 01		 push	 1
  0013a	50		 push	 eax
  0013b	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00141	89 b5 ac fd ff
	ff		 mov	 DWORD PTR _js$1[ebp], esi
  00147	50		 push	 eax
  00148	03 d9		 add	 ebx, ecx
  0014a	e8 00 00 00 00	 call	 _jpeg_read_scanlines

; 327  : 	if (cinfo.out_color_space == JCS_GRAYSCALE) {

  0014f	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+44]
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH
  00158	83 f8 01	 cmp	 eax, 1
  0015b	75 36		 jne	 SHORT $LN18@jpeg_load

; 328  : 	    for (x = 0; x < width; x++) {

  0015d	33 d2		 xor	 edx, edx
  0015f	85 ff		 test	 edi, edi
  00161	0f 8e a2 01 00
	00		 jle	 $LN2@jpeg_load
  00167	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0016a	66 0f 1f 44 00
	00		 npad	 6
$LL7@jpeg_load:

; 329  : 		line[x].a = 255;

  00170	c6 40 fe ff	 mov	 BYTE PTR [eax-2], 255	; 000000ffH
  00174	8d 40 04	 lea	 eax, DWORD PTR [eax+4]

; 330  : 		line[x].r = line[x].g = line[x].b = js[x];

  00177	8b 8d ac fd ff
	ff		 mov	 ecx, DWORD PTR _js$1[ebp]
  0017d	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00180	42		 inc	 edx
  00181	88 48 fd	 mov	 BYTE PTR [eax-3], cl
  00184	88 48 fc	 mov	 BYTE PTR [eax-4], cl
  00187	88 48 fb	 mov	 BYTE PTR [eax-5], cl
  0018a	3b d7		 cmp	 edx, edi
  0018c	7c e2		 jl	 SHORT $LL7@jpeg_load

; 331  : 	    }
; 332  : 	} else if (cinfo.out_color_space == JCS_RGB) {

  0018e	e9 76 01 00 00	 jmp	 $LN2@jpeg_load
$LN18@jpeg_load:
  00193	83 f8 02	 cmp	 eax, 2
  00196	75 56		 jne	 SHORT $LN20@jpeg_load

; 333  : 	    for (x = width - 1; x >= 0; x--) {

  00198	8d 77 ff	 lea	 esi, DWORD PTR [edi-1]
  0019b	85 f6		 test	 esi, esi
  0019d	0f 88 60 01 00
	00		 js	 $LN50@jpeg_load
  001a3	8d 0c b5 02 00
	00 00		 lea	 ecx, DWORD PTR [esi*4+2]
  001aa	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  001ad	03 cb		 add	 ecx, ebx
  001af	90		 npad	 1
$LL10@jpeg_load:
  001b0	83 ee 01	 sub	 esi, 1

; 334  : 		line[x].a = 255;

  001b3	c6 41 fe ff	 mov	 BYTE PTR [ecx-2], 255	; 000000ffH

; 335  : 		line[x].r = js[x*3+0];

  001b7	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  001bd	8d 52 fd	 lea	 edx, DWORD PTR [edx-3]
  001c0	8d 49 fc	 lea	 ecx, DWORD PTR [ecx-4]
  001c3	0f b6 44 02 03	 movzx	 eax, BYTE PTR [edx+eax+3]
  001c8	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 336  : 		line[x].g = js[x*3+1];

  001cb	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  001d1	0f b6 44 02 04	 movzx	 eax, BYTE PTR [edx+eax+4]
  001d6	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 337  : 		line[x].b = js[x*3+2];

  001d9	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  001df	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  001e4	88 41 05	 mov	 BYTE PTR [ecx+5], al
  001e7	79 c7		 jns	 SHORT $LL10@jpeg_load

; 338  : 	    }
; 339  : 	} else if (cinfo.out_color_space == JCS_YCCK) {

  001e9	e9 15 01 00 00	 jmp	 $LN50@jpeg_load
$LN20@jpeg_load:
  001ee	83 f8 05	 cmp	 eax, 5
  001f1	0f 84 88 01 00
	00		 je	 $LN33@jpeg_load

; 341  : 	    return 0;
; 342  : 	} else if (cinfo.out_color_space == JCS_YCbCr) {

  001f7	83 f8 03	 cmp	 eax, 3
  001fa	0f 85 83 00 00
	00		 jne	 $LN24@jpeg_load

; 343  : 	    for (x = 0; x < width; x++) {

  00200	85 ff		 test	 edi, edi
  00202	0f 8e 01 01 00
	00		 jle	 $LN2@jpeg_load
  00208	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1252[ebp], 0
  00212	8d 73 02	 lea	 esi, DWORD PTR [ebx+2]
  00215	89 bd a0 fd ff
	ff		 mov	 DWORD PTR tv1247[ebp], edi
  0021b	8b bd 94 fd ff
	ff		 mov	 edi, DWORD PTR tv1252[ebp]
$LL13@jpeg_load:

; 344  : 		int y = js[x * 3 + 0];

  00221	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  00227	8d 7f 03	 lea	 edi, DWORD PTR [edi+3]
  0022a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 345  : 		int u = js[x * 3 + 1];

  0022d	0f b6 54 07 fe	 movzx	 edx, BYTE PTR [edi+eax-2]
  00232	8a 5c 07 fd	 mov	 bl, BYTE PTR [edi+eax-3]

; 346  : 		int v = js[x * 3 + 1];
; 347  : 		line[x].a = 255;

  00236	c6 46 fa ff	 mov	 BYTE PTR [esi-6], 255	; 000000ffH

; 348  : 		line[x].r = y + ((360 * (v - 128)) >> 8);

  0023a	8d 42 80	 lea	 eax, DWORD PTR [edx-128]
  0023d	69 c0 68 01 00
	00		 imul	 eax, eax, 360
  00243	c1 f8 08	 sar	 eax, 8
  00246	02 c3		 add	 al, bl
  00248	88 46 fb	 mov	 BYTE PTR [esi-5], al

; 349  : 		line[x].g = y - ((88 * (u - 128) + 183 * (v - 128)) >> 8);

  0024b	8d 42 80	 lea	 eax, DWORD PTR [edx-128]
  0024e	69 c8 0f 01 00
	00		 imul	 ecx, eax, 271
  00254	8a c3		 mov	 al, bl
  00256	c1 f9 08	 sar	 ecx, 8
  00259	2a c1		 sub	 al, cl
  0025b	88 46 fc	 mov	 BYTE PTR [esi-4], al

; 350  : 		line[x].b = y + ((455 * (u - 128)) >> 8);

  0025e	8d 42 80	 lea	 eax, DWORD PTR [edx-128]
  00261	69 c0 c7 01 00
	00		 imul	 eax, eax, 455
  00267	c1 f8 08	 sar	 eax, 8
  0026a	02 c3		 add	 al, bl
  0026c	83 ad a0 fd ff
	ff 01		 sub	 DWORD PTR tv1247[ebp], 1
  00273	88 46 fd	 mov	 BYTE PTR [esi-3], al
  00276	75 a9		 jne	 SHORT $LL13@jpeg_load

; 351  : 	    }
; 352  : 	} else if (cinfo.out_color_space == JCS_CMYK) {

  00278	8b bd 90 fd ff
	ff		 mov	 edi, DWORD PTR _width$1$[ebp]
  0027e	e9 80 00 00 00	 jmp	 $LN50@jpeg_load
$LN24@jpeg_load:
  00283	83 f8 04	 cmp	 eax, 4
  00286	0f 85 7d 00 00
	00		 jne	 $LN2@jpeg_load

; 353  : 	    for (x = 0; x < width; x++) {

  0028c	33 f6		 xor	 esi, esi
  0028e	85 ff		 test	 edi, edi
  00290	7e 71		 jle	 SHORT $LN50@jpeg_load
  00292	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL16@jpeg_load:

; 354  : 		int white = 255 - js[x * 4 + 3];

  002a0	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002a6	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  002ab	0f b6 44 b0 03	 movzx	 eax, BYTE PTR [eax+esi*4+3]
  002b0	2b d0		 sub	 edx, eax

; 355  : 		line[x].a = 255;

  002b2	c6 04 b3 ff	 mov	 BYTE PTR [ebx+esi*4], 255 ; 000000ffH

; 356  : 		line[x].r = white - ((js[x * 4] * white) >> 8);

  002b6	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002bc	0f b6 0c b0	 movzx	 ecx, BYTE PTR [eax+esi*4]
  002c0	8a c2		 mov	 al, dl
  002c2	0f af ca	 imul	 ecx, edx
  002c5	c1 f9 08	 sar	 ecx, 8
  002c8	2a c1		 sub	 al, cl
  002ca	88 44 b3 01	 mov	 BYTE PTR [ebx+esi*4+1], al

; 357  : 		line[x].g = white - ((js[x * 4 + 1] * white) >> 8);

  002ce	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002d4	0f b6 4c b0 01	 movzx	 ecx, BYTE PTR [eax+esi*4+1]
  002d9	8a c2		 mov	 al, dl
  002db	0f af ca	 imul	 ecx, edx
  002de	c1 f9 08	 sar	 ecx, 8
  002e1	2a c1		 sub	 al, cl
  002e3	88 44 b3 02	 mov	 BYTE PTR [ebx+esi*4+2], al

; 358  : 		line[x].b = white - ((js[x * 4 + 2] * white) >> 8);

  002e7	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002ed	0f b6 44 b0 02	 movzx	 eax, BYTE PTR [eax+esi*4+2]
  002f2	0f af c2	 imul	 eax, edx
  002f5	c1 f8 08	 sar	 eax, 8
  002f8	2a d0		 sub	 dl, al
  002fa	88 54 b3 03	 mov	 BYTE PTR [ebx+esi*4+3], dl
  002fe	46		 inc	 esi
  002ff	3b f7		 cmp	 esi, edi
  00301	7c 9d		 jl	 SHORT $LL16@jpeg_load
$LN50@jpeg_load:

; 319  : 
; 320  :     int y;
; 321  :     for (y=0;y<height;y++) {

  00303	8b b5 a8 fd ff
	ff		 mov	 esi, DWORD PTR _scanline$1$[ebp]
$LN2@jpeg_load:
  00309	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR _y$1$[ebp]
  0030f	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  00316	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1244[ebp]
  0031c	40		 inc	 eax
  0031d	03 ca		 add	 ecx, edx
  0031f	89 85 9c fd ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax
  00325	8b 95 98 fd ff
	ff		 mov	 edx, DWORD PTR _dest$GSCopy$1$[ebp]
  0032b	89 8d a4 fd ff
	ff		 mov	 DWORD PTR tv1244[ebp], ecx
  00331	3b 85 8c fd ff
	ff		 cmp	 eax, DWORD PTR _height$1$[ebp]
  00337	0f 8c f3 fd ff
	ff		 jl	 $LL4@jpeg_load
$LN3@jpeg_load:

; 359  : 	    }
; 360  : 	}
; 361  :     }
; 362  : 
; 363  :     free(scanline);

  0033d	56		 push	 esi
  0033e	e8 00 00 00 00	 call	 _free

; 364  : 
; 365  :     jpeg_finish_decompress(&cinfo);

  00343	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 _jpeg_finish_decompress

; 366  :     jpeg_destroy_decompress(&cinfo);

  0034f	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00355	50		 push	 eax
  00356	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 367  :     fclose(fi);

  0035b	ff b5 88 fd ff
	ff		 push	 DWORD PTR _fi$1$[ebp]
  00361	e8 00 00 00 00	 call	 _fclose
  00366	83 c4 10	 add	 esp, 16			; 00000010H

; 368  :     return 1;

  00369	b8 01 00 00 00	 mov	 eax, 1
  0036e	5f		 pop	 edi

; 369  : }

  0036f	5e		 pop	 esi
  00370	5b		 pop	 ebx
  00371	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00374	33 cd		 xor	 ecx, ebp
  00376	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037b	8b e5		 mov	 esp, ebp
  0037d	5d		 pop	 ebp
  0037e	c3		 ret	 0
$LN33@jpeg_load:

; 340  : 	    fprintf(stderr, "Error: Can't convert YCCK to RGB.\n");

  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@
  00384	6a 02		 push	 2
  00386	e8 00 00 00 00	 call	 ___acrt_iob_func
  0038b	83 c4 04	 add	 esp, 4
  0038e	50		 push	 eax
  0038f	e8 00 00 00 00	 call	 _fprintf

; 369  : }

  00394	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00397	83 c4 08	 add	 esp, 8
  0039a	33 cd		 xor	 ecx, ebp
  0039c	33 c0		 xor	 eax, eax
  0039e	5f		 pop	 edi
  0039f	5e		 pop	 esi
  003a0	5b		 pop	 ebx
  003a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c3		 ret	 0
?jpeg_load@@YAHPBDPAPAEPAH2@Z ENDP			; jpeg_load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_save_to_mem@@YAHPAEHHH0H@Z
_TEXT	SEGMENT
_mgr$ = -584						; size = 20
_data2$1 = -564						; size = 4
_cinfo$ = -560						; size = 424
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
__dest$ = 24						; size = 4
__destlen$ = 28						; size = 4
?jpeg_save_to_mem@@YAHPAEHHH0H@Z PROC			; jpeg_save_to_mem, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 02 00
	00		 sub	 esp, 584		; 00000248H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _width$[ebp]

; 173  :   struct jpeg_destination_mgr mgr;
; 174  :   struct jpeg_compress_struct cinfo;
; 175  :   struct jpeg_error_mgr jerr;
; 176  :   int t;
; 177  : 
; 178  :   memset(&cinfo, 0, sizeof(cinfo));

  00017	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp+4]
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  00021	57		 push	 edi
  00022	68 a4 01 00 00	 push	 420			; 000001a4H
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _memset

; 179  :   memset(&jerr, 0, sizeof(jerr));

  0002f	68 84 00 00 00	 push	 132			; 00000084H
  00034	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  0003a	6a 00		 push	 0
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset

; 180  :   memset(&mgr, 0, sizeof(mgr));
; 181  :   cinfo.err = jpeg_std_error(&jerr);

  00042	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00048	0f 57 c0	 xorps	 xmm0, xmm0
  0004b	50		 push	 eax
  0004c	66 0f 13 85 b8
	fd ff ff	 movlpd	 QWORD PTR _mgr$[ebp], xmm0
  00054	e8 00 00 00 00	 call	 _jpeg_std_error

; 182  :   jpeg_create_compress(&cinfo);

  00059	68 a8 01 00 00	 push	 424			; 000001a8H
  0005e	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  00064	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0006a	6a 5a		 push	 90			; 0000005aH
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _jpeg_CreateCompress

; 183  : 
; 184  :   dest = _dest;

  00072	8b 45 18	 mov	 eax, DWORD PTR __dest$[ebp]

; 185  :   len = 0;
; 186  :   destlen = _destlen;
; 187  : 
; 188  :   mgr.init_destination = mem_init_destination;
; 189  :   mgr.empty_output_buffer = mem_empty_output_buffer;
; 190  :   mgr.term_destination = mem_term_destination;
; 191  :   cinfo.dest = &mgr;
; 192  : 
; 193  :   // init compression
; 194  : 
; 195  :   cinfo.image_width  = width;
; 196  :   cinfo.image_height = height;

  00075	8b 7d 10	 mov	 edi, DWORD PTR _height$[ebp]
  00078	a3 00 00 00 00	 mov	 DWORD PTR ?dest@@3PAEA, eax
  0007d	8b 45 1c	 mov	 eax, DWORD PTR __destlen$[ebp]
  00080	a3 00 00 00 00	 mov	 DWORD PTR ?destlen@@3HA, eax
  00085	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  0008b	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 197  :   cinfo.input_components = 3;
; 198  :   cinfo.in_color_space = JCS_RGB;
; 199  :   jpeg_set_defaults(&cinfo);

  00091	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00097	50		 push	 eax
  00098	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?len@@3HA, 0
  000a2	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; mem_init_destination
  000ac	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; mem_empty_output_buffer
  000b6	c7 85 c8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; mem_term_destination
  000c0	89 9d ec fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], ebx
  000c6	89 bd f0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], edi
  000cc	c7 85 f4 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3
  000d6	c7 85 f8 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2
  000e0	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 200  :   cinfo.dct_method = JDCT_IFAST;
; 201  :   jpeg_set_quality(&cinfo,quality,TRUE);

  000e5	6a 01		 push	 1
  000e7	ff 75 14	 push	 DWORD PTR _quality$[ebp]
  000ea	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000f0	c7 85 ac fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+220], 1
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _jpeg_set_quality

; 202  : 
; 203  :   jpeg_start_compress(&cinfo, FALSE);

  00100	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00106	6a 00		 push	 0
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _jpeg_start_compress
  0010e	83 c4 40	 add	 esp, 64			; 00000040H

; 204  :   for(t=0;t<height;t++) {

  00111	85 ff		 test	 edi, edi
  00113	7e 30		 jle	 SHORT $LN3@jpeg_save_

; 172  : {

  00115	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  00118	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@jpeg_save_:

; 205  :     unsigned char*data2 = &data[width*3*t];
; 206  :     jpeg_write_scanlines(&cinfo, &data2, 1);

  00120	6a 01		 push	 1
  00122	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00128	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _data2$1[ebp], esi
  0012e	50		 push	 eax
  0012f	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013e	03 f3		 add	 esi, ebx
  00140	83 ef 01	 sub	 edi, 1
  00143	75 db		 jne	 SHORT $LL4@jpeg_save_
$LN3@jpeg_save_:

; 207  :   }
; 208  :   jpeg_finish_compress(&cinfo);

  00145	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 209  :   jpeg_destroy_compress(&cinfo);

  00151	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 _jpeg_destroy_compress

; 210  :   return len;
; 211  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	83 c4 08	 add	 esp, 8
  00163	a1 00 00 00 00	 mov	 eax, DWORD PTR ?len@@3HA
  00168	33 cd		 xor	 ecx, ebp
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?jpeg_save_to_mem@@YAHPAEHHH0H@Z ENDP			; jpeg_save_to_mem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z
_TEXT	SEGMENT
_mgr$ = -584						; size = 20
_data2$1 = -564						; size = 4
_cinfo$ = -560						; size = 424
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
__fi$ = 24						; size = 4
?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z PROC		; jpeg_save_to_file, COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 02 00
	00		 sub	 esp, 584		; 00000248H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :   struct jpeg_destination_mgr mgr;
; 131  :   struct jpeg_compress_struct cinfo;
; 132  :   struct jpeg_error_mgr jerr;
; 133  :   int t;
; 134  : 
; 135  :   fi = _fi;

  00013	8b 45 18	 mov	 eax, DWORD PTR __fi$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  0001e	57		 push	 edi

; 136  : 
; 137  :   memset(&cinfo, 0, sizeof(cinfo));

  0001f	68 a4 01 00 00	 push	 420			; 000001a4H
  00024	a3 00 00 00 00	 mov	 DWORD PTR ?fi@@3PAU_iobuf@@A, eax
  00029	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp+4]
  0002f	6a 00		 push	 0
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memset

; 138  :   memset(&jerr, 0, sizeof(jerr));

  00037	68 84 00 00 00	 push	 132			; 00000084H
  0003c	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00042	6a 00		 push	 0
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memset

; 139  :   memset(&mgr, 0, sizeof(mgr));
; 140  :   cinfo.err = jpeg_std_error(&jerr);

  0004a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00050	0f 57 c0	 xorps	 xmm0, xmm0
  00053	50		 push	 eax
  00054	66 0f 13 85 b8
	fd ff ff	 movlpd	 QWORD PTR _mgr$[ebp], xmm0
  0005c	e8 00 00 00 00	 call	 _jpeg_std_error

; 141  :   jpeg_create_compress(&cinfo);

  00061	68 a8 01 00 00	 push	 424			; 000001a8H
  00066	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  0006c	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00072	6a 5a		 push	 90			; 0000005aH
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _jpeg_CreateCompress

; 142  : 
; 143  :   mgr.init_destination = file_init_destination;
; 144  :   mgr.empty_output_buffer = file_empty_output_buffer;
; 145  :   mgr.term_destination = file_term_destination;
; 146  :   cinfo.dest = &mgr;
; 147  : 
; 148  :   // init compression
; 149  : 
; 150  :   cinfo.image_width  = width;
; 151  :   cinfo.image_height = height;

  0007a	8b 7d 10	 mov	 edi, DWORD PTR _height$[ebp]
  0007d	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  00083	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 152  :   cinfo.input_components = 3;
; 153  :   cinfo.in_color_space = JCS_RGB;
; 154  :   jpeg_set_defaults(&cinfo);

  00089	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0008f	50		 push	 eax
  00090	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_init_destination
  0009a	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; file_empty_output_buffer
  000a4	c7 85 c8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_term_destination
  000ae	89 9d ec fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], ebx
  000b4	89 bd f0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], edi
  000ba	c7 85 f4 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3
  000c4	c7 85 f8 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2
  000ce	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 155  :   cinfo.dct_method = JDCT_IFAST;
; 156  :   jpeg_set_quality(&cinfo,quality,TRUE);

  000d3	6a 01		 push	 1
  000d5	ff 75 14	 push	 DWORD PTR _quality$[ebp]
  000d8	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000de	c7 85 ac fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+220], 1
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _jpeg_set_quality

; 157  : 
; 158  :   //jpeg_write_tables(&cinfo);
; 159  :   //jpeg_suppress_tables(&cinfo, TRUE);
; 160  :   jpeg_start_compress(&cinfo, FALSE);

  000ee	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000f4	6a 00		 push	 0
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _jpeg_start_compress
  000fc	83 c4 40	 add	 esp, 64			; 00000040H

; 161  : 
; 162  :   for(t=0;t<height;t++) {

  000ff	85 ff		 test	 edi, edi
  00101	7e 32		 jle	 SHORT $LN3@jpeg_save_

; 129  : {

  00103	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  00106	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@jpeg_save_:

; 163  :     unsigned char*data2 = &data[width*3*t];
; 164  :     jpeg_write_scanlines(&cinfo, &data2, 1);

  00110	6a 01		 push	 1
  00112	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00118	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _data2$1[ebp], esi
  0011e	50		 push	 eax
  0011f	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	03 f3		 add	 esi, ebx
  00130	83 ef 01	 sub	 edi, 1
  00133	75 db		 jne	 SHORT $LL4@jpeg_save_
$LN3@jpeg_save_:

; 165  :   }
; 166  :   jpeg_finish_compress(&cinfo);

  00135	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 167  :   jpeg_destroy_compress(&cinfo);

  00141	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _jpeg_destroy_compress

; 168  :   return 1;
; 169  : }

  0014d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00150	83 c4 08	 add	 esp, 8
  00153	33 cd		 xor	 ecx, ebp
  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z ENDP		; jpeg_save_to_file
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_save@@YAHPAEHHHPBD@Z
_TEXT	SEGMENT
_mgr$ = -584						; size = 20
_data2$1 = -564						; size = 4
_cinfo$ = -560						; size = 424
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
_filename$ = 24						; size = 4
?jpeg_save@@YAHPAEHHHPBD@Z PROC				; jpeg_save, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 02 00
	00		 sub	 esp, 584		; 00000248H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 18	 mov	 eax, DWORD PTR _filename$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]

; 80   :   struct jpeg_destination_mgr mgr;
; 81   :   struct jpeg_compress_struct cinfo;
; 82   :   struct jpeg_error_mgr jerr;
; 83   :   int t;
; 84   : 
; 85   :   if(filename) {

  0001e	85 c0		 test	 eax, eax
  00020	74 27		 je	 SHORT $LN5@jpeg_save

; 86   :     fi = fopen(filename, "wb");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _fopen
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 00 00 00 00	 mov	 DWORD PTR ?fi@@3PAU_iobuf@@A, eax

; 87   : 	if(fi == NULL)

  00035	85 c0		 test	 eax, eax
  00037	75 1a		 jne	 SHORT $LN6@jpeg_save

; 125  :   return 1;
; 126  : }

  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN5@jpeg_save:

; 88   : 		return 0;
; 89   :   } else
; 90   :     fi = NULL;

  00049	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?fi@@3PAU_iobuf@@A, 0
$LN6@jpeg_save:
  00053	57		 push	 edi

; 91   : 
; 92   :   memset(&cinfo, 0, sizeof(cinfo));

  00054	68 a4 01 00 00	 push	 420			; 000001a4H
  00059	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp+4]
  0005f	6a 00		 push	 0
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _memset

; 93   :   memset(&jerr, 0, sizeof(jerr));

  00067	68 84 00 00 00	 push	 132			; 00000084H
  0006c	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00072	6a 00		 push	 0
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _memset

; 94   :   memset(&mgr, 0, sizeof(mgr));
; 95   :   cinfo.err = jpeg_std_error(&jerr);

  0007a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	50		 push	 eax
  00084	66 0f 13 85 b8
	fd ff ff	 movlpd	 QWORD PTR _mgr$[ebp], xmm0
  0008c	e8 00 00 00 00	 call	 _jpeg_std_error

; 96   :   jpeg_create_compress(&cinfo);

  00091	68 a8 01 00 00	 push	 424			; 000001a8H
  00096	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  0009c	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000a2	6a 5a		 push	 90			; 0000005aH
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _jpeg_CreateCompress

; 97   : 
; 98   :   mgr.init_destination = file_init_destination;
; 99   :   mgr.empty_output_buffer = file_empty_output_buffer;
; 100  :   mgr.term_destination = file_term_destination;
; 101  :   cinfo.dest = &mgr;
; 102  : 
; 103  :   // init compression
; 104  : 
; 105  :   cinfo.image_width  = width;
; 106  :   cinfo.image_height = height;

  000aa	8b 7d 10	 mov	 edi, DWORD PTR _height$[ebp]
  000ad	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  000b3	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 107  :   cinfo.input_components = 3;
; 108  :   cinfo.in_color_space = JCS_RGB;
; 109  :   jpeg_set_defaults(&cinfo);

  000b9	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000bf	50		 push	 eax
  000c0	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_init_destination
  000ca	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; file_empty_output_buffer
  000d4	c7 85 c8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_term_destination
  000de	89 9d ec fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], ebx
  000e4	89 bd f0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], edi
  000ea	c7 85 f4 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3
  000f4	c7 85 f8 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2
  000fe	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 110  :   jpeg_set_quality(&cinfo,quality,TRUE);

  00103	6a 01		 push	 1
  00105	ff 75 14	 push	 DWORD PTR _quality$[ebp]
  00108	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _jpeg_set_quality

; 111  : 
; 112  :   //jpeg_write_tables(&cinfo);
; 113  :   //jpeg_suppress_tables(&cinfo, TRUE);
; 114  :   jpeg_start_compress(&cinfo, FALSE);

  00114	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0011a	6a 00		 push	 0
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _jpeg_start_compress
  00122	83 c4 40	 add	 esp, 64			; 00000040H

; 115  : 
; 116  :   for(t=0;t<height;t++) {

  00125	85 ff		 test	 edi, edi
  00127	7e 2c		 jle	 SHORT $LN3@jpeg_save

; 91   : 
; 92   :   memset(&cinfo, 0, sizeof(cinfo));

  00129	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  0012c	0f 1f 40 00	 npad	 4
$LL4@jpeg_save:

; 117  :     unsigned char*data2 = &data[width*3*t];
; 118  :     jpeg_write_scanlines(&cinfo, &data2, 1);

  00130	6a 01		 push	 1
  00132	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00138	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _data2$1[ebp], esi
  0013e	50		 push	 eax
  0013f	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014e	03 f3		 add	 esi, ebx
  00150	83 ef 01	 sub	 edi, 1
  00153	75 db		 jne	 SHORT $LL4@jpeg_save
$LN3@jpeg_save:

; 119  :   }
; 120  :   jpeg_finish_compress(&cinfo);

  00155	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 121  : 
; 122  :   if(fi)

  00161	a1 00 00 00 00	 mov	 eax, DWORD PTR ?fi@@3PAU_iobuf@@A
  00166	83 c4 04	 add	 esp, 4
  00169	5f		 pop	 edi
  0016a	85 c0		 test	 eax, eax
  0016c	74 09		 je	 SHORT $LN8@jpeg_save

; 123  :     fclose(fi);

  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _fclose
  00174	83 c4 04	 add	 esp, 4
$LN8@jpeg_save:

; 124  :   jpeg_destroy_compress(&cinfo);

  00177	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _jpeg_destroy_compress

; 125  :   return 1;
; 126  : }

  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	83 c4 04	 add	 esp, 4
  00189	33 cd		 xor	 ecx, ebp
  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c3		 ret	 0
?jpeg_save@@YAHPAEHHHPBD@Z ENDP				; jpeg_save
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000e	83 c4 04	 add	 esp, 4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00014	51		 push	 ecx
  00015	6a 00		 push	 0
  00017	56		 push	 esi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;

  0002b	5e		 pop	 esi

; 961  :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;
; 842  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
