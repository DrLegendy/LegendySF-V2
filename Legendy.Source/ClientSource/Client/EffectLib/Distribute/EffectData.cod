; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7?$CDynamicPool@VCEffectData@@@@6B@		; CDynamicPool<CEffectData>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCEffectData@@@@UAEPAXI@Z	; CDynamicPool<CEffectData>::`scalar deleting destructor'
PUBLIC	??_R4?$CDynamicPool@VCEffectData@@@@6B@		; CDynamicPool<CEffectData>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCEffectData@@@@@8	; CDynamicPool<CEffectData> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCEffectData@@@@8		; CDynamicPool<CEffectData>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCEffectData@@@@8		; CDynamicPool<CEffectData>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCEffectData@@@@8	; CDynamicPool<CEffectData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPool@VCEffectData@@@@UAEPAXI@Z:PROC ; CDynamicPool<CEffectData>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCEffectData@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCEffectData@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCEffectData@@@@@8 ; CDynamicPool<CEffectData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCEffectData@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCEffectData@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCEffectData@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCEffectData@@@@8 ; CDynamicPool<CEffectData>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCEffectData@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCEffectData@@@@8 DD 00H		; CDynamicPool<CEffectData>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCEffectData@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCEffectData@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCEffectData@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CEffectData> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCEffectData@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCEffectData@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCEffectData@@@@6B@ DD 00H		; CDynamicPool<CEffectData>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCEffectData@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCEffectData@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$CDynamicPool@VCEffectData@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCEffectData@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCEffectData@@@@6B@ ; CDynamicPool<CEffectData>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCEffectData@@@@UAEPAXI@Z
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CEffectData@@QAE@XZ				; CEffectData::CEffectData
PUBLIC	??1CEffectData@@UAE@XZ				; CEffectData::~CEffectData
PUBLIC	?Clear@CEffectData@@QAEXXZ			; CEffectData::Clear
PUBLIC	?LoadScript@CEffectData@@QAE_NPBD@Z		; CEffectData::LoadScript
PUBLIC	?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z	; CEffectData::LoadSoundScriptData
PUBLIC	?GetParticleCount@CEffectData@@QAEKXZ		; CEffectData::GetParticleCount
PUBLIC	?GetParticlePointer@CEffectData@@QAEPAVCParticleSystemData@@K@Z ; CEffectData::GetParticlePointer
PUBLIC	?GetMeshCount@CEffectData@@QAEKXZ		; CEffectData::GetMeshCount
PUBLIC	?GetMeshPointer@CEffectData@@QAEPAVCEffectMeshScript@@K@Z ; CEffectData::GetMeshPointer
PUBLIC	?GetLightCount@CEffectData@@QAEKXZ		; CEffectData::GetLightCount
PUBLIC	?GetLightPointer@CEffectData@@QAEPAVCLightData@@K@Z ; CEffectData::GetLightPointer
PUBLIC	?GetSoundInstanceVector@CEffectData@@QAEPAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@XZ ; CEffectData::GetSoundInstanceVector
PUBLIC	?GetBoundingSphereRadius@CEffectData@@QAEMXZ	; CEffectData::GetBoundingSphereRadius
PUBLIC	?GetBoundingSpherePosition@CEffectData@@QAE?AUD3DXVECTOR3@@XZ ; CEffectData::GetBoundingSpherePosition
PUBLIC	?GetFileName@CEffectData@@QBEPBDXZ		; CEffectData::GetFileName
PUBLIC	?__ClearParticleDataVector@CEffectData@@IAEXXZ	; CEffectData::__ClearParticleDataVector
PUBLIC	?__ClearLightDataVector@CEffectData@@IAEXXZ	; CEffectData::__ClearLightDataVector
PUBLIC	?__ClearMeshDataVector@CEffectData@@IAEXXZ	; CEffectData::__ClearMeshDataVector
PUBLIC	?AllocParticle@CEffectData@@MAEPAVCParticleSystemData@@XZ ; CEffectData::AllocParticle
PUBLIC	?AllocMesh@CEffectData@@MAEPAVCEffectMeshScript@@XZ ; CEffectData::AllocMesh
PUBLIC	?AllocLight@CEffectData@@MAEPAVCLightData@@XZ	; CEffectData::AllocLight
PUBLIC	?_Xlength@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@CAXXZ ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Xlength
PUBLIC	?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
PUBLIC	?_Xlength@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@CAXXZ ; std::vector<CLightData *,std::allocator<CLightData *> >::_Xlength
PUBLIC	??1?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::~vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >
PUBLIC	?DestroySystem@CEffectData@@SAXXZ		; CEffectData::DestroySystem
PUBLIC	?New@CEffectData@@SAPAV1@XZ			; CEffectData::New
PUBLIC	?Delete@CEffectData@@SAXPAV1@@Z			; CEffectData::Delete
PUBLIC	??_GCEffectData@@UAEPAXI@Z			; CEffectData::`scalar deleting destructor'
PUBLIC	??1?$CDynamicPool@VCEffectData@@@@UAE@XZ	; CDynamicPool<CEffectData>::~CDynamicPool<CEffectData>
PUBLIC	?Delete@?$CDynamicPool@VCEffectData@@@@KAXPAVCEffectData@@@Z ; CDynamicPool<CEffectData>::Delete
PUBLIC	?_Xlength@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@CAXXZ ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Xlength
PUBLIC	??1?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::~vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >
PUBLIC	??$_Emplace_reallocate@ABQAVCLightData@@@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@QAEPAPAVCLightData@@QAPAV2@ABQAV2@@Z ; std::vector<CLightData *,std::allocator<CLightData *> >::_Emplace_reallocate<CLightData * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCParticleSystemData@@@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@QAEPAPAVCParticleSystemData@@QAPAV2@ABQAV2@@Z ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Emplace_reallocate<CParticleSystemData * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCEffectData@@@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@QAEPAPAVCEffectData@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Emplace_reallocate<CEffectData * const &>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCLightData@@@std@@@std@@YAXPAPAVCLightData@@QAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z ; std::_Destroy_range<std::allocator<CLightData *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAXPAPAVCEffectMeshScript@@QAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAXPAPAVCParticleSystemData@@QAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z ; std::_Destroy_range<std::allocator<CParticleSystemData *> >
PUBLIC	??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCEffectData@@@std@@@std@@YAXPAPAVCEffectData@@QAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectData *> >
PUBLIC	??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
PUBLIC	??$_Uninitialized_move@PAPAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@YAPAPAVCEffectData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z ; std::_Uninitialized_move<CEffectData * *,std::allocator<CEffectData *> >
PUBLIC	??$_Uninitialized_move@PAPAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@YAPAPAVCLightData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z ; std::_Uninitialized_move<CLightData * *,std::allocator<CLightData *> >
PUBLIC	??$_Uninitialized_move@PAPAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAPAPAVCEffectMeshScript@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z ; std::_Uninitialized_move<CEffectMeshScript * *,std::allocator<CEffectMeshScript *> >
PUBLIC	??$_Uninitialized_move@PAPAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAPAPAVCParticleSystemData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z ; std::_Uninitialized_move<CParticleSystemData * *,std::allocator<CParticleSystemData *> >
PUBLIC	??$_Copy_memmove@PAPAVCEffectData@@PAPAV1@@std@@YAPAPAVCEffectData@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectData * *,CEffectData * *>
PUBLIC	??$_Copy_memmove@PAPAVCLightData@@PAPAV1@@std@@YAPAPAVCLightData@@PAPAV1@00@Z ; std::_Copy_memmove<CLightData * *,CLightData * *>
PUBLIC	??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
PUBLIC	??$_Copy_memmove@PAPAVCParticleSystemData@@PAPAV1@@std@@YAPAPAVCParticleSystemData@@PAPAV1@00@Z ; std::_Copy_memmove<CParticleSystemData * *,CParticleSystemData * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A ; CEffectData::ms_kPool
PUBLIC	??_7CEffectData@@6B@				; CEffectData::`vftable'
PUBLIC	??_C@_0BF@MLNDGKC@boundingsphereradius@		; `string'
PUBLIC	??_C@_0BH@HALPILME@boundingsphereposition@	; `string'
PUBLIC	??_C@_04KPBEILIJ@mesh@				; `string'
PUBLIC	??_C@_08PKKGOGAD@particle@			; `string'
PUBLIC	??_C@_05OEPGNJB@light@				; `string'
PUBLIC	??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@		; `string'
PUBLIC	??_C@_06PBLIODKG@sound?1@			; `string'
PUBLIC	??_C@_04NMMFEKGF@?4mss@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CEffectData@@6B@				; CEffectData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEffectData@@@8				; CEffectData `RTTI Type Descriptor'
PUBLIC	??_R3CEffectData@@8				; CEffectData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectData@@8				; CEffectData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectData@@8			; CEffectData::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_tolower:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??0CTextFileLoader@@QAE@XZ:PROC			; CTextFileLoader::CTextFileLoader
EXTRN	??1CTextFileLoader@@UAE@XZ:PROC			; CTextFileLoader::~CTextFileLoader
EXTRN	?Load@CTextFileLoader@@QAE_NPBD@Z:PROC		; CTextFileLoader::Load
EXTRN	?SetTop@CTextFileLoader@@QAEXXZ:PROC		; CTextFileLoader::SetTop
EXTRN	?GetChildNodeCount@CTextFileLoader@@QAEKXZ:PROC	; CTextFileLoader::GetChildNodeCount
EXTRN	?SetChildNode@CTextFileLoader@@QAEHK@Z:PROC	; CTextFileLoader::SetChildNode
EXTRN	?SetParentNode@CTextFileLoader@@QAEHXZ:PROC	; CTextFileLoader::SetParentNode
EXTRN	?GetCurrentNodeName@CTextFileLoader@@QAEHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CTextFileLoader::GetCurrentNodeName
EXTRN	?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z:PROC ; CTextFileLoader::GetTokenFloat
EXTRN	?GetTokenVector3@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXVECTOR3@@@Z:PROC ; CTextFileLoader::GetTokenVector3
EXTRN	?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z:PROC ; NSound::LoadSoundInformationPiece
EXTRN	?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z:PROC ; NSound::DataToInstance
EXTRN	?Clear@CEffectElementBase@@QAEXXZ:PROC		; CEffectElementBase::Clear
EXTRN	?LoadScript@CEffectElementBase@@QAEHAAVCTextFileLoader@@@Z:PROC ; CEffectElementBase::LoadScript
EXTRN	?DestroySystem@CParticleSystemData@@SAXXZ:PROC	; CParticleSystemData::DestroySystem
EXTRN	?New@CParticleSystemData@@SAPAV1@XZ:PROC	; CParticleSystemData::New
EXTRN	?Delete@CParticleSystemData@@SAXPAV1@@Z:PROC	; CParticleSystemData::Delete
EXTRN	?DestroySystem@CEffectMeshScript@@SAXXZ:PROC	; CEffectMeshScript::DestroySystem
EXTRN	?New@CEffectMeshScript@@SAPAV1@XZ:PROC		; CEffectMeshScript::New
EXTRN	?Delete@CEffectMeshScript@@SAXPAV1@@Z:PROC	; CEffectMeshScript::Delete
EXTRN	?DestroySystem@CLightData@@SAXXZ:PROC		; CLightData::DestroySystem
EXTRN	?New@CLightData@@SAPAV1@XZ:PROC			; CLightData::New
EXTRN	?Delete@CLightData@@SAXPAV1@@Z:PROC		; CLightData::Delete
EXTRN	??_ECEffectData@@UAEPAXI@Z:PROC			; CEffectData::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CEffectData@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CEffectData@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectData@@8 DD FLAT:??_R0?AVCEffectData@@@8 ; CEffectData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectData@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectData@@8
rdata$r	SEGMENT
??_R2CEffectData@@8 DD FLAT:??_R1A@?0A@EA@CEffectData@@8 ; CEffectData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEffectData@@8
rdata$r	SEGMENT
??_R3CEffectData@@8 DD 00H				; CEffectData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEffectData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectData@@@8
data$r	SEGMENT
??_R0?AVCEffectData@@@8 DD FLAT:??_7type_info@@6B@	; CEffectData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectData@@', 00H
data$r	ENDS
;	COMDAT ??_R4CEffectData@@6B@
rdata$r	SEGMENT
??_R4CEffectData@@6B@ DD 00H				; CEffectData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectData@@@8
	DD	FLAT:??_R3CEffectData@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NMMFEKGF@?4mss@
CONST	SEGMENT
??_C@_04NMMFEKGF@?4mss@ DB '.mss', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBLIODKG@sound?1@
CONST	SEGMENT
??_C@_06PBLIODKG@sound?1@ DB 'sound/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@
CONST	SEGMENT
??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@ DB 'd:/ymir work/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OEPGNJB@light@
CONST	SEGMENT
??_C@_05OEPGNJB@light@ DB 'light', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PKKGOGAD@particle@
CONST	SEGMENT
??_C@_08PKKGOGAD@particle@ DB 'particle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KPBEILIJ@mesh@
CONST	SEGMENT
??_C@_04KPBEILIJ@mesh@ DB 'mesh', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HALPILME@boundingsphereposition@
CONST	SEGMENT
??_C@_0BH@HALPILME@boundingsphereposition@ DB 'boundingsphereposition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MLNDGKC@boundingsphereradius@
CONST	SEGMENT
??_C@_0BF@MLNDGKC@boundingsphereradius@ DB 'boundingsphereradius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CEffectData@@6B@
CONST	SEGMENT
??_7CEffectData@@6B@ DD FLAT:??_R4CEffectData@@6B@	; CEffectData::`vftable'
	DD	FLAT:??_ECEffectData@@UAEPAXI@Z
	DD	FLAT:?AllocParticle@CEffectData@@MAEPAVCParticleSystemData@@XZ
	DD	FLAT:?AllocMesh@CEffectData@@MAEPAVCEffectMeshScript@@XZ
	DD	FLAT:?AllocLight@CEffectData@@MAEPAVCLightData@@XZ
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A DD FLAT:??_7?$CDynamicPool@VCEffectData@@@@6B@ ; CEffectData::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z$0
__ehfuncinfo$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadScript@CEffectData@@QAE_NPBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LoadScript@CEffectData@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadScript@CEffectData@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$6
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCParticleSystemData@@PAPAV1@@std@@YAPAPAVCParticleSystemData@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCParticleSystemData@@PAPAV1@@std@@YAPAPAVCParticleSystemData@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CParticleSystemData * *,CParticleSystemData * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCParticleSystemData@@PAPAV1@@std@@YAPAPAVCParticleSystemData@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CParticleSystemData * *,CParticleSystemData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCLightData@@PAPAV1@@std@@YAPAPAVCLightData@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCLightData@@PAPAV1@@std@@YAPAPAVCLightData@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CLightData * *,CLightData * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCLightData@@PAPAV1@@std@@YAPAPAVCLightData@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CLightData * *,CLightData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCEffectData@@PAPAV1@@std@@YAPAPAVCEffectData@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCEffectData@@PAPAV1@@std@@YAPAPAVCEffectData@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CEffectData * *,CEffectData * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCEffectData@@PAPAV1@@std@@YAPAPAVCEffectData@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CEffectData * *,CEffectData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAPAPAVCParticleSystemData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAPAPAVCParticleSystemData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z PROC ; std::_Uninitialized_move<CParticleSystemData * *,std::allocator<CParticleSystemData *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCParticleSystemData@@PAPAV1@@std@@YAPAPAVCParticleSystemData@@PAPAV1@00@Z ; std::_Copy_memmove<CParticleSystemData * *,CParticleSystemData * *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAPAPAVCParticleSystemData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z ENDP ; std::_Uninitialized_move<CParticleSystemData * *,std::allocator<CParticleSystemData *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAPAPAVCEffectMeshScript@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAPAPAVCEffectMeshScript@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z PROC ; std::_Uninitialized_move<CEffectMeshScript * *,std::allocator<CEffectMeshScript *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAPAPAVCEffectMeshScript@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z ENDP ; std::_Uninitialized_move<CEffectMeshScript * *,std::allocator<CEffectMeshScript *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@YAPAPAVCLightData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@YAPAPAVCLightData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z PROC ; std::_Uninitialized_move<CLightData * *,std::allocator<CLightData *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCLightData@@PAPAV1@@std@@YAPAPAVCLightData@@PAPAV1@00@Z ; std::_Copy_memmove<CLightData * *,CLightData * *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@YAPAPAVCLightData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z ENDP ; std::_Uninitialized_move<CLightData * *,std::allocator<CLightData *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@YAPAPAVCEffectData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@YAPAPAVCEffectData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z PROC ; std::_Uninitialized_move<CEffectData * *,std::allocator<CEffectData *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectData@@PAPAV1@@std@@YAPAPAVCEffectData@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectData * *,CEffectData * *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@YAPAPAVCEffectData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z ENDP ; std::_Uninitialized_move<CEffectData * *,std::allocator<CEffectData *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 959  :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 32		 je	 SHORT $LN3@Destroy_ra
  0000f	83 c6 18	 add	 esi, 24			; 00000018H
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00017	72 0d		 jb	 SHORT $LN18@Destroy_ra

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00019	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001a	50		 push	 eax
  0001b	ff 76 ec	 push	 DWORD PTR [esi-20]
  0001e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00023	83 c4 08	 add	 esp, 8
$LN18@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00026	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0002d	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00033	c6 46 ec 00	 mov	 BYTE PTR [esi-20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  00037	83 c6 1c	 add	 esi, 28			; 0000001cH
  0003a	8d 46 e8	 lea	 eax, DWORD PTR [esi-24]
  0003d	3b c7		 cmp	 eax, edi
  0003f	75 d1		 jne	 SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:
  00041	5f		 pop	 edi

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCEffectData@@@std@@@std@@YAXPAPAVCEffectData@@QAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCEffectData@@@std@@@std@@YAXPAPAVCEffectData@@QAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CEffectData *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PAVCEffectData@@@std@@@std@@YAXPAPAVCEffectData@@QAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CEffectData *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NSound::SSoundData> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 959  :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 32		 je	 SHORT $LN3@Destroy_ra
  0000f	83 c6 18	 add	 esi, 24			; 00000018H
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00017	72 0d		 jb	 SHORT $LN18@Destroy_ra

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00019	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001a	50		 push	 eax
  0001b	ff 76 ec	 push	 DWORD PTR [esi-20]
  0001e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00023	83 c4 08	 add	 esp, 8
$LN18@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00026	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0002d	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00033	c6 46 ec 00	 mov	 BYTE PTR [esi-20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  00037	83 c6 1c	 add	 esi, 28			; 0000001cH
  0003a	8d 46 e8	 lea	 eax, DWORD PTR [esi-24]
  0003d	3b c7		 cmp	 eax, edi
  0003f	75 d1		 jne	 SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:
  00041	5f		 pop	 edi

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAXPAPAVCParticleSystemData@@QAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAXPAPAVCParticleSystemData@@QAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CParticleSystemData *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAXPAPAVCParticleSystemData@@QAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CParticleSystemData *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAXPAPAVCEffectMeshScript@@QAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAXPAPAVCEffectMeshScript@@QAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CEffectMeshScript *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAXPAPAVCEffectMeshScript@@QAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CEffectMeshScript *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCLightData@@@std@@@std@@YAXPAPAVCLightData@@QAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCLightData@@@std@@@std@@YAXPAPAVCLightData@@QAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CLightData *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PAVCLightData@@@std@@@std@@YAXPAPAVCLightData@@QAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CLightData *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCEffectData@@@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@QAEPAPAVCEffectData@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
tv436 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv435 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCEffectData@@@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@QAEPAPAVCEffectData@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Emplace_reallocate<CEffectData * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 be 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00045	8b c7		 mov	 eax, edi
  00047	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00049	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004c	3b c7		 cmp	 eax, edi
  0004e	0f 42 c7	 cmovb	 eax, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 8f 00 00
	00		 ja	 $LN40@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00060	89 45 f4	 mov	 DWORD PTR tv436[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00063	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006d	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00073	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00076	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	3b da		 cmp	 ebx, edx
  00084	75 07		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00086	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0008b	eb 17		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008d	56		 push	 esi
  0008e	57		 push	 edi
  0008f	53		 push	 ebx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@YAPAPAVCEffectData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z ; std::_Uninitialized_move<CEffectData * *,std::allocator<CEffectData *> >
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009e	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000a4	56		 push	 esi
  000a5	50		 push	 eax
  000a6	52		 push	 edx
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@YAPAPAVCEffectData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectData@@@0@@Z ; std::_Uninitialized_move<CEffectData * *,std::allocator<CEffectData *> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000b2	85 c9		 test	 ecx, ecx
  000b4	74 12		 je	 SHORT $LN33@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	83 e0 fc	 and	 eax, -4			; fffffffcH
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c5	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000cb	8b c3		 mov	 eax, ebx

; 1680 :         _Myfirst = _Newvec;

  000cd	89 3e		 mov	 DWORD PTR [esi], edi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000cf	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  000d2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv436[ebp]
  000d8	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000da	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000db	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 767  :     }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@CAXXZ ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000eb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f0	cc		 int	 3
??$_Emplace_reallocate@ABQAVCEffectData@@@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@QAEPAPAVCEffectData@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Emplace_reallocate<CEffectData * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCParticleSystemData@@@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@QAEPAPAVCParticleSystemData@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
tv436 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv435 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCParticleSystemData@@@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@QAEPAPAVCParticleSystemData@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Emplace_reallocate<CParticleSystemData * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 be 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00045	8b c7		 mov	 eax, edi
  00047	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00049	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004c	3b c7		 cmp	 eax, edi
  0004e	0f 42 c7	 cmovb	 eax, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 8f 00 00
	00		 ja	 $LN40@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00060	89 45 f4	 mov	 DWORD PTR tv436[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00063	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006d	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00073	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00076	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	3b da		 cmp	 ebx, edx
  00084	75 07		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00086	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0008b	eb 17		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008d	56		 push	 esi
  0008e	57		 push	 edi
  0008f	53		 push	 ebx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAPAPAVCParticleSystemData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z ; std::_Uninitialized_move<CParticleSystemData * *,std::allocator<CParticleSystemData *> >
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009e	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000a4	56		 push	 esi
  000a5	50		 push	 eax
  000a6	52		 push	 edx
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@YAPAPAVCParticleSystemData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCParticleSystemData@@@0@@Z ; std::_Uninitialized_move<CParticleSystemData * *,std::allocator<CParticleSystemData *> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000b2	85 c9		 test	 ecx, ecx
  000b4	74 12		 je	 SHORT $LN33@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	83 e0 fc	 and	 eax, -4			; fffffffcH
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c5	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000cb	8b c3		 mov	 eax, ebx

; 1680 :         _Myfirst = _Newvec;

  000cd	89 3e		 mov	 DWORD PTR [esi], edi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000cf	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  000d2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv436[ebp]
  000d8	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000da	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000db	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 767  :     }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@CAXXZ ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000eb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f0	cc		 int	 3
??$_Emplace_reallocate@ABQAVCParticleSystemData@@@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@QAEPAPAVCParticleSystemData@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Emplace_reallocate<CParticleSystemData * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
tv436 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv435 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 be 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00045	8b c7		 mov	 eax, edi
  00047	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00049	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004c	3b c7		 cmp	 eax, edi
  0004e	0f 42 c7	 cmovb	 eax, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 8f 00 00
	00		 ja	 $LN40@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00060	89 45 f4	 mov	 DWORD PTR tv436[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00063	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006d	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00073	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00076	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	3b da		 cmp	 ebx, edx
  00084	75 07		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00086	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0008b	eb 17		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008d	56		 push	 esi
  0008e	57		 push	 edi
  0008f	53		 push	 ebx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAPAPAVCEffectMeshScript@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z ; std::_Uninitialized_move<CEffectMeshScript * *,std::allocator<CEffectMeshScript *> >
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009e	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000a4	56		 push	 esi
  000a5	50		 push	 eax
  000a6	52		 push	 edx
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@YAPAPAVCEffectMeshScript@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshScript@@@0@@Z ; std::_Uninitialized_move<CEffectMeshScript * *,std::allocator<CEffectMeshScript *> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000b2	85 c9		 test	 ecx, ecx
  000b4	74 12		 je	 SHORT $LN33@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	83 e0 fc	 and	 eax, -4			; fffffffcH
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c5	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000cb	8b c3		 mov	 eax, ebx

; 1680 :         _Myfirst = _Newvec;

  000cd	89 3e		 mov	 DWORD PTR [esi], edi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000cf	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  000d2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv436[ebp]
  000d8	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000da	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000db	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 767  :     }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000eb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f0	cc		 int	 3
??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCLightData@@@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@QAEPAPAVCLightData@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
tv436 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv435 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCLightData@@@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@QAEPAPAVCLightData@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CLightData *,std::allocator<CLightData *> >::_Emplace_reallocate<CLightData * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 be 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00045	8b c7		 mov	 eax, edi
  00047	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00049	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004c	3b c7		 cmp	 eax, edi
  0004e	0f 42 c7	 cmovb	 eax, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 8f 00 00
	00		 ja	 $LN40@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00060	89 45 f4	 mov	 DWORD PTR tv436[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00063	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006d	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00073	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00076	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	3b da		 cmp	 ebx, edx
  00084	75 07		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00086	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0008b	eb 17		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008d	56		 push	 esi
  0008e	57		 push	 edi
  0008f	53		 push	 ebx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@YAPAPAVCLightData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z ; std::_Uninitialized_move<CLightData * *,std::allocator<CLightData *> >
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009e	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000a4	56		 push	 esi
  000a5	50		 push	 eax
  000a6	52		 push	 edx
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@YAPAPAVCLightData@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCLightData@@@0@@Z ; std::_Uninitialized_move<CLightData * *,std::allocator<CLightData *> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000b2	85 c9		 test	 ecx, ecx
  000b4	74 12		 je	 SHORT $LN33@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	83 e0 fc	 and	 eax, -4			; fffffffcH
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c5	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000cb	8b c3		 mov	 eax, ebx

; 1680 :         _Myfirst = _Newvec;

  000cd	89 3e		 mov	 DWORD PTR [esi], edi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000cf	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  000d2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv436[ebp]
  000d8	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000da	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000db	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 767  :     }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@CAXXZ ; std::vector<CLightData *,std::allocator<CLightData *> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000eb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f0	cc		 int	 3
??$_Emplace_reallocate@ABQAVCLightData@@@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@QAEPAPAVCLightData@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CLightData *,std::allocator<CLightData *> >::_Emplace_reallocate<CLightData * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::~vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 07		 mov	 eax, DWORD PTR [edi]
  00005	85 c0		 test	 eax, eax
  00007	74 4d		 je	 SHORT $LN4@vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00009	57		 push	 edi
  0000a	ff 77 04	 push	 DWORD PTR [edi+4]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0001b	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0001d	f7 e9		 imul	 ecx
  0001f	03 d1		 add	 edx, ecx
  00021	c1 fa 04	 sar	 edx, 4
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00029	03 ca		 add	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002b	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00032	2b c1		 sub	 eax, ecx
  00034	c1 e0 02	 shl	 eax, 2
  00037	50		 push	 eax
  00038	ff 37		 push	 DWORD PTR [edi]
  0003a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0003f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00048	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  0004f	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  00056	5f		 pop	 edi

; 673  :         _Tidy();
; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00057	c3		 ret	 0
??1?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::~vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CEffectData::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A ; CEffectData::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCEffectData@@@@UAE@XZ ; CDynamicPool<CEffectData>::~CDynamicPool<CEffectData>
??__F?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CEffectData::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ??__E?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CEffectData::ms_kPool'', COMDAT

; 4    : CDynamicPool<CEffectData> CEffectData::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CEffectData::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CEffectData::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCEffectData@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCEffectData@@@@UAEPAXI@Z PROC	; CDynamicPool<CEffectData>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCEffectData@@@@UAE@XZ ; CDynamicPool<CEffectData>::~CDynamicPool<CEffectData>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCEffectData@@@@UAEPAXI@Z ENDP	; CDynamicPool<CEffectData>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCEffectData@@@@KAXPAVCEffectData@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCEffectData@@@@KAXPAVCEffectData@@@Z PROC ; CDynamicPool<CEffectData>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 			delete pkData;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkData$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN3@Delete
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN3@Delete:

; 111  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Delete@?$CDynamicPool@VCEffectData@@@@KAXPAVCEffectData@@@Z ENDP ; CDynamicPool<CEffectData>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCEffectData@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCEffectData@@@@UAE@XZ PROC		; CDynamicPool<CEffectData>::~CDynamicPool<CEffectData>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCEffectData@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 27		 je	 SHORT $LN6@CDynamicPo

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00013	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e0 fc	 and	 eax, -4			; fffffffcH
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00026	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00029	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1699 :             _Myend   = pointer();

  00030	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN6@CDynamicPo:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00037	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 27		 je	 SHORT $LN13@CDynamicPo

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0003e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00041	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00043	83 e0 fc	 and	 eax, -4			; fffffffcH
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0004d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00057	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1699 :             _Myend   = pointer();

  0005e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN13@CDynamicPo:
  00065	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 26   : 		}

  00066	c3		 ret	 0
??1?$CDynamicPool@VCEffectData@@@@UAE@XZ ENDP		; CDynamicPool<CEffectData>::~CDynamicPool<CEffectData>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCEffectData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectData@@UAEPAXI@Z PROC				; CEffectData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CEffectData@@UAE@XZ	; CEffectData::~CEffectData
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 5c		 push	 92			; 0000005cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCEffectData@@UAEPAXI@Z ENDP				; CEffectData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?Delete@CEffectData@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkData$ = 8						; size = 4
?Delete@CEffectData@@SAXPAV1@@Z PROC			; CEffectData::Delete, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 13   : 	pkData->Clear();

  00004	8b 75 08	 mov	 esi, DWORD PTR _pkData$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?Clear@CEffectData@@QAEXXZ ; CEffectData::Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0000e	a1 14 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+20
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 14   : 	ms_kPool.Free(pkData);

  00013	89 75 08	 mov	 DWORD PTR _pkData$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00016	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+24
  0001c	74 0c		 je	 SHORT $LN8@Delete

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	89 30		 mov	 DWORD PTR [eax], esi

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00020	83 05 14 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+20, 4
  00027	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 15   : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN8@Delete:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002a	8d 4d 08	 lea	 ecx, DWORD PTR _pkData$[ebp]
  0002d	51		 push	 ecx
  0002e	50		 push	 eax
  0002f	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+16
  00034	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectData@@@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@QAEPAPAVCEffectData@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Emplace_reallocate<CEffectData * const &>
  00039	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 15   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?Delete@CEffectData@@SAXPAV1@@Z ENDP			; CEffectData::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?New@CEffectData@@SAPAV1@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pkNewData$2 = -4					; size = 4
?New@CEffectData@@SAPAV1@XZ PROC			; CEffectData::New, COMDAT

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00004	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+20
  0000a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+16, ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00010	75 61		 jne	 SHORT $LN4@New

; 65   : 				T* pkNewData=new T;

  00012	56		 push	 esi
  00013	6a 5c		 push	 92			; 0000005cH
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00020	85 c0		 test	 eax, eax
  00022	74 0b		 je	 SHORT $LN6@New
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??0CEffectData@@QAE@XZ	; CEffectData::CEffectData
  0002b	8b f0		 mov	 esi, eax
  0002d	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  0002f	33 f6		 xor	 esi, esi
$LN7@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00031	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+8
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 65   : 				T* pkNewData=new T;

  00036	89 75 fc	 mov	 DWORD PTR _pkNewData$2[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00039	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+12
  0003f	74 16		 je	 SHORT $LN14@New

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00041	89 30		 mov	 DWORD PTR [eax], esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 8    : 	return ms_kPool.Alloc();

  00043	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00045	83 05 08 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+8, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0004c	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+32
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 8    : 	return ms_kPool.Alloc();

  00052	5e		 pop	 esi

; 9    : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN14@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00057	8d 4d fc	 lea	 ecx, DWORD PTR _pkNewData$2[ebp]
  0005a	51		 push	 ecx
  0005b	50		 push	 eax
  0005c	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+4
  00061	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectData@@@?$vector@PAVCEffectData@@V?$allocator@PAVCEffectData@@@std@@@std@@QAEPAPAVCEffectData@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectData *,std::allocator<CEffectData *> >::_Emplace_reallocate<CEffectData * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  00066	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+32
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 8    : 	return ms_kPool.Alloc();

  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi

; 9    : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN4@New:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00073	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1559 :         return _My_data._Mylast[-1];

  00076	83 c1 fc	 add	 ecx, -4			; fffffffcH

; 1338 :         --_Mylast;

  00079	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+20, ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 9    : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?New@CEffectData@@SAPAV1@XZ ENDP			; CEffectData::New
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?DestroySystem@CEffectData@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CEffectData@@SAXXZ PROC			; CEffectData::DestroySystem, COMDAT

; 18   : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+4
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 18   : {

  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 234  :     const auto _ULast = _Get_unwrapped(_Last);

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+8

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000e	3b f7		 cmp	 esi, edi
  00010	74 19		 je	 SHORT $LN19@DestroySys
$LL20@DestroySys:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 110  : 			delete pkData;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN18@DestroySys
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 01		 push	 1
  0001c	ff 10		 call	 DWORD PTR [eax]
$LN18@DestroySys:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001e	83 c6 04	 add	 esi, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL20@DestroySys
  00025	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+4
$LN19@DestroySys:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 52   : 			m_kVct_pkFree.clear();

  0002b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+16
  00030	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+8, esi
  00036	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectData@@2V?$CDynamicPool@VCEffectData@@@@A+20, eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 21   : 	CParticleSystemData::DestroySystem();

  0003b	e8 00 00 00 00	 call	 ?DestroySystem@CParticleSystemData@@SAXXZ ; CParticleSystemData::DestroySystem

; 22   : 	CEffectMeshScript::DestroySystem();

  00040	e8 00 00 00 00	 call	 ?DestroySystem@CEffectMeshScript@@SAXXZ ; CEffectMeshScript::DestroySystem

; 23   : 	CLightData::DestroySystem();

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	e9 00 00 00 00	 jmp	 ?DestroySystem@CLightData@@SAXXZ ; CLightData::DestroySystem
?DestroySystem@CEffectData@@SAXXZ ENDP			; CEffectData::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::~vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 07		 mov	 eax, DWORD PTR [edi]
  00005	85 c0		 test	 eax, eax
  00007	74 4d		 je	 SHORT $LN4@vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00009	57		 push	 edi
  0000a	ff 77 04	 push	 DWORD PTR [edi+4]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0001b	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0001d	f7 e9		 imul	 ecx
  0001f	03 d1		 add	 edx, ecx
  00021	c1 fa 04	 sar	 edx, 4
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00029	03 ca		 add	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002b	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00032	2b c1		 sub	 eax, ecx
  00034	c1 e0 02	 shl	 eax, 2
  00037	50		 push	 eax
  00038	ff 37		 push	 DWORD PTR [edi]
  0003a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0003f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00048	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  0004f	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  00056	5f		 pop	 edi

; 673  :         _Tidy();
; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00057	c3		 ret	 0
??1?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::~vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@CAXXZ PROC ; std::vector<CLightData *,std::allocator<CLightData *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@CAXXZ ENDP ; std::vector<CLightData *,std::allocator<CLightData *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@CAXXZ PROC ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@CAXXZ ENDP ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?AllocLight@CEffectData@@MAEPAVCLightData@@XZ
_TEXT	SEGMENT
_pLight$ = -4						; size = 4
?AllocLight@CEffectData@@MAEPAVCLightData@@XZ PROC	; CEffectData::AllocLight, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 126  : 	CLightData * pLight = CLightData::New();

  00008	e8 00 00 00 00	 call	 ?New@CLightData@@SAPAV1@XZ ; CLightData::New

; 127  : 	m_LightVector.push_back(pLight);

  0000d	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00010	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00012	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 126  : 	CLightData * pLight = CLightData::New();

  00015	89 7d fc	 mov	 DWORD PTR _pLight$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001b	74 0e		 je	 SHORT $LN6@AllocLight

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001d	89 38		 mov	 DWORD PTR [eax], edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 129  : }

  0001f	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00021	83 41 04 04	 add	 DWORD PTR [ecx+4], 4
  00025	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 129  : }

  00026	5e		 pop	 esi
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN6@AllocLight:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002b	8d 55 fc	 lea	 edx, DWORD PTR _pLight$[ebp]
  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCLightData@@@?$vector@PAVCLightData@@V?$allocator@PAVCLightData@@@std@@@std@@QAEPAPAVCLightData@@QAPAV2@ABQAV2@@Z ; std::vector<CLightData *,std::allocator<CLightData *> >::_Emplace_reallocate<CLightData * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 129  : }

  00035	8b c7		 mov	 eax, edi
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?AllocLight@CEffectData@@MAEPAVCLightData@@XZ ENDP	; CEffectData::AllocLight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?AllocMesh@CEffectData@@MAEPAVCEffectMeshScript@@XZ
_TEXT	SEGMENT
_pMesh$ = -4						; size = 4
?AllocMesh@CEffectData@@MAEPAVCEffectMeshScript@@XZ PROC ; CEffectData::AllocMesh, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 119  : 	CEffectMeshScript * pMesh = CEffectMeshScript::New();

  00008	e8 00 00 00 00	 call	 ?New@CEffectMeshScript@@SAPAV1@XZ ; CEffectMeshScript::New

; 120  : 	m_MeshVector.push_back(pMesh);

  0000d	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00010	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00012	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 119  : 	CEffectMeshScript * pMesh = CEffectMeshScript::New();

  00015	89 7d fc	 mov	 DWORD PTR _pMesh$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001b	74 0e		 je	 SHORT $LN6@AllocMesh

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001d	89 38		 mov	 DWORD PTR [eax], edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 122  : }

  0001f	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00021	83 41 04 04	 add	 DWORD PTR [ecx+4], 4
  00025	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 122  : }

  00026	5e		 pop	 esi
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN6@AllocMesh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002b	8d 55 fc	 lea	 edx, DWORD PTR _pMesh$[ebp]
  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@QAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 122  : }

  00035	8b c7		 mov	 eax, edi
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?AllocMesh@CEffectData@@MAEPAVCEffectMeshScript@@XZ ENDP ; CEffectData::AllocMesh
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?AllocParticle@CEffectData@@MAEPAVCParticleSystemData@@XZ
_TEXT	SEGMENT
_pParticle$ = -4					; size = 4
?AllocParticle@CEffectData@@MAEPAVCParticleSystemData@@XZ PROC ; CEffectData::AllocParticle, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 112  : 	CParticleSystemData * pParticle = CParticleSystemData::New();

  00008	e8 00 00 00 00	 call	 ?New@CParticleSystemData@@SAPAV1@XZ ; CParticleSystemData::New

; 113  : 	m_ParticleVector.push_back(pParticle);

  0000d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00010	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00012	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 112  : 	CParticleSystemData * pParticle = CParticleSystemData::New();

  00015	89 7d fc	 mov	 DWORD PTR _pParticle$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001b	74 0e		 je	 SHORT $LN6@AllocParti

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001d	89 38		 mov	 DWORD PTR [eax], edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 115  : }

  0001f	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00021	83 41 04 04	 add	 DWORD PTR [ecx+4], 4
  00025	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 115  : }

  00026	5e		 pop	 esi
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN6@AllocParti:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002b	8d 55 fc	 lea	 edx, DWORD PTR _pParticle$[ebp]
  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCParticleSystemData@@@?$vector@PAVCParticleSystemData@@V?$allocator@PAVCParticleSystemData@@@std@@@std@@QAEPAPAVCParticleSystemData@@QAPAV2@ABQAV2@@Z ; std::vector<CParticleSystemData *,std::allocator<CParticleSystemData *> >::_Emplace_reallocate<CParticleSystemData * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 115  : }

  00035	8b c7		 mov	 eax, edi
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?AllocParticle@CEffectData@@MAEPAVCParticleSystemData@@XZ ENDP ; CEffectData::AllocParticle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?__ClearMeshDataVector@CEffectData@@IAEXXZ
_TEXT	SEGMENT
?__ClearMeshDataVector@CEffectData@@IAEXXZ PROC		; CEffectData::__ClearMeshDataVector, COMDAT
; _this$ = ecx

; 200  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00005	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00008	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 1c		 je	 SHORT $LN24@ClearMeshD
  0000f	90		 npad	 1
$LL18@ClearMeshD:

; 236  :         _Func(*_UFirst);

  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ?Delete@CEffectMeshScript@@SAXPAV1@@Z ; CEffectMeshScript::Delete
  00017	83 c6 04	 add	 esi, 4
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b f3		 cmp	 esi, ebx
  0001f	75 ef		 jne	 SHORT $LL18@ClearMeshD
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 202  : 	m_MeshVector.clear();

  00021	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00024	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00027	5f		 pop	 edi

; 203  : }

  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	c3		 ret	 0
$LN24@ClearMeshD:

; 202  : 	m_MeshVector.clear();

  0002b	89 77 14	 mov	 DWORD PTR [edi+20], esi
  0002e	5f		 pop	 edi

; 203  : }

  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	c3		 ret	 0
?__ClearMeshDataVector@CEffectData@@IAEXXZ ENDP		; CEffectData::__ClearMeshDataVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?__ClearLightDataVector@CEffectData@@IAEXXZ
_TEXT	SEGMENT
?__ClearLightDataVector@CEffectData@@IAEXXZ PROC	; CEffectData::__ClearLightDataVector, COMDAT
; _this$ = ecx

; 194  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00005	8b 5f 20	 mov	 ebx, DWORD PTR [edi+32]
  00008	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 1c		 je	 SHORT $LN24@ClearLight
  0000f	90		 npad	 1
$LL18@ClearLight:

; 236  :         _Func(*_UFirst);

  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ?Delete@CLightData@@SAXPAV1@@Z ; CLightData::Delete
  00017	83 c6 04	 add	 esi, 4
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b f3		 cmp	 esi, ebx
  0001f	75 ef		 jne	 SHORT $LL18@ClearLight
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 196  : 	m_LightVector.clear();

  00021	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00024	89 47 20	 mov	 DWORD PTR [edi+32], eax
  00027	5f		 pop	 edi

; 197  : }

  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	c3		 ret	 0
$LN24@ClearLight:

; 196  : 	m_LightVector.clear();

  0002b	89 77 20	 mov	 DWORD PTR [edi+32], esi
  0002e	5f		 pop	 edi

; 197  : }

  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	c3		 ret	 0
?__ClearLightDataVector@CEffectData@@IAEXXZ ENDP	; CEffectData::__ClearLightDataVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?__ClearParticleDataVector@CEffectData@@IAEXXZ
_TEXT	SEGMENT
?__ClearParticleDataVector@CEffectData@@IAEXXZ PROC	; CEffectData::__ClearParticleDataVector, COMDAT
; _this$ = ecx

; 188  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00005	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  00008	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 1c		 je	 SHORT $LN24@ClearParti
  0000f	90		 npad	 1
$LL18@ClearParti:

; 236  :         _Func(*_UFirst);

  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ?Delete@CParticleSystemData@@SAXPAV1@@Z ; CParticleSystemData::Delete
  00017	83 c6 04	 add	 esi, 4
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b f3		 cmp	 esi, ebx
  0001f	75 ef		 jne	 SHORT $LL18@ClearParti
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 190  : 	m_ParticleVector.clear();

  00021	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00024	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00027	5f		 pop	 edi

; 191  : }

  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	c3		 ret	 0
$LN24@ClearParti:

; 190  : 	m_ParticleVector.clear();

  0002b	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002e	5f		 pop	 edi

; 191  : }

  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	c3		 ret	 0
?__ClearParticleDataVector@CEffectData@@IAEXXZ ENDP	; CEffectData::__ClearParticleDataVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetFileName@CEffectData@@QBEPBDXZ
_TEXT	SEGMENT
?GetFileName@CEffectData@@QBEPBDXZ PROC			; CEffectData::GetFileName, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00000	83 79 58 10	 cmp	 DWORD PTR [ecx+88], 16	; 00000010H

; 3668 :         return _Mypair._Myval2._Myptr();

  00004	8d 41 44	 lea	 eax, DWORD PTR [ecx+68]

; 2145 :         if (_Large_string_engaged()) {

  00007	72 02		 jb	 SHORT $LN6@GetFileNam
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 184  : 	return m_strFileName.c_str();

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN6@GetFileNam:

; 185  : }

  0000b	c3		 ret	 0
?GetFileName@CEffectData@@QBEPBDXZ ENDP			; CEffectData::GetFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetBoundingSpherePosition@CEffectData@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetBoundingSpherePosition@CEffectData@@QAE?AUD3DXVECTOR3@@XZ PROC ; CEffectData::GetBoundingSpherePosition, COMDAT
; _this$ = ecx

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 179  : 	return m_v3BoundingSpherePosition;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	f3 0f 7e 41 38	 movq	 xmm0, QWORD PTR [ecx+56]
  0000b	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  0000e	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 180  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?GetBoundingSpherePosition@CEffectData@@QAE?AUD3DXVECTOR3@@XZ ENDP ; CEffectData::GetBoundingSpherePosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetBoundingSphereRadius@CEffectData@@QAEMXZ
_TEXT	SEGMENT
?GetBoundingSphereRadius@CEffectData@@QAEMXZ PROC	; CEffectData::GetBoundingSphereRadius, COMDAT
; _this$ = ecx

; 174  : 	return m_fBoundingSphereRadius;

  00000	d9 41 34	 fld	 DWORD PTR [ecx+52]

; 175  : }

  00003	c3		 ret	 0
?GetBoundingSphereRadius@CEffectData@@QAEMXZ ENDP	; CEffectData::GetBoundingSphereRadius
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetSoundInstanceVector@CEffectData@@QAEPAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetSoundInstanceVector@CEffectData@@QAEPAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@XZ PROC ; CEffectData::GetSoundInstanceVector, COMDAT
; _this$ = ecx

; 169  : 	return &m_SoundInstanceVector;

  00000	8d 41 28	 lea	 eax, DWORD PTR [ecx+40]

; 170  : }

  00003	c3		 ret	 0
?GetSoundInstanceVector@CEffectData@@QAEPAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@XZ ENDP ; CEffectData::GetSoundInstanceVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetLightPointer@CEffectData@@QAEPAVCLightData@@K@Z
_TEXT	SEGMENT
_dwPosition$ = 8					; size = 4
?GetLightPointer@CEffectData@@QAEPAVCLightData@@K@Z PROC ; CEffectData::GetLightPointer, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 138  : 	assert(dwPosition < m_LightVector.size());
; 139  : 	return m_LightVector[dwPosition];

  00003	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00006	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  00009	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 140  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?GetLightPointer@CEffectData@@QAEPAVCLightData@@K@Z ENDP ; CEffectData::GetLightPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetLightCount@CEffectData@@QAEKXZ
_TEXT	SEGMENT
?GetLightCount@CEffectData@@QAEKXZ PROC			; CEffectData::GetLightCount, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	2b 41 1c	 sub	 eax, DWORD PTR [ecx+28]
  00006	c1 f8 02	 sar	 eax, 2
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 134  : }

  00009	c3		 ret	 0
?GetLightCount@CEffectData@@QAEKXZ ENDP			; CEffectData::GetLightCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetMeshPointer@CEffectData@@QAEPAVCEffectMeshScript@@K@Z
_TEXT	SEGMENT
_dwPosition$ = 8					; size = 4
?GetMeshPointer@CEffectData@@QAEPAVCEffectMeshScript@@K@Z PROC ; CEffectData::GetMeshPointer, COMDAT
; _this$ = ecx

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	assert(dwPosition < m_MeshVector.size());
; 164  : 	return m_MeshVector[dwPosition];

  00003	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  00009	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 165  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?GetMeshPointer@CEffectData@@QAEPAVCEffectMeshScript@@K@Z ENDP ; CEffectData::GetMeshPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetMeshCount@CEffectData@@QAEKXZ
_TEXT	SEGMENT
?GetMeshCount@CEffectData@@QAEKXZ PROC			; CEffectData::GetMeshCount, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  00006	c1 f8 02	 sar	 eax, 2
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 160  : }

  00009	c3		 ret	 0
?GetMeshCount@CEffectData@@QAEKXZ ENDP			; CEffectData::GetMeshCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetParticlePointer@CEffectData@@QAEPAVCParticleSystemData@@K@Z
_TEXT	SEGMENT
_dwPosition$ = 8					; size = 4
?GetParticlePointer@CEffectData@@QAEPAVCParticleSystemData@@K@Z PROC ; CEffectData::GetParticlePointer, COMDAT
; _this$ = ecx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 148  : 	if(dwPosition < m_ParticleVector.size())

  00009	8b 55 08	 mov	 edx, DWORD PTR _dwPosition$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000c	2b c8		 sub	 ecx, eax
  0000e	c1 f9 02	 sar	 ecx, 2
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 148  : 	if(dwPosition < m_ParticleVector.size())

  00011	3b d1		 cmp	 edx, ecx
  00013	73 07		 jae	 SHORT $LN2@GetParticl

; 149  : 		return m_ParticleVector[dwPosition];

  00015	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 154  : 	}
; 155  : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetParticl:

; 150  : 	else
; 151  : 	{
; 152  : 		assert(false);
; 153  : 		return NULL;

  0001c	33 c0		 xor	 eax, eax

; 154  : 	}
; 155  : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?GetParticlePointer@CEffectData@@QAEPAVCParticleSystemData@@K@Z ENDP ; CEffectData::GetParticlePointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?GetParticleCount@CEffectData@@QAEKXZ
_TEXT	SEGMENT
?GetParticleCount@CEffectData@@QAEKXZ PROC		; CEffectData::GetParticleCount, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 145  : }

  00009	c3		 ret	 0
?GetParticleCount@CEffectData@@QAEKXZ ENDP		; CEffectData::GetParticleCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z
_TEXT	SEGMENT
_SoundDataVector$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z PROC	; CEffectData::LoadSoundScriptData, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00029	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SoundDataVector$[ebp], 0
  00030	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _SoundDataVector$[ebp+4], 0
  00037	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _SoundDataVector$[ebp+8], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 101  : 	if (NSound::LoadSoundInformationPiece(c_szFileName, SoundDataVector))

  0003e	6a 00		 push	 0
  00040	8d 45 e8	 lea	 eax, DWORD PTR _SoundDataVector$[ebp]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	50		 push	 eax
  0004b	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0004e	e8 00 00 00 00	 call	 ?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z ; NSound::LoadSoundInformationPiece
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	84 c0		 test	 al, al
  00058	74 14		 je	 SHORT $LN2@LoadSoundS

; 102  : 	{
; 103  : 		NSound::DataToInstance(SoundDataVector, &m_SoundInstanceVector);

  0005a	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0005d	50		 push	 eax
  0005e	8d 45 e8	 lea	 eax, DWORD PTR _SoundDataVector$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z ; NSound::DataToInstance
  00067	83 c4 08	 add	 esp, 8
  0006a	32 db		 xor	 bl, bl
  0006c	eb 02		 jmp	 SHORT $LN5@LoadSoundS
$LN2@LoadSoundS:

; 104  : 		return false;
; 105  : 	}
; 106  : 
; 107  : 	return true;

  0006e	b3 01		 mov	 bl, 1
$LN5@LoadSoundS:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00070	8b 45 e8	 mov	 eax, DWORD PTR _SoundDataVector$[ebp]
  00073	85 c0		 test	 eax, eax
  00075	74 3e		 je	 SHORT $LN30@LoadSoundS

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00077	8d 4d e8	 lea	 ecx, DWORD PTR _SoundDataVector$[ebp]
  0007a	51		 push	 ecx
  0007b	ff 75 ec	 push	 DWORD PTR _SoundDataVector$[ebp+4]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00084	8b 4d f0	 mov	 ecx, DWORD PTR _SoundDataVector$[ebp+8]
  00087	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0008c	2b 4d e8	 sub	 ecx, DWORD PTR _SoundDataVector$[ebp]
  0008f	f7 e9		 imul	 ecx
  00091	03 d1		 add	 edx, ecx
  00093	c1 fa 04	 sar	 edx, 4
  00096	8b f2		 mov	 esi, edx
  00098	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0009b	03 f2		 add	 esi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0009d	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*8]
  000a4	2b ce		 sub	 ecx, esi
  000a6	c1 e1 02	 shl	 ecx, 2
  000a9	51		 push	 ecx
  000aa	ff 75 e8	 push	 DWORD PTR _SoundDataVector$[ebp]
  000ad	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000b2	83 c4 14	 add	 esp, 20			; 00000014H
$LN30@LoadSoundS:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 108  : }

  000b5	8a c3		 mov	 al, bl
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SoundDataVector$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::~vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z ENDP	; CEffectData::LoadSoundScriptData
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?LoadScript@CEffectData@@QAE_NPBD@Z
_TEXT	SEGMENT
$T2 = -252						; size = 4
tv2771 = -248						; size = 4
__Possible_matches_end$1$ = -244			; size = 4
_c_szFileName$GSCopy$1$ = -240				; size = 4
__Result$2$ = -240					; size = 4
_this$GSCopy$1$ = -236					; size = 4
__Result$2$ = -232					; size = 4
_nLength$1$ = -232					; size = 4
__New_array$3 = -232					; size = 4
__New_ptr$4 = -232					; size = 4
__New_ptr$5 = -232					; size = 4
_strNoExtensionName$1$ = -228				; size = 4
__Result$1$ = -228					; size = 4
_strNoExtensionName$2$ = -224				; size = 4
__Result$1$ = -224					; size = 4
_i$1$ = -224						; size = 4
tv2797 = -217						; size = 1
tv2795 = -217						; size = 1
$T6 = -217						; size = 1
_TextFileLoader$ = -216					; size = 128
_strPathHeader$ = -88					; size = 24
_strSoundFileName$7 = -64				; size = 24
$T8 = -64						; size = 24
$T9 = -64						; size = 24
_strNoExtensionName$ = -40				; size = 24
_strName$10 = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
?LoadScript@CEffectData@@QAE_NPBD@Z PROC		; CEffectData::LoadScript, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadScript@CEffectData@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 bd 14 ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00035	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00038	8b ce		 mov	 ecx, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 27   : {

  0003a	89 b5 10 ff ff
	ff		 mov	 DWORD PTR _c_szFileName$GSCopy$1$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00040	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL559@LoadScript:
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	41		 inc	 ecx
  00046	84 c0		 test	 al, al
  00048	75 f9		 jne	 SHORT $LL559@LoadScript
  0004a	2b ca		 sub	 ecx, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 28   : 	m_strFileName = c_szFileName;

  0004c	83 c7 44	 add	 edi, 68			; 00000044H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0004f	51		 push	 ecx
  00050	56		 push	 esi
  00051	8b cf		 mov	 ecx, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 28   : 	m_strFileName = c_szFileName;

  00053	89 bd 1c ff ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00059	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h

; 224  : 		size_t nLength = str.length();

  0005e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 225  : 
; 226  : 		for (size_t i = 0; i<nLength; ++i)

  00061	33 f6		 xor	 esi, esi
  00063	89 85 18 ff ff
	ff		 mov	 DWORD PTR _nLength$1$[ebp], eax
  00069	85 c0		 test	 eax, eax
  0006b	74 69		 je	 SHORT $LN34@LoadScript
  0006d	0f 1f 00	 npad	 3
$LL35@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2163 :         if (_Mysize <= _Off) {

  00070	39 77 10	 cmp	 DWORD PTR [edi+16], esi
  00073	0f 86 ba 07 00
	00		 jbe	 $LN524@LoadScript

; 2153 :         return _BUF_SIZE <= _Myres;

  00079	8b 47 14	 mov	 eax, DWORD PTR [edi+20]

; 2135 :         value_type* _Result = _Bx._Buf;

  0007c	8b cf		 mov	 ecx, edi

; 2136 :         if (_Large_string_engaged()) {

  0007e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00081	72 02		 jb	 SHORT $LN556@LoadScript

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00083	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN556@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h

; 228  : 			if (str.at(i) == '\\')

  00085	80 3c 31 5c	 cmp	 BYTE PTR [ecx+esi], 92	; 0000005cH
  00089	75 0f		 jne	 SHORT $LN36@LoadScript
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  0008b	8b cf		 mov	 ecx, edi

; 2136 :         if (_Large_string_engaged()) {

  0008d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00090	72 02		 jb	 SHORT $LN553@LoadScript

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00092	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN553@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h

; 229  : 				str.at(i) = '/';

  00094	c6 04 31 2f	 mov	 BYTE PTR [ecx+esi], 47	; 0000002fH
  00098	eb 33		 jmp	 SHORT $LN33@LoadScript
$LN36@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2136 :         if (_Large_string_engaged()) {

  0009a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009d	72 06		 jb	 SHORT $LN554@LoadScript

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  0009f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000a1	03 ce		 add	 ecx, esi
  000a3	eb 0b		 jmp	 SHORT $LN558@LoadScript
$LN554@LoadScript:

; 3578 :         return _Mypair._Myval2._Myptr()[_Off];

  000a5	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]

; 2135 :         value_type* _Result = _Bx._Buf;

  000a8	89 bd 20 ff ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edi

; 2136 :         if (_Large_string_engaged()) {

  000ae	72 08		 jb	 SHORT $LN555@LoadScript
$LN558@LoadScript:

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  000b0	8b 07		 mov	 eax, DWORD PTR [edi]
  000b2	89 85 20 ff ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN555@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h

; 231  : 				str.at(i) = (char)tolower(str.at(i));

  000b8	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _tolower
  000c1	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR __Result$1$[ebp]
  000c7	83 c4 04	 add	 esp, 4
  000ca	88 04 31	 mov	 BYTE PTR [ecx+esi], al
$LN33@LoadScript:

; 225  : 
; 226  : 		for (size_t i = 0; i<nLength; ++i)

  000cd	46		 inc	 esi
  000ce	3b b5 18 ff ff
	ff		 cmp	 esi, DWORD PTR _nLength$1$[ebp]
  000d4	72 9a		 jb	 SHORT $LL35@LoadScript
$LN34@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 31   : 	CTextFileLoader TextFileLoader;

  000d6	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  000dc	e8 00 00 00 00	 call	 ??0CTextFileLoader@@QAE@XZ ; CTextFileLoader::CTextFileLoader

; 32   : 	if (!TextFileLoader.Load(c_szFileName))

  000e1	ff b5 10 ff ff
	ff		 push	 DWORD PTR _c_szFileName$GSCopy$1$[ebp]
  000e7	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  000ed	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000f4	e8 00 00 00 00	 call	 ?Load@CTextFileLoader@@QAE_NPBD@Z ; CTextFileLoader::Load
  000f9	84 c0		 test	 al, al
  000fb	75 0b		 jne	 SHORT $LN5@LoadScript
  000fd	88 85 27 ff ff
	ff		 mov	 BYTE PTR $T6[ebp], al
  00103	e9 60 06 00 00	 jmp	 $LN514@LoadScript
$LN5@LoadScript:

; 33   : 		return false;
; 34   : 
; 35   : 	TextFileLoader.SetTop();

  00108	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  0010e	e8 00 00 00 00	 call	 ?SetTop@CTextFileLoader@@QAEXXZ ; CTextFileLoader::SetTop
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00113	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00115	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T9[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0011c	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00123	c6 45 c0 00	 mov	 BYTE PTR $T9[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00127	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0012c	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BF@MLNDGKC@boundingsphereradius@

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00133	8b c8		 mov	 ecx, eax

; 4229 :         _Mypair._Myval2._Orphan_all();
; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  00135	c7 45 d0 14 00
	00 00		 mov	 DWORD PTR $T9[ebp+16], 20 ; 00000014H

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  0013c	c7 45 d4 1f 00
	00 00		 mov	 DWORD PTR $T9[ebp+20], 31 ; 0000001fH
  00143	89 8d 18 ff ff
	ff		 mov	 DWORD PTR __New_ptr$5[ebp], ecx

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00149	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0014c	a1 10 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BF@MLNDGKC@boundingsphereradius@+16
  00151	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00154	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR __New_ptr$5[ebp]
  0015a	50		 push	 eax
  0015b	8d 45 c0	 lea	 eax, DWORD PTR $T9[ebp]

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0015e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 37   : 	if (!TextFileLoader.GetTokenFloat("boundingsphereradius", &m_fBoundingSphereRadius))

  0016b	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00171	8d 45 c0	 lea	 eax, DWORD PTR $T9[ebp]
  00174	83 c6 34	 add	 esi, 52			; 00000034H
  00177	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0017b	56		 push	 esi
  0017c	50		 push	 eax
  0017d	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00183	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  00188	85 c0		 test	 eax, eax
  0018a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0018e	8b 45 d4	 mov	 eax, DWORD PTR $T9[ebp+20]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 37   : 	if (!TextFileLoader.GetTokenFloat("boundingsphereradius", &m_fBoundingSphereRadius))

  00191	0f 94 85 27 ff
	ff ff		 sete	 BYTE PTR tv2797[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00198	83 f8 10	 cmp	 eax, 16			; 00000010H
  0019b	72 0d		 jb	 SHORT $LN135@LoadScript

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0019d	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0019e	50		 push	 eax
  0019f	ff 75 c0	 push	 DWORD PTR $T9[ebp]
  001a2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  001a7	83 c4 08	 add	 esp, 8
$LN135@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 37   : 	if (!TextFileLoader.GetTokenFloat("boundingsphereradius", &m_fBoundingSphereRadius))

  001aa	80 bd 27 ff ff
	ff 00		 cmp	 BYTE PTR tv2797[ebp], 0
  001b1	74 06		 je	 SHORT $LN6@LoadScript

; 38   : 	{
; 39   : 		m_fBoundingSphereRadius = 0.0f;

  001b3	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  001b9	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  001bb	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  001c2	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T8[ebp+20], 15 ; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  001c9	c6 45 c0 00	 mov	 BYTE PTR $T8[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  001cd	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  001d2	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BH@HALPILME@boundingsphereposition@

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  001d9	8b c8		 mov	 ecx, eax

; 4229 :         _Mypair._Myval2._Orphan_all();
; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  001db	c7 45 d0 16 00
	00 00		 mov	 DWORD PTR $T8[ebp+16], 22 ; 00000016H

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  001e2	c7 45 d4 1f 00
	00 00		 mov	 DWORD PTR $T8[ebp+20], 31 ; 0000001fH
  001e9	89 8d 18 ff ff
	ff		 mov	 DWORD PTR __New_ptr$4[ebp], ecx

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  001ef	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  001f2	a1 10 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BH@HALPILME@boundingsphereposition@+16
  001f7	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  001fa	66 a1 14 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BH@HALPILME@boundingsphereposition@+20
  00200	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00204	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR __New_ptr$4[ebp]
  0020a	50		 push	 eax
  0020b	8d 45 c0	 lea	 eax, DWORD PTR $T8[ebp]

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0020e	c6 41 16 00	 mov	 BYTE PTR [ecx+22], 0

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 42   : 	if (!TextFileLoader.GetTokenVector3("boundingsphereposition", &m_v3BoundingSpherePosition))

  0021b	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00221	8d 45 c0	 lea	 eax, DWORD PTR $T8[ebp]
  00224	83 c6 38	 add	 esi, 56			; 00000038H
  00227	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0022b	56		 push	 esi
  0022c	50		 push	 eax
  0022d	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00233	e8 00 00 00 00	 call	 ?GetTokenVector3@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXVECTOR3@@@Z ; CTextFileLoader::GetTokenVector3
  00238	85 c0		 test	 eax, eax
  0023a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0023e	8b 45 d4	 mov	 eax, DWORD PTR $T8[ebp+20]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 42   : 	if (!TextFileLoader.GetTokenVector3("boundingsphereposition", &m_v3BoundingSpherePosition))

  00241	0f 94 85 27 ff
	ff ff		 sete	 BYTE PTR tv2795[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00248	83 f8 10	 cmp	 eax, 16			; 00000010H
  0024b	72 0d		 jb	 SHORT $LN191@LoadScript

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0024d	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0024e	50		 push	 eax
  0024f	ff 75 c0	 push	 DWORD PTR $T8[ebp]
  00252	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00257	83 c4 08	 add	 esp, 8
$LN191@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 42   : 	if (!TextFileLoader.GetTokenVector3("boundingsphereposition", &m_v3BoundingSpherePosition))

  0025a	80 bd 27 ff ff
	ff 00		 cmp	 BYTE PTR tv2795[ebp], 0
  00261	74 1a		 je	 SHORT $LN7@LoadScript

; 43   : 	{
; 44   : 		m_v3BoundingSpherePosition.x = m_v3BoundingSpherePosition.y = m_v3BoundingSpherePosition.z = 0.0f;

  00263	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00269	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0026f	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0
  00276	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN7@LoadScript:

; 47   : 	for (DWORD i = 0; i < TextFileLoader.GetChildNodeCount(); ++i)

  0027d	33 f6		 xor	 esi, esi
  0027f	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00285	89 b5 20 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  0028b	e8 00 00 00 00	 call	 ?GetChildNodeCount@CTextFileLoader@@QAEKXZ ; CTextFileLoader::GetChildNodeCount
  00290	85 c0		 test	 eax, eax
  00292	0f 84 5a 02 00
	00		 je	 $LN3@LoadScript
  00298	8b bd 14 ff ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  0029e	66 90		 npad	 2
$LL4@LoadScript:

; 48   : 	{
; 49   : 		if (!TextFileLoader.SetChildNode(i))

  002a0	56		 push	 esi
  002a1	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  002a7	e8 00 00 00 00	 call	 ?SetChildNode@CTextFileLoader@@QAEHK@Z ; CTextFileLoader::SetChildNode
  002ac	85 c0		 test	 eax, eax
  002ae	0f 84 1e 02 00
	00		 je	 $LN2@LoadScript
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  002b4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strName$10[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  002bb	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strName$10[ebp+20], 15 ; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  002c2	c6 45 d8 00	 mov	 BYTE PTR _strName$10[ebp], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 54   : 		if (!TextFileLoader.GetCurrentNodeName(&strName))

  002c6	8d 45 d8	 lea	 eax, DWORD PTR _strName$10[ebp]
  002c9	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  002cd	50		 push	 eax
  002ce	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  002d4	e8 00 00 00 00	 call	 ?GetCurrentNodeName@CTextFileLoader@@QAEHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CTextFileLoader::GetCurrentNodeName
  002d9	85 c0		 test	 eax, eax
  002db	75 21		 jne	 SHORT $LN9@LoadScript

; 55   : 			continue;

  002dd	88 45 fc	 mov	 BYTE PTR __$EHRec$[ebp+8], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002e0	8b 45 ec	 mov	 eax, DWORD PTR _strName$10[ebp+20]
  002e3	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e6	0f 82 e6 01 00
	00		 jb	 $LN2@LoadScript

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  002ec	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002ed	50		 push	 eax
  002ee	ff 75 d8	 push	 DWORD PTR _strName$10[ebp]
  002f1	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  002f6	83 c4 08	 add	 esp, 8
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 55   : 			continue;

  002f9	e9 d4 01 00 00	 jmp	 $LN2@LoadScript
$LN9@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  002fe	83 7d ec 10	 cmp	 DWORD PTR _strName$10[ebp+20], 16 ; 00000010H
  00302	8d 4d d8	 lea	 ecx, DWORD PTR _strName$10[ebp]

; 511  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00305	8b 75 e8	 mov	 esi, DWORD PTR _strName$10[ebp+16]
  00308	b8 04 00 00 00	 mov	 eax, 4

; 2145 :         if (_Large_string_engaged()) {

  0030d	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _strName$10[ebp]

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

  00311	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04KPBEILIJ@mesh@

; 511  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00316	83 fe 04	 cmp	 esi, 4
  00319	0f 47 f0	 cmova	 esi, eax

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

  0031c	2b f0		 sub	 esi, eax
  0031e	72 11		 jb	 SHORT $LN562@LoadScript
$LL563@LoadScript:
  00320	8b 01		 mov	 eax, DWORD PTR [ecx]
  00322	3b 02		 cmp	 eax, DWORD PTR [edx]
  00324	75 10		 jne	 SHORT $LN561@LoadScript
  00326	83 c1 04	 add	 ecx, 4
  00329	83 c2 04	 add	 edx, 4
  0032c	83 ee 04	 sub	 esi, 4
  0032f	73 ef		 jae	 SHORT $LL563@LoadScript
$LN562@LoadScript:
  00331	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00334	74 34		 je	 SHORT $LN560@LoadScript
$LN561@LoadScript:
  00336	8a 01		 mov	 al, BYTE PTR [ecx]
  00338	3a 02		 cmp	 al, BYTE PTR [edx]
  0033a	75 27		 jne	 SHORT $LN564@LoadScript
  0033c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0033f	74 29		 je	 SHORT $LN560@LoadScript
  00341	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00344	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00347	75 1a		 jne	 SHORT $LN564@LoadScript
  00349	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0034c	74 1c		 je	 SHORT $LN560@LoadScript
  0034e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00351	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00354	75 0d		 jne	 SHORT $LN564@LoadScript
  00356	83 fe ff	 cmp	 esi, -1
  00359	74 0f		 je	 SHORT $LN560@LoadScript
  0035b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0035e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00361	74 07		 je	 SHORT $LN560@LoadScript
$LN564@LoadScript:
  00363	1b c0		 sbb	 eax, eax
  00365	83 c8 01	 or	 eax, 1
  00368	eb 02		 jmp	 SHORT $LN565@LoadScript
$LN560@LoadScript:
  0036a	33 c0		 xor	 eax, eax
$LN565@LoadScript:

; 513  :     if (_Ans != 0) {

  0036c	85 c0		 test	 eax, eax
  0036e	8b 45 e8	 mov	 eax, DWORD PTR _strName$10[ebp+16]
  00371	75 11		 jne	 SHORT $LN10@LoadScript

; 514  :         return _Ans;
; 515  :     }
; 516  : 
; 517  :     if (_Left_size < _Right_size) {

  00373	83 f8 04	 cmp	 eax, 4
  00376	72 0c		 jb	 SHORT $LN10@LoadScript

; 518  :         return -1;
; 519  :     }
; 520  : 
; 521  :     if (_Left_size > _Right_size) {

  00378	77 0a		 ja	 SHORT $LN10@LoadScript
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 59   : 			CEffectMeshScript * pMesh = AllocMesh();

  0037a	8b 07		 mov	 eax, DWORD PTR [edi]
  0037c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 60   : 			pMesh->Clear();
; 61   : 			pMesh->LoadScript(TextFileLoader);

  0037f	e9 09 01 00 00	 jmp	 $LN597@LoadScript
$LN10@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  00384	83 7d ec 10	 cmp	 DWORD PTR _strName$10[ebp+20], 16 ; 00000010H
  00388	8d 4d d8	 lea	 ecx, DWORD PTR _strName$10[ebp]

; 511  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  0038b	8b f0		 mov	 esi, eax

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

  0038d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08PKKGOGAD@particle@

; 2145 :         if (_Large_string_engaged()) {

  00392	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _strName$10[ebp]

; 511  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00396	83 f8 08	 cmp	 eax, 8
  00399	b8 08 00 00 00	 mov	 eax, 8
  0039e	0f 47 f0	 cmova	 esi, eax

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

  003a1	83 ee 04	 sub	 esi, 4
  003a4	72 11		 jb	 SHORT $LN568@LoadScript
$LL569@LoadScript:
  003a6	8b 01		 mov	 eax, DWORD PTR [ecx]
  003a8	3b 02		 cmp	 eax, DWORD PTR [edx]
  003aa	75 10		 jne	 SHORT $LN567@LoadScript
  003ac	83 c1 04	 add	 ecx, 4
  003af	83 c2 04	 add	 edx, 4
  003b2	83 ee 04	 sub	 esi, 4
  003b5	73 ef		 jae	 SHORT $LL569@LoadScript
$LN568@LoadScript:
  003b7	83 fe fc	 cmp	 esi, -4			; fffffffcH
  003ba	74 34		 je	 SHORT $LN566@LoadScript
$LN567@LoadScript:
  003bc	8a 01		 mov	 al, BYTE PTR [ecx]
  003be	3a 02		 cmp	 al, BYTE PTR [edx]
  003c0	75 27		 jne	 SHORT $LN570@LoadScript
  003c2	83 fe fd	 cmp	 esi, -3			; fffffffdH
  003c5	74 29		 je	 SHORT $LN566@LoadScript
  003c7	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  003ca	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  003cd	75 1a		 jne	 SHORT $LN570@LoadScript
  003cf	83 fe fe	 cmp	 esi, -2			; fffffffeH
  003d2	74 1c		 je	 SHORT $LN566@LoadScript
  003d4	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  003d7	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  003da	75 0d		 jne	 SHORT $LN570@LoadScript
  003dc	83 fe ff	 cmp	 esi, -1
  003df	74 0f		 je	 SHORT $LN566@LoadScript
  003e1	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  003e4	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  003e7	74 07		 je	 SHORT $LN566@LoadScript
$LN570@LoadScript:
  003e9	1b c0		 sbb	 eax, eax
  003eb	83 c8 01	 or	 eax, 1
  003ee	eb 02		 jmp	 SHORT $LN571@LoadScript
$LN566@LoadScript:
  003f0	33 c0		 xor	 eax, eax
$LN571@LoadScript:

; 513  :     if (_Ans != 0) {

  003f2	85 c0		 test	 eax, eax
  003f4	8b 45 e8	 mov	 eax, DWORD PTR _strName$10[ebp+16]
  003f7	75 11		 jne	 SHORT $LN12@LoadScript

; 514  :         return _Ans;
; 515  :     }
; 516  : 
; 517  :     if (_Left_size < _Right_size) {

  003f9	83 f8 08	 cmp	 eax, 8
  003fc	72 0c		 jb	 SHORT $LN12@LoadScript

; 518  :         return -1;
; 519  :     }
; 520  : 
; 521  :     if (_Left_size > _Right_size) {

  003fe	77 0a		 ja	 SHORT $LN12@LoadScript
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 65   : 			CParticleSystemData * pParticleSystemData = AllocParticle();

  00400	8b 07		 mov	 eax, DWORD PTR [edi]
  00402	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 66   : 			pParticleSystemData->Clear();
; 67   : 			pParticleSystemData->LoadScript(TextFileLoader);
; 68   : 		}

  00405	e9 83 00 00 00	 jmp	 $LN597@LoadScript
$LN12@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  0040a	83 7d ec 10	 cmp	 DWORD PTR _strName$10[ebp+20], 16 ; 00000010H
  0040e	8d 4d d8	 lea	 ecx, DWORD PTR _strName$10[ebp]

; 511  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00411	8b f0		 mov	 esi, eax

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

  00413	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05OEPGNJB@light@

; 2145 :         if (_Large_string_engaged()) {

  00418	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _strName$10[ebp]

; 511  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  0041c	83 f8 05	 cmp	 eax, 5
  0041f	b8 05 00 00 00	 mov	 eax, 5
  00424	0f 47 f0	 cmova	 esi, eax

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

  00427	83 ee 04	 sub	 esi, 4
  0042a	72 15		 jb	 SHORT $LN574@LoadScript
  0042c	0f 1f 40 00	 npad	 4
$LL575@LoadScript:
  00430	8b 01		 mov	 eax, DWORD PTR [ecx]
  00432	3b 02		 cmp	 eax, DWORD PTR [edx]
  00434	75 10		 jne	 SHORT $LN573@LoadScript
  00436	83 c1 04	 add	 ecx, 4
  00439	83 c2 04	 add	 edx, 4
  0043c	83 ee 04	 sub	 esi, 4
  0043f	73 ef		 jae	 SHORT $LL575@LoadScript
$LN574@LoadScript:
  00441	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00444	74 34		 je	 SHORT $LN572@LoadScript
$LN573@LoadScript:
  00446	8a 01		 mov	 al, BYTE PTR [ecx]
  00448	3a 02		 cmp	 al, BYTE PTR [edx]
  0044a	75 27		 jne	 SHORT $LN576@LoadScript
  0044c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0044f	74 29		 je	 SHORT $LN572@LoadScript
  00451	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00454	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00457	75 1a		 jne	 SHORT $LN576@LoadScript
  00459	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0045c	74 1c		 je	 SHORT $LN572@LoadScript
  0045e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00461	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00464	75 0d		 jne	 SHORT $LN576@LoadScript
  00466	83 fe ff	 cmp	 esi, -1
  00469	74 0f		 je	 SHORT $LN572@LoadScript
  0046b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0046e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00471	74 07		 je	 SHORT $LN572@LoadScript
$LN576@LoadScript:
  00473	1b c0		 sbb	 eax, eax
  00475	83 c8 01	 or	 eax, 1
  00478	eb 02		 jmp	 SHORT $LN577@LoadScript
$LN572@LoadScript:
  0047a	33 c0		 xor	 eax, eax
$LN577@LoadScript:

; 513  :     if (_Ans != 0) {

  0047c	85 c0		 test	 eax, eax
  0047e	75 28		 jne	 SHORT $LN14@LoadScript

; 514  :         return _Ans;
; 515  :     }
; 516  : 
; 517  :     if (_Left_size < _Right_size) {

  00480	83 7d e8 05	 cmp	 DWORD PTR _strName$10[ebp+16], 5
  00484	72 22		 jb	 SHORT $LN14@LoadScript

; 518  :         return -1;
; 519  :     }
; 520  : 
; 521  :     if (_Left_size > _Right_size) {

  00486	77 20		 ja	 SHORT $LN14@LoadScript
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 71   : 			CLightData * pLightData = AllocLight();

  00488	8b 07		 mov	 eax, DWORD PTR [edi]
  0048a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
$LN597@LoadScript:

; 72   : 			pLightData->Clear();
; 73   : 			pLightData->LoadScript(TextFileLoader);
; 74   : 		}
; 75   : 
; 76   : 		TextFileLoader.SetParentNode();

  0048d	8b cf		 mov	 ecx, edi
  0048f	ff d0		 call	 eax
  00491	8b f0		 mov	 esi, eax
  00493	8b ce		 mov	 ecx, esi
  00495	e8 00 00 00 00	 call	 ?Clear@CEffectElementBase@@QAEXXZ ; CEffectElementBase::Clear
  0049a	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _TextFileLoader$[ebp]
  004a0	8b ce		 mov	 ecx, esi
  004a2	50		 push	 eax
  004a3	e8 00 00 00 00	 call	 ?LoadScript@CEffectElementBase@@QAEHAAVCTextFileLoader@@@Z ; CEffectElementBase::LoadScript
$LN14@LoadScript:
  004a8	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  004ae	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004b3	8b 45 ec	 mov	 eax, DWORD PTR _strName$10[ebp+20]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 77   : 	}

  004b6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004ba	83 f8 10	 cmp	 eax, 16			; 00000010H
  004bd	72 0d		 jb	 SHORT $LN594@LoadScript

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  004bf	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004c0	50		 push	 eax
  004c1	ff 75 d8	 push	 DWORD PTR _strName$10[ebp]
  004c4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  004c9	83 c4 08	 add	 esp, 8
$LN594@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 47   : 	for (DWORD i = 0; i < TextFileLoader.GetChildNodeCount(); ++i)

  004cc	8b b5 20 ff ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
$LN2@LoadScript:
  004d2	46		 inc	 esi
  004d3	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  004d9	89 b5 20 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  004df	e8 00 00 00 00	 call	 ?GetChildNodeCount@CTextFileLoader@@QAEKXZ ; CTextFileLoader::GetChildNodeCount
  004e4	3b f0		 cmp	 esi, eax
  004e6	0f 82 b4 fd ff
	ff		 jb	 $LL4@LoadScript
  004ec	8b bd 1c ff ff
	ff		 mov	 edi, DWORD PTR __Result$1$[ebp]
$LN3@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  004f2	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@+8
  004f7	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@
  004ff	89 45 b0	 mov	 DWORD PTR _strPathHeader$[ebp+8], eax
  00502	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@+12

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00507	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strPathHeader$[ebp+20], 15 ; 0000000fH

; 2968 :             _Mypair._Myval2._Mysize = _Count;

  0050e	c7 45 b8 0d 00
	00 00		 mov	 DWORD PTR _strPathHeader$[ebp+16], 13 ; 0000000dH

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00515	66 0f d6 45 a8	 movq	 QWORD PTR _strPathHeader$[ebp], xmm0
  0051a	88 45 b4	 mov	 BYTE PTR _strPathHeader$[ebp+12], al

; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0051d	c6 45 b5 00	 mov	 BYTE PTR _strPathHeader$[ebp+13], 0

; 2153 :         return _BUF_SIZE <= _Myres;

  00521	8b 77 14	 mov	 esi, DWORD PTR [edi+20]

; 2144 :         const value_type* _Result = _Bx._Buf;

  00524	8b d7		 mov	 edx, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 80   : 	std::string strPathHeader = "d:/ymir work/";

  00526	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  0052a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0052d	72 02		 jb	 SHORT $LN557@LoadScript

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0052f	8b 17		 mov	 edx, DWORD PTR [edi]
$LN557@LoadScript:

; 3997 :         return static_cast<size_type>(

  00531	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00534	89 85 1c ff ff
	ff		 mov	 DWORD PTR _strNoExtensionName$1$[ebp], eax

; 604  :     if (_Hay_size != 0) { // room for match, look for it

  0053a	85 c0		 test	 eax, eax
  0053c	74 70		 je	 SHORT $LN327@LoadScript

; 605  :         for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {

  0053e	83 c9 ff	 or	 ecx, -1
  00541	48		 dec	 eax
  00542	3b c1		 cmp	 eax, ecx
  00544	0f 42 c8	 cmovb	 ecx, eax
  00547	03 ca		 add	 ecx, edx

; 606  :             if (_Traits::eq(*_Match_try, _Ch)) {

  00549	80 39 2e	 cmp	 BYTE PTR [ecx], 46	; 0000002eH
  0054c	74 0c		 je	 SHORT $LN528@LoadScript
  0054e	66 90		 npad	 2
$LL341@LoadScript:

; 608  :             }
; 609  : 
; 610  :             if (_Match_try == _Haystack) {

  00550	3b ca		 cmp	 ecx, edx
  00552	74 54		 je	 SHORT $LN593@LoadScript

; 606  :             if (_Traits::eq(*_Match_try, _Ch)) {

  00554	49		 dec	 ecx
  00555	80 39 2e	 cmp	 BYTE PTR [ecx], 46	; 0000002eH
  00558	75 f6		 jne	 SHORT $LL341@LoadScript
$LN528@LoadScript:

; 607  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  0055a	2b ca		 sub	 ecx, edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h

; 335  : 	if (string::npos != npos)

  0055c	83 f9 ff	 cmp	 ecx, -1
  0055f	74 47		 je	 SHORT $LN593@LoadScript
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2174 :         return (_STD min)(_Size, _Mysize - _Off);

  00561	39 8d 1c ff ff
	ff		 cmp	 DWORD PTR _strNoExtensionName$1$[ebp], ecx

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00567	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strNoExtensionName$[ebp+16], 0

; 2174 :         return (_STD min)(_Size, _Mysize - _Off);

  0056e	0f 42 8d 1c ff
	ff ff		 cmovb	 ecx, DWORD PTR _strNoExtensionName$1$[ebp]

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00575	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strNoExtensionName$[ebp+20], 15 ; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0057c	c6 45 d8 00	 mov	 BYTE PTR _strNoExtensionName$[ebp], 0

; 2145 :         if (_Large_string_engaged()) {

  00580	83 fe 10	 cmp	 esi, 16			; 00000010H
  00583	72 02		 jb	 SHORT $LN369@LoadScript

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00585	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN369@LoadScript:

; 2946 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00587	51		 push	 ecx
  00588	57		 push	 edi
  00589	8d 4d d8	 lea	 ecx, DWORD PTR _strNoExtensionName$[ebp]
  0058c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterBase\filename.h

; 336  : 		return std::string(str, 0, npos);

  00591	8b 55 ec	 mov	 edx, DWORD PTR _strNoExtensionName$[ebp+20]
  00594	8b 7d e8	 mov	 edi, DWORD PTR _strNoExtensionName$[ebp+16]
  00597	89 95 20 ff ff
	ff		 mov	 DWORD PTR _strNoExtensionName$2$[ebp], edx
  0059d	89 bd 1c ff ff
	ff		 mov	 DWORD PTR _strNoExtensionName$1$[ebp], edi
  005a3	e9 96 00 00 00	 jmp	 $LN381@LoadScript
$LN593@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  005a8	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _strNoExtensionName$1$[ebp]
$LN327@LoadScript:
  005ae	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strNoExtensionName$[ebp+16], 0
  005b5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _strNoExtensionName$[ebp+20], 0

; 2145 :         if (_Large_string_engaged()) {

  005bc	83 fe 10	 cmp	 esi, 16			; 00000010H
  005bf	72 02		 jb	 SHORT $LN385@LoadScript

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  005c1	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN385@LoadScript:

; 2659 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  005c3	83 f8 10	 cmp	 eax, 16			; 00000010H
  005c6	73 14		 jae	 SHORT $LN382@LoadScript

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  005c8	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]

; 2662 :             _My_data._Myres  = _BUF_SIZE - 1;

  005cb	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  005d0	89 95 20 ff ff
	ff		 mov	 DWORD PTR _strNoExtensionName$2$[ebp], edx

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  005d6	0f 11 45 d8	 movups	 XMMWORD PTR _strNoExtensionName$[ebp], xmm0

; 2663 :             return;

  005da	eb 56		 jmp	 SHORT $LN598@LoadScript
$LN382@LoadScript:

; 2664 :         }
; 2665 : 
; 2666 :         auto& _Al                     = _Getal();
; 2667 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  005dc	83 c8 0f	 or	 eax, 15			; 0000000fH
  005df	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  005e4	3b c1		 cmp	 eax, ecx
  005e6	0f 47 c1	 cmova	 eax, ecx
  005e9	89 85 20 ff ff
	ff		 mov	 DWORD PTR _strNoExtensionName$2$[ebp], eax

; 2668 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  005ef	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  005f0	50		 push	 eax
  005f1	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2668 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  005f6	8b f0		 mov	 esi, eax

; 2669 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  005f8	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR __New_array$3[ebp]
  005fe	50		 push	 eax
  005ff	8d 45 d8	 lea	 eax, DWORD PTR _strNoExtensionName$[ebp]
  00602	89 b5 18 ff ff
	ff		 mov	 DWORD PTR __New_array$3[ebp], esi
  00608	50		 push	 eax
  00609	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2670 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  0060e	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _strNoExtensionName$1$[ebp]
  00614	40		 inc	 eax

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00615	50		 push	 eax
  00616	57		 push	 edi
  00617	56		 push	 esi
  00618	e8 00 00 00 00	 call	 _memcpy

; 2671 :         _My_data._Mysize = _Right_size;

  0061d	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _strNoExtensionName$1$[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00623	83 c4 18	 add	 esp, 24			; 00000018H

; 2672 :         _My_data._Myres  = _New_capacity;

  00626	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _strNoExtensionName$2$[ebp]
  0062c	89 85 1c ff ff
	ff		 mov	 DWORD PTR _strNoExtensionName$1$[ebp], eax
$LN598@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 81   : 	std::string strNoExtensionName = CFileNameHelper::NoExtension(m_strFileName);

  00632	8b bd 1c ff ff
	ff		 mov	 edi, DWORD PTR _strNoExtensionName$1$[ebp]
  00638	89 55 ec	 mov	 DWORD PTR _strNoExtensionName$[ebp+20], edx
  0063b	89 45 e8	 mov	 DWORD PTR _strNoExtensionName$[ebp+16], eax
$LN381@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2144 :         const value_type* _Result = _Bx._Buf;

  0063e	8d 45 a8	 lea	 eax, DWORD PTR _strPathHeader$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 81   : 	std::string strNoExtensionName = CFileNameHelper::NoExtension(m_strFileName);

  00641	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00645	8b f0		 mov	 esi, eax

; 2145 :         if (_Large_string_engaged()) {

  00647	89 85 10 ff ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0064d	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL578@LoadScript:
  00650	8a 06		 mov	 al, BYTE PTR [esi]
  00652	46		 inc	 esi
  00653	84 c0		 test	 al, al
  00655	75 f9		 jne	 SHORT $LL578@LoadScript
  00657	2b f1		 sub	 esi, ecx

; 2144 :         const value_type* _Result = _Bx._Buf;

  00659	8d 45 d8	 lea	 eax, DWORD PTR _strNoExtensionName$[ebp]

; 2145 :         if (_Large_string_engaged()) {

  0065c	8b 4d d8	 mov	 ecx, DWORD PTR _strNoExtensionName$[ebp]
  0065f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00662	89 b5 04 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], esi

; 2145 :         if (_Large_string_engaged()) {

  00668	0f 43 c1	 cmovae	 eax, ecx
  0066b	89 85 18 ff ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 533  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00671	3b f7		 cmp	 esi, edi
  00673	0f 87 d0 00 00
	00		 ja	 $LN591@LoadScript

; 534  :         // xpos cannot exist, report failure
; 535  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 536  :         // 1. _Start_at <= xpos
; 537  :         // 2. xpos + _Needle_size <= _Hay_size;
; 538  :         // therefore:
; 539  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 540  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 541  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 542  :         return static_cast<size_t>(-1);
; 543  :     }
; 544  : 
; 545  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00679	85 f6		 test	 esi, esi
  0067b	0f 84 2c 01 00
	00		 je	 $LN552@LoadScript

; 546  :         return _Start_at;
; 547  :     }
; 548  : 
; 549  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00681	2b c6		 sub	 eax, esi
  00683	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00686	03 c8		 add	 ecx, eax

; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  00688	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Result$2$[ebp]

; 549  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0068e	89 8d 0c ff ff
	ff		 mov	 DWORD PTR __Possible_matches_end$1$[ebp], ecx

; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  00694	0f be 10	 movsx	 edx, BYTE PTR [eax]

; 551  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00697	8b c1		 mov	 eax, ecx
  00699	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR __Result$2$[ebp]
  0069f	2b c1		 sub	 eax, ecx

; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  006a1	50		 push	 eax
  006a2	52		 push	 edx
  006a3	51		 push	 ecx
  006a4	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv2771[ebp], edx
  006aa	e8 00 00 00 00	 call	 _memchr
  006af	8b f8		 mov	 edi, eax
  006b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 552  :         if (!_Match_try) { // didn't find first character; report failure

  006b4	85 ff		 test	 edi, edi
  006b6	0f 84 8d 00 00
	00		 je	 $LN591@LoadScript
  006bc	0f 1f 40 00	 npad	 4
$LL416@LoadScript:

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

  006c0	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR __Result$2$[ebp]
  006c6	8b cf		 mov	 ecx, edi
  006c8	83 ee 04	 sub	 esi, 4
  006cb	72 14		 jb	 SHORT $LN581@LoadScript
  006cd	0f 1f 00	 npad	 3
$LL582@LoadScript:
  006d0	8b 01		 mov	 eax, DWORD PTR [ecx]
  006d2	3b 02		 cmp	 eax, DWORD PTR [edx]
  006d4	75 10		 jne	 SHORT $LN580@LoadScript
  006d6	83 c1 04	 add	 ecx, 4
  006d9	83 c2 04	 add	 edx, 4
  006dc	83 ee 04	 sub	 esi, 4
  006df	73 ef		 jae	 SHORT $LL582@LoadScript
$LN581@LoadScript:
  006e1	83 fe fc	 cmp	 esi, -4			; fffffffcH
  006e4	74 34		 je	 SHORT $LN579@LoadScript
$LN580@LoadScript:
  006e6	8a 01		 mov	 al, BYTE PTR [ecx]
  006e8	3a 02		 cmp	 al, BYTE PTR [edx]
  006ea	75 27		 jne	 SHORT $LN583@LoadScript
  006ec	83 fe fd	 cmp	 esi, -3			; fffffffdH
  006ef	74 29		 je	 SHORT $LN579@LoadScript
  006f1	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  006f4	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  006f7	75 1a		 jne	 SHORT $LN583@LoadScript
  006f9	83 fe fe	 cmp	 esi, -2			; fffffffeH
  006fc	74 1c		 je	 SHORT $LN579@LoadScript
  006fe	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00701	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00704	75 0d		 jne	 SHORT $LN583@LoadScript
  00706	83 fe ff	 cmp	 esi, -1
  00709	74 0f		 je	 SHORT $LN579@LoadScript
  0070b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0070e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00711	74 07		 je	 SHORT $LN579@LoadScript
$LN583@LoadScript:
  00713	1b c0		 sbb	 eax, eax
  00715	83 c8 01	 or	 eax, 1
  00718	eb 02		 jmp	 SHORT $LN584@LoadScript
$LN579@LoadScript:
  0071a	33 c0		 xor	 eax, eax
$LN584@LoadScript:

; 556  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  0071c	85 c0		 test	 eax, eax
  0071e	74 76		 je	 SHORT $LN531@LoadScript

; 550  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  00720	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Possible_matches_end$1$[ebp]
  00726	47		 inc	 edi

; 551  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00727	2b c7		 sub	 eax, edi

; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  00729	50		 push	 eax
  0072a	ff b5 08 ff ff
	ff		 push	 DWORD PTR tv2771[ebp]
  00730	57		 push	 edi
  00731	e8 00 00 00 00	 call	 _memchr

; 552  :         if (!_Match_try) { // didn't find first character; report failure

  00736	8b b5 04 ff ff
	ff		 mov	 esi, DWORD PTR $T2[ebp]

; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  0073c	8b f8		 mov	 edi, eax
  0073e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 552  :         if (!_Match_try) { // didn't find first character; report failure

  00741	85 ff		 test	 edi, edi
  00743	0f 85 77 ff ff
	ff		 jne	 $LL416@LoadScript
$LN591@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 94   : 	return true;

  00749	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _strNoExtensionName$2$[ebp]
$LN494@LoadScript:
  0074f	c6 85 27 ff ff
	ff 01		 mov	 BYTE PTR $T6[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00756	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00759	72 0d		 jb	 SHORT $LN514@LoadScript

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0075b	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0075c	50		 push	 eax
  0075d	ff 75 d8	 push	 DWORD PTR _strNoExtensionName$[ebp]
  00760	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00765	83 c4 08	 add	 esp, 8
$LN514@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 94   : 	return true;

  00768	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  0076e	e8 00 00 00 00	 call	 ??1CTextFileLoader@@UAE@XZ ; CTextFileLoader::~CTextFileLoader
  00773	8a 85 27 ff ff
	ff		 mov	 al, BYTE PTR $T6[ebp]

; 95   : }

  00779	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0077c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00783	59		 pop	 ecx
  00784	5f		 pop	 edi
  00785	5e		 pop	 esi
  00786	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00789	33 cd		 xor	 ecx, ebp
  0078b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00790	8b e5		 mov	 esp, ebp
  00792	5d		 pop	 ebp
  00793	c2 04 00	 ret	 4
$LN531@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 557  :             return static_cast<size_t>(_Match_try - _Haystack);

  00796	2b bd 18 ff ff
	ff		 sub	 edi, DWORD PTR __Result$2$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 83   : 	if (iPos >= 0)

  0079c	78 ab		 js	 SHORT $LN591@LoadScript
  0079e	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _strNoExtensionName$2$[ebp]
  007a4	8b bd 1c ff ff
	ff		 mov	 edi, DWORD PTR _strNoExtensionName$1$[ebp]
  007aa	8b 4d d8	 mov	 ecx, DWORD PTR _strNoExtensionName$[ebp]
$LN552@LoadScript:

; 84   : 	if (strNoExtensionName.size() > strPathHeader.size())

  007ad	be 0d 00 00 00	 mov	 esi, 13			; 0000000dH
  007b2	3b fe		 cmp	 edi, esi
  007b4	76 93		 jbe	 SHORT $LN591@LoadScript
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  007b6	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strSoundFileName$7[ebp+20], 15 ; 0000000fH

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  007bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_06PBLIODKG@sound?1@

; 2153 :         return _BUF_SIZE <= _Myres;

  007c2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  007c5	89 45 c0	 mov	 DWORD PTR _strSoundFileName$7[ebp], eax
  007c8	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_06PBLIODKG@sound?1@+4
  007ce	66 89 45 c4	 mov	 WORD PTR _strSoundFileName$7[ebp+4], ax

; 2135 :         value_type* _Result = _Bx._Buf;

  007d2	8d 45 d8	 lea	 eax, DWORD PTR _strNoExtensionName$[ebp]

; 2136 :         if (_Large_string_engaged()) {

  007d5	0f 43 c1	 cmovae	 eax, ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 86   : 		std::string strSoundFileName;

  007d8	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 3590 :         return _Mypair._Myval2._Myptr()[_Off];

  007dc	03 c6		 add	 eax, esi

; 2968 :             _Mypair._Myval2._Mysize = _Count;

  007de	c7 45 d0 06 00
	00 00		 mov	 DWORD PTR _strSoundFileName$7[ebp+16], 6
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 88   : 		strSoundFileName += &strNoExtensionName[strPathHeader.size()];

  007e5	50		 push	 eax
  007e6	8d 4d c0	 lea	 ecx, DWORD PTR _strSoundFileName$7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  007e9	c6 45 c6 00	 mov	 BYTE PTR _strSoundFileName$7[ebp+6], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 88   : 		strSoundFileName += &strNoExtensionName[strPathHeader.size()];

  007ed	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 89   : 		strSoundFileName += ".mss";

  007f2	68 00 00 00 00	 push	 OFFSET ??_C@_04NMMFEKGF@?4mss@
  007f7	8d 4d c0	 lea	 ecx, DWORD PTR _strSoundFileName$7[ebp]
  007fa	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  007ff	83 7d d4 10	 cmp	 DWORD PTR _strSoundFileName$7[ebp+20], 16 ; 00000010H

; 2144 :         const value_type* _Result = _Bx._Buf;

  00803	8d 45 c0	 lea	 eax, DWORD PTR _strSoundFileName$7[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 91   : 		LoadSoundScriptData(strSoundFileName.c_str());

  00806	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  0080c	0f 43 45 c0	 cmovae	 eax, DWORD PTR _strSoundFileName$7[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 91   : 		LoadSoundScriptData(strSoundFileName.c_str());

  00810	50		 push	 eax
  00811	e8 00 00 00 00	 call	 ?LoadSoundScriptData@CEffectData@@QAE_NPBD@Z ; CEffectData::LoadSoundScriptData
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00816	8b 45 d4	 mov	 eax, DWORD PTR _strSoundFileName$7[ebp+20]
  00819	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0081c	72 0d		 jb	 SHORT $LN585@LoadScript

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0081e	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0081f	50		 push	 eax
  00820	ff 75 c0	 push	 DWORD PTR _strSoundFileName$7[ebp]
  00823	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00828	83 c4 08	 add	 esp, 8
$LN585@LoadScript:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 94   : 	return true;

  0082b	8b 45 ec	 mov	 eax, DWORD PTR _strNoExtensionName$[ebp+20]
  0082e	e9 1c ff ff ff	 jmp	 $LN494@LoadScript
$LN524@LoadScript:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2164 :             _Xran();

  00833	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN596@LoadScript:
  00838	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$0:
  00000	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CTextFileLoader@@UAE@XZ ; CTextFileLoader::~CTextFileLoader
__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$1:
  0000b	8d 4d c0	 lea	 ecx, DWORD PTR $T9[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$2:
  00013	8d 4d c0	 lea	 ecx, DWORD PTR $T8[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$3:
  0001b	8d 4d d8	 lea	 ecx, DWORD PTR _strName$10[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$4:
  00023	8d 4d a8	 lea	 ecx, DWORD PTR _strPathHeader$[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$5:
  0002b	8d 4d d8	 lea	 ecx, DWORD PTR _strNoExtensionName$[ebp]
  0002e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScript@CEffectData@@QAE_NPBD@Z$6:
  00033	8d 4d c0	 lea	 ecx, DWORD PTR _strSoundFileName$7[ebp]
  00036	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003b	cc		 int	 3
  0003c	cc		 int	 3
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
__ehhandler$?LoadScript@CEffectData@@QAE_NPBD@Z:
  00040	90		 npad	 1
  00041	90		 npad	 1
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00049	8b 8a 04 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-252]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadScript@CEffectData@@QAE_NPBD@Z
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadScript@CEffectData@@QAE_NPBD@Z ENDP		; CEffectData::LoadScript
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ?Clear@CEffectData@@QAEXXZ
_TEXT	SEGMENT
?Clear@CEffectData@@QAEXXZ PROC				; CEffectData::Clear, COMDAT
; _this$ = ecx

; 206  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 207  : 	m_fBoundingSphereRadius = 0.0f;

  00003	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 208  : 	m_v3BoundingSpherePosition.x = m_v3BoundingSpherePosition.y = m_v3BoundingSpherePosition.z = 0.0f;

  0000a	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  00011	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00018	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 209  : 	__ClearParticleDataVector();

  0001f	e8 00 00 00 00	 call	 ?__ClearParticleDataVector@CEffectData@@IAEXXZ ; CEffectData::__ClearParticleDataVector

; 210  : 	__ClearLightDataVector();

  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?__ClearLightDataVector@CEffectData@@IAEXXZ ; CEffectData::__ClearLightDataVector

; 211  : 	__ClearMeshDataVector();

  0002b	8b ce		 mov	 ecx, esi
  0002d	5e		 pop	 esi
  0002e	e9 00 00 00 00	 jmp	 ?__ClearMeshDataVector@CEffectData@@IAEXXZ ; CEffectData::__ClearMeshDataVector
?Clear@CEffectData@@QAEXXZ ENDP				; CEffectData::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ??1CEffectData@@UAE@XZ
_TEXT	SEGMENT
??1CEffectData@@UAE@XZ PROC				; CEffectData::~CEffectData, COMDAT
; _this$ = ecx

; 220  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectData@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00009	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0000c	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0000f	72 0d		 jb	 SHORT $LN7@CEffectDat

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00011	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	50		 push	 eax
  00013	ff 76 44	 push	 DWORD PTR [esi+68]
  00016	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001b	83 c4 08	 add	 esp, 8
$LN7@CEffectDat:
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 221  : }

  0001e	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00021	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00028	c7 46 58 0f 00
	00 00		 mov	 DWORD PTR [esi+88], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0002f	c6 46 44 00	 mov	 BYTE PTR [esi+68], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 221  : }

  00033	e8 00 00 00 00	 call	 ??1?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::~vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00038	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 27		 je	 SHORT $LN16@CEffectDat

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0003f	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00042	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00044	83 e0 fc	 and	 eax, -4			; fffffffcH
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0004e	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00055	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00058	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 1699 :             _Myend   = pointer();

  0005f	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
$LN16@CEffectDat:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00066	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00069	85 c9		 test	 ecx, ecx
  0006b	74 27		 je	 SHORT $LN23@CEffectDat

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006d	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00070	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00072	83 e0 fc	 and	 eax, -4			; fffffffcH
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0007c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00086	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1699 :             _Myend   = pointer();

  0008d	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN23@CEffectDat:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00094	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00097	85 c9		 test	 ecx, ecx
  00099	74 27		 je	 SHORT $LN30@CEffectDat

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0009b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0009e	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	83 e0 fc	 and	 eax, -4			; fffffffcH
  000a3	50		 push	 eax
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  000aa	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b1	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  000b4	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1699 :             _Myend   = pointer();

  000bb	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN30@CEffectDat:
  000c2	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 221  : }

  000c3	c3		 ret	 0
??1CEffectData@@UAE@XZ ENDP				; CEffectData::~CEffectData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp
;	COMDAT ??0CEffectData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CEffectData@@QAE@XZ PROC				; CEffectData::CEffectData, COMDAT
; _this$ = ecx

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CEffectData@@6B@

; 218  : }

  0000a	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00021	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00028	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0002f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00036	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0003d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00044	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  0004b	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00052	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00059	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00060	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00067	c7 41 58 0f 00
	00 00		 mov	 DWORD PTR [ecx+88], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0006e	c6 41 44 00	 mov	 BYTE PTR [ecx+68], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\EffectLib\EffectData.cpp

; 215  : {

  00072	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 	m_fBoundingSphereRadius = 0.0f;

  00075	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 217  : 	m_v3BoundingSpherePosition.x = m_v3BoundingSpherePosition.y = m_v3BoundingSpherePosition.z = 0.0f;

  0007c	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00083	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  0008a	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 218  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
??0CEffectData@@QAE@XZ ENDP				; CEffectData::CEffectData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 268  :     _Obj.~_Ty();
; 269  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__New_ptr$1 = 12					; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2964 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 2965 :         // assign [_Ptr, _Ptr + _Count)
; 2966 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b f9		 cmp	 edi, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2135 :         value_type* _Result = _Bx._Buf;

  00016	8b de		 mov	 ebx, esi

; 2153 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN5@assign:

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0001f	57		 push	 edi
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 2967 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2968 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2969 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 2981 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4221 :         if (_New_size > max_size()) {

  0003e	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00044	0f 87 91 00 00
	00		 ja	 $LN36@assign

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b df		 mov	 ebx, edi
  0004c	83 cb 0f	 or	 ebx, 15			; 0000000fH
  0004f	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 07		 jbe	 SHORT $LN19@assign

; 4203 :             return _Max;

  00057	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0005c	eb 1e		 jmp	 SHORT $LN18@assign
$LN19@assign:

; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0005e	8b d1		 mov	 edx, ecx
  00060	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00065	d1 ea		 shr	 edx, 1
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN20@assign

; 4207 :             return _Max;

  0006d	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00072	eb 08		 jmp	 SHORT $LN18@assign
$LN20@assign:

; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00077	3b d8		 cmp	 ebx, eax
  00079	0f 42 d8	 cmovb	 ebx, eax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0007c	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00085	57		 push	 edi
  00086	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00089	89 45 0c	 mov	 DWORD PTR __New_ptr$1[ebp], eax

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0008c	50		 push	 eax

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  0008d	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  00090	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00093	e8 00 00 00 00	 call	 _memcpy

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00098	8b 5d 0c	 mov	 ebx, DWORD PTR __New_ptr$1[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0009b	83 c4 10	 add	 esp, 16			; 00000010H

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  0009e	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000a1	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 19		 jb	 SHORT $LN13@assign

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000aa	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ab	50		 push	 eax
  000ac	ff 36		 push	 DWORD PTR [esi]
  000ae	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2981 :     }

  000b3	83 c4 08	 add	 esp, 8

; 4235 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000b6	89 1e		 mov	 DWORD PTR [esi], ebx

; 2981 :     }

  000b8	8b c6		 mov	 eax, esi
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
$LN13@assign:

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000c3	8d 45 0c	 lea	 eax, DWORD PTR __New_ptr$1[ebp]
  000c6	50		 push	 eax
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2981 :     }

  000cd	83 c4 08	 add	 esp, 8
  000d0	8b c6		 mov	 eax, esi
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
$LN36@assign:

; 4222 :             _Xlen_string(); // result too long

  000db	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN33@assign:
  000e0	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Old_size$1$ = -16					; size = 4
__New_ptr$1 = -12					; size = 4
__Old$1$ = -8						; size = 4
tv441 = -4						; size = 4
tv438 = -4						; size = 4
$T2 = -4						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2822 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 2822 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  0000d	57		 push	 edi

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000e	8b f9		 mov	 edi, ecx
  00010	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
$LL49@operator:
  00013	8a 07		 mov	 al, BYTE PTR [edi]
  00015	47		 inc	 edi
  00016	84 c0		 test	 al, al
  00018	75 f9		 jne	 SHORT $LL49@operator

; 2859 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0001a	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0001d	2b fa		 sub	 edi, edx

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0001f	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  00022	8b c2		 mov	 eax, edx
  00024	2b c6		 sub	 eax, esi
  00026	89 75 f0	 mov	 DWORD PTR __Old_size$1$[ebp], esi
  00029	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0002c	3b f8		 cmp	 edi, eax
  0002e	77 2b		 ja	 SHORT $LN8@operator

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00030	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00033	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 2135 :         value_type* _Result = _Bx._Buf;

  00036	8b c3		 mov	 eax, ebx

; 2153 :         return _BUF_SIZE <= _Myres;

  00038	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2136 :         if (_Large_string_engaged()) {

  0003b	72 02		 jb	 SHORT $LN11@operator

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  0003d	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN11@operator:

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0003f	57		 push	 edi

; 2863 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00040	03 f0		 add	 esi, eax

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00042	51		 push	 ecx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 _memmove
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004c	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 2823 :         return append(_Ptr);

  00050	8b c3		 mov	 eax, ebx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 2824 :     }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN8@operator:

; 4249 :         if (max_size() - _Old_size < _Size_increase) {

  0005b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00060	2b c6		 sub	 eax, esi
  00062	3b c7		 cmp	 eax, edi
  00064	0f 82 d5 00 00
	00		 jb	 $LN54@operator

; 4251 :         }
; 4252 : 
; 4253 :         const size_type _New_size     = _Old_size + _Size_increase;

  0006a	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0006d	83 c9 0f	 or	 ecx, 15			; 0000000fH
  00070	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00076	76 07		 jbe	 SHORT $LN25@operator

; 4203 :             return _Max;

  00078	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0007d	eb 24		 jmp	 SHORT $LN51@operator
$LN25@operator:

; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0007f	8b c2		 mov	 eax, edx
  00081	d1 e8		 shr	 eax, 1
  00083	89 45 fc	 mov	 DWORD PTR tv441[ebp], eax
  00086	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0008b	2b 45 fc	 sub	 eax, DWORD PTR tv441[ebp]
  0008e	3b d0		 cmp	 edx, eax
  00090	76 07		 jbe	 SHORT $LN26@operator

; 4207 :             return _Max;

  00092	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00097	eb 0a		 jmp	 SHORT $LN51@operator
$LN26@operator:

; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00099	8b 45 fc	 mov	 eax, DWORD PTR tv441[ebp]
  0009c	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0009e	3b c8		 cmp	 ecx, eax
  000a0	0f 42 c8	 cmovb	 ecx, eax
$LN51@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4257 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000a3	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000a6	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4260 :         _My_data._Myres       = _New_capacity;

  000af	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  000b2	8b d0		 mov	 edx, eax
  000b4	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  000b7	89 55 f4	 mov	 DWORD PTR __New_ptr$1[ebp], edx
  000ba	89 43 10	 mov	 DWORD PTR [ebx+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000bd	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4262 :         if (_BUF_SIZE <= _Old_capacity) {

  000c0	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000c4	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  000c7	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx
  000ca	89 45 fc	 mov	 DWORD PTR tv438[ebp], eax
  000cd	72 3e		 jb	 SHORT $LN19@operator

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000cf	ff 75 f0	 push	 DWORD PTR __Old_size$1$[ebp]

; 4263 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000d2	8b 33		 mov	 esi, DWORD PTR [ebx]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000d4	56		 push	 esi
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 _memcpy
  000db	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000de	57		 push	 edi
  000df	50		 push	 eax
  000e0	ff 75 fc	 push	 DWORD PTR tv438[ebp]
  000e3	e8 00 00 00 00	 call	 _memcpy

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000e8	8b 45 fc	 mov	 eax, DWORD PTR tv438[ebp]
  000eb	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 4265 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000f2	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f3	50		 push	 eax
  000f4	56		 push	 esi
  000f5	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4266 :             _My_data._Bx._Ptr = _New_ptr;

  000fa	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1[ebp]

; 2823 :         return append(_Ptr);

  000fd	83 c4 20	 add	 esp, 32			; 00000020H

; 4266 :             _My_data._Bx._Ptr = _New_ptr;

  00100	89 03		 mov	 DWORD PTR [ebx], eax

; 2823 :         return append(_Ptr);

  00102	8b c3		 mov	 eax, ebx
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 2824 :     }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 04 00	 ret	 4
$LN19@operator:

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0010d	56		 push	 esi
  0010e	53		 push	 ebx
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 _memcpy
  00115	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00118	8b 75 fc	 mov	 esi, DWORD PTR tv438[ebp]
  0011b	57		 push	 edi
  0011c	50		 push	 eax
  0011d	56		 push	 esi
  0011e	e8 00 00 00 00	 call	 _memcpy

; 4269 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00123	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$1[ebp]

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00126	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 4269 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0012a	50		 push	 eax
  0012b	53		 push	 ebx
  0012c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2823 :         return append(_Ptr);

  00131	83 c4 20	 add	 esp, 32			; 00000020H
  00134	8b c3		 mov	 eax, ebx
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx

; 2824 :     }

  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 04 00	 ret	 4
$LN54@operator:

; 4250 :             _Xlen_string(); // result too long

  0013f	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN50@operator:
  00144	cc		 int	 3
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2722 :     ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2153 :         return _BUF_SIZE <= _Myres;

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 0c		 jb	 SHORT $LN4@basic_stri

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000b	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	83 c4 08	 add	 esp, 8
$LN4@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0001e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi

; 2723 :         _Tidy_deallocate();
; 2724 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2725 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2726 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2727 :         _Mypair._Myval2._Myproxy = nullptr;
; 2728 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2729 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2730 :     }

  00029	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2169 :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2201 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
