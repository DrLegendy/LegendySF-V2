; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\EterBase\tea.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_tea_encrypt
PUBLIC	_tea_decrypt
PUBLIC	?tea_code@@YAXKKPBKPAK@Z			; tea_code
PUBLIC	?tea_decode@@YAXKKPBKPAK@Z			; tea_decode
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterBase\tea.cpp
;	COMDAT ?tea_decode@@YAXKKPBKPAK@Z
_TEXT	SEGMENT
_sz$ = 8						; size = 4
_n$1$ = 12						; size = 4
_sy$ = 12						; size = 4
_key$ = 16						; size = 4
_dest$ = 20						; size = 4
?tea_decode@@YAXKKPBKPAK@Z PROC				; tea_decode, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 29   : #pragma warning(disable:4307)
; 30   : 	register unsigned long y = sy, z = sz, sum = DELTA * TEA_ROUND;

  00005	8b 75 0c	 mov	 esi, DWORD PTR _sy$[ebp]
  00008	b8 20 37 ef c6	 mov	 eax, -957401312		; c6ef3720H
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _sz$[ebp]
  00011	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LL2@tea_decode:

; 31   : #pragma warning(default:4307)
; 32   : 
; 33   : 	unsigned long		n = TEA_ROUND;
; 34   : 
; 35   : 	while (n-- > 0)
; 36   : 	{
; 37   : 		z -= ((y << 4 ^ y >> 5) + y) ^ (sum + key[sum >> 11 & 3]);

  00016	8b d6		 mov	 edx, esi
  00018	8b ce		 mov	 ecx, esi
  0001a	c1 e1 04	 shl	 ecx, 4
  0001d	4b		 dec	 ebx
  0001e	c1 ea 05	 shr	 edx, 5
  00021	33 d1		 xor	 edx, ecx
  00023	89 5d 0c	 mov	 DWORD PTR _n$1$[ebp], ebx
  00026	8b 5d 10	 mov	 ebx, DWORD PTR _key$[ebp]
  00029	8b c8		 mov	 ecx, eax
  0002b	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  0002e	03 d6		 add	 edx, esi
  00030	83 e1 03	 and	 ecx, 3
  00033	8b 0c 8b	 mov	 ecx, DWORD PTR [ebx+ecx*4]
  00036	03 c8		 add	 ecx, eax

; 38   : 		sum -= DELTA;

  00038	05 47 86 c8 61	 add	 eax, 1640531527		; 61c88647H
  0003d	33 d1		 xor	 edx, ecx
  0003f	2b fa		 sub	 edi, edx

; 39   : 		y -= ((z << 4 ^ z >> 5) + z) ^ (sum + key[sum & 3]);

  00041	8b d7		 mov	 edx, edi
  00043	8b cf		 mov	 ecx, edi
  00045	c1 e1 04	 shl	 ecx, 4
  00048	c1 ea 05	 shr	 edx, 5
  0004b	33 d1		 xor	 edx, ecx
  0004d	8b c8		 mov	 ecx, eax
  0004f	83 e1 03	 and	 ecx, 3
  00052	03 d7		 add	 edx, edi
  00054	8b 0c 8b	 mov	 ecx, DWORD PTR [ebx+ecx*4]
  00057	8b 5d 0c	 mov	 ebx, DWORD PTR _n$1$[ebp]
  0005a	03 c8		 add	 ecx, eax
  0005c	33 d1		 xor	 edx, ecx
  0005e	2b f2		 sub	 esi, edx
  00060	85 db		 test	 ebx, ebx
  00062	75 b2		 jne	 SHORT $LL2@tea_decode

; 40   : 	}
; 41   : 
; 42   : 	*(dest++)	= y;

  00064	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  00067	89 30		 mov	 DWORD PTR [eax], esi

; 43   : 	*dest	= z;

  00069	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 44   : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?tea_decode@@YAXKKPBKPAK@Z ENDP				; tea_decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterBase\tea.cpp
;	COMDAT ?tea_code@@YAXKKPBKPAK@Z
_TEXT	SEGMENT
_sz$ = 8						; size = 4
_n$1$ = 12						; size = 4
_sy$ = 12						; size = 4
_key$ = 16						; size = 4
_dest$ = 20						; size = 4
?tea_code@@YAXKKPBKPAK@Z PROC				; tea_code, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 13   : 	register unsigned long y = sy, z = sz, sum = 0;

  00005	8b 75 0c	 mov	 esi, DWORD PTR _sy$[ebp]
  00008	33 c0		 xor	 eax, eax
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _sz$[ebp]
  0000e	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LL2@tea_code:

; 14   : 	unsigned long		n = TEA_ROUND;
; 15   : 
; 16   : 	while (n-- > 0)
; 17   : 	{
; 18   : 		y	+= ((z << 4 ^ z >> 5) + z) ^ (sum + key[sum & 3]);

  00013	8b d7		 mov	 edx, edi
  00015	8b cf		 mov	 ecx, edi
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	4b		 dec	 ebx
  0001b	c1 ea 05	 shr	 edx, 5
  0001e	33 d1		 xor	 edx, ecx
  00020	89 5d 0c	 mov	 DWORD PTR _n$1$[ebp], ebx
  00023	8b 5d 10	 mov	 ebx, DWORD PTR _key$[ebp]
  00026	8b c8		 mov	 ecx, eax
  00028	83 e1 03	 and	 ecx, 3
  0002b	03 d7		 add	 edx, edi
  0002d	8b 0c 8b	 mov	 ecx, DWORD PTR [ebx+ecx*4]
  00030	03 c8		 add	 ecx, eax

; 19   : 		sum	+= DELTA;

  00032	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  00037	33 d1		 xor	 edx, ecx
  00039	03 f2		 add	 esi, edx

; 20   : 		z	+= ((y << 4 ^ y >> 5) + y) ^ (sum + key[sum >> 11 & 3]);

  0003b	8b d6		 mov	 edx, esi
  0003d	8b ce		 mov	 ecx, esi
  0003f	c1 e1 04	 shl	 ecx, 4
  00042	c1 ea 05	 shr	 edx, 5
  00045	33 d1		 xor	 edx, ecx
  00047	8b c8		 mov	 ecx, eax
  00049	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  0004c	03 d6		 add	 edx, esi
  0004e	83 e1 03	 and	 ecx, 3
  00051	8b 0c 8b	 mov	 ecx, DWORD PTR [ebx+ecx*4]
  00054	8b 5d 0c	 mov	 ebx, DWORD PTR _n$1$[ebp]
  00057	03 c8		 add	 ecx, eax
  00059	33 d1		 xor	 edx, ecx
  0005b	03 fa		 add	 edi, edx
  0005d	85 db		 test	 ebx, ebx
  0005f	75 b2		 jne	 SHORT $LL2@tea_code

; 21   : 	}
; 22   : 
; 23   : 	*(dest++)	= y;

  00061	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  00064	89 30		 mov	 DWORD PTR [eax], esi

; 24   : 	*dest	= z;

  00066	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx

; 25   : }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?tea_code@@YAXKKPBKPAK@Z ENDP				; tea_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterBase\tea.cpp
;	COMDAT _tea_decrypt
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_key$ = 16						; size = 4
_size$ = 20						; size = 4
_tea_decrypt PROC					; COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 67   : 	int		i;
; 68   : 	int		resize;
; 69   : 
; 70   : 	if (size % 8 != 0)

  00005	8b 75 14	 mov	 esi, DWORD PTR _size$[ebp]
  00008	8b c6		 mov	 eax, esi
  0000a	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0000f	79 07		 jns	 SHORT $LN13@tea_decryp
  00011	48		 dec	 eax
  00012	83 c8 f8	 or	 eax, -8			; fffffff8H
  00015	83 c0 01	 add	 eax, 1
$LN13@tea_decryp:
  00018	74 05		 je	 SHORT $LN5@tea_decryp

; 71   : 		resize = size + 8 - (size % 8);

  0001a	2b f0		 sub	 esi, eax
  0001c	83 c6 08	 add	 esi, 8
$LN5@tea_decryp:

; 72   : 	else
; 73   : 		resize = size;
; 74   : 
; 75   : 	for (i = 0; i < resize >> 3; i++, dest += 2, src += 2)

  0001f	8b de		 mov	 ebx, esi
  00021	89 75 14	 mov	 DWORD PTR _size$[ebp], esi
  00024	c1 fb 03	 sar	 ebx, 3
  00027	85 db		 test	 ebx, ebx
  00029	7e 2d		 jle	 SHORT $LN12@tea_decryp
  0002b	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  0002e	57		 push	 edi
  0002f	8b 7d 0c	 mov	 edi, DWORD PTR _src$[ebp]
  00032	2b f7		 sub	 esi, edi
$LL4@tea_decryp:

; 76   : 		tea_decode(*(src + 1), *src, key, dest);

  00034	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00037	50		 push	 eax
  00038	ff 75 10	 push	 DWORD PTR _key$[ebp]
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 77 04	 push	 DWORD PTR [edi+4]
  00040	e8 00 00 00 00	 call	 ?tea_decode@@YAXKKPBKPAK@Z ; tea_decode
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	8d 7f 08	 lea	 edi, DWORD PTR [edi+8]
  0004b	83 eb 01	 sub	 ebx, 1
  0004e	75 e4		 jne	 SHORT $LL4@tea_decryp

; 77   : 
; 78   : 	return (resize);

  00050	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 79   : }

  00055	5b		 pop	 ebx
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN12@tea_decryp:

; 77   : 
; 78   : 	return (resize);

  00058	8b c6		 mov	 eax, esi
  0005a	5e		 pop	 esi

; 79   : }

  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_tea_decrypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\EterBase\tea.cpp
;	COMDAT _tea_encrypt
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_key$ = 16						; size = 4
_resize$1$ = 20						; size = 4
_size$ = 20						; size = 4
_tea_encrypt PROC					; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 	int		i;
; 49   : 	int		resize;
; 50   : 
; 51   : 	if (size % 8 != 0)

  00003	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00010	79 07		 jns	 SHORT $LN13@tea_encryp
  00012	48		 dec	 eax
  00013	83 c8 f8	 or	 eax, -8			; fffffff8H
  00016	83 c0 01	 add	 eax, 1
$LN13@tea_encryp:
  00019	8b 75 0c	 mov	 esi, DWORD PTR _src$[ebp]
  0001c	8b d9		 mov	 ebx, ecx
  0001e	74 1d		 je	 SHORT $LN5@tea_encryp

; 52   : 	{
; 53   : 		resize = size + 8 - (size % 8);

  00020	2b d8		 sub	 ebx, eax
  00022	83 c3 08	 add	 ebx, 8

; 54   : 		memset((char *) src + size, 0, resize - size);

  00025	8b c3		 mov	 eax, ebx
  00027	89 5d 14	 mov	 DWORD PTR _resize$1$[ebp], ebx
  0002a	2b c1		 sub	 eax, ecx
  0002c	50		 push	 eax
  0002d	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00030	6a 00		 push	 0
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _memset
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 	}

  0003b	eb 03		 jmp	 SHORT $LN6@tea_encryp
$LN5@tea_encryp:

; 56   : 	else
; 57   : 		resize = size;

  0003d	89 4d 14	 mov	 DWORD PTR _resize$1$[ebp], ecx
$LN6@tea_encryp:

; 58   : 
; 59   : 	for (i = 0; i < resize >> 3; i++, dest += 2, src += 2)

  00040	8b fb		 mov	 edi, ebx
  00042	c1 ff 03	 sar	 edi, 3
  00045	85 ff		 test	 edi, edi
  00047	7e 2b		 jle	 SHORT $LN12@tea_encryp
  00049	8b 5d 08	 mov	 ebx, DWORD PTR _dest$[ebp]
  0004c	2b de		 sub	 ebx, esi
  0004e	66 90		 npad	 2
$LL4@tea_encryp:

; 60   : 		tea_code(*(src + 1), *src, key, dest);

  00050	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  00053	50		 push	 eax
  00054	ff 75 10	 push	 DWORD PTR _key$[ebp]
  00057	ff 36		 push	 DWORD PTR [esi]
  00059	ff 76 04	 push	 DWORD PTR [esi+4]
  0005c	e8 00 00 00 00	 call	 ?tea_code@@YAXKKPBKPAK@Z ; tea_code
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	8d 76 08	 lea	 esi, DWORD PTR [esi+8]
  00067	83 ef 01	 sub	 edi, 1
  0006a	75 e4		 jne	 SHORT $LL4@tea_encryp

; 61   : 
; 62   : 	return (resize);

  0006c	8b 45 14	 mov	 eax, DWORD PTR _resize$1$[ebp]
  0006f	5f		 pop	 edi

; 63   : }

  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN12@tea_encryp:
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	8b c3		 mov	 eax, ebx
  00078	5b		 pop	 ebx
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_tea_encrypt ENDP
_TEXT	ENDS
END
