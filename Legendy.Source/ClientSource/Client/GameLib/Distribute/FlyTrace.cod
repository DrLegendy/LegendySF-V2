; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7?$CDynamicPool@VCFlyTrace@@@@6B@		; CDynamicPool<CFlyTrace>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCFlyTrace@@@@UAEPAXI@Z	; CDynamicPool<CFlyTrace>::`scalar deleting destructor'
PUBLIC	??_R4?$CDynamicPool@VCFlyTrace@@@@6B@		; CDynamicPool<CFlyTrace>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCFlyTrace@@@@@8		; CDynamicPool<CFlyTrace> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCFlyTrace@@@@8		; CDynamicPool<CFlyTrace>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCFlyTrace@@@@8		; CDynamicPool<CFlyTrace>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCFlyTrace@@@@8	; CDynamicPool<CFlyTrace>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPool@VCFlyTrace@@@@UAEPAXI@Z:PROC	; CDynamicPool<CFlyTrace>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCFlyTrace@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCFlyTrace@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCFlyTrace@@@@@8 ; CDynamicPool<CFlyTrace>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCFlyTrace@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCFlyTrace@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCFlyTrace@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCFlyTrace@@@@8 ; CDynamicPool<CFlyTrace>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCFlyTrace@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCFlyTrace@@@@8 DD 00H		; CDynamicPool<CFlyTrace>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCFlyTrace@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCFlyTrace@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCFlyTrace@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CFlyTrace> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCFlyTrace@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCFlyTrace@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCFlyTrace@@@@6B@ DD 00H		; CDynamicPool<CFlyTrace>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCFlyTrace@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCFlyTrace@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$CDynamicPool@VCFlyTrace@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCFlyTrace@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCFlyTrace@@@@6B@ ; CDynamicPool<CFlyTrace>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCFlyTrace@@@@UAEPAXI@Z
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CFlyTrace@@QAE@XZ				; CFlyTrace::CFlyTrace
PUBLIC	??1CFlyTrace@@UAE@XZ				; CFlyTrace::~CFlyTrace
PUBLIC	?Destroy@CFlyTrace@@QAEXXZ			; CFlyTrace::Destroy
PUBLIC	?Create@CFlyTrace@@QAEXABUTFlyingAttachData@CFlyingData@@@Z ; CFlyTrace::Create
PUBLIC	?UpdateNewPosition@CFlyTrace@@QAEXABUD3DXVECTOR3@@@Z ; CFlyTrace::UpdateNewPosition
PUBLIC	?Update@CFlyTrace@@QAEXXZ			; CFlyTrace::Update
PUBLIC	?Render@CFlyTrace@@QAEXXZ			; CFlyTrace::Render
PUBLIC	?__Initialize@CFlyTrace@@IAEXXZ			; CFlyTrace::__Initialize
PUBLIC	?push_front@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@QAEX$$QAU?$pair@MUD3DXVECTOR3@@@2@@Z ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::push_front
PUBLIC	?_Xlen@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@ABEXXZ ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Xlen
PUBLIC	?_Tidy@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@AAEXXZ ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Tidy
PUBLIC	?DestroySystem@CFlyTrace@@SAXXZ			; CFlyTrace::DestroySystem
PUBLIC	?New@CFlyTrace@@SAPAV1@XZ			; CFlyTrace::New
PUBLIC	?Delete@CFlyTrace@@SAXPAV1@@Z			; CFlyTrace::Delete
PUBLIC	??_GCFlyTrace@@UAEPAXI@Z			; CFlyTrace::`scalar deleting destructor'
PUBLIC	??1?$CDynamicPool@VCFlyTrace@@@@UAE@XZ		; CDynamicPool<CFlyTrace>::~CDynamicPool<CFlyTrace>
PUBLIC	?Delete@?$CDynamicPool@VCFlyTrace@@@@KAXPAVCFlyTrace@@@Z ; CDynamicPool<CFlyTrace>::Delete
PUBLIC	?_Xlength@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@CAXXZ ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Xlength
PUBLIC	??0TFlyVertex@@QAE@XZ				; TFlyVertex::TFlyVertex
PUBLIC	??1?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::~vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >
PUBLIC	?_Xlength@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@CAXXZ ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Xlength
PUBLIC	??$_Const_cast@$$CBU?$pair@MUTFlyVertexSet@@@std@@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@PBU10@@Z ; std::_Const_cast<std::pair<float,TFlyVertexSet> const >
PUBLIC	??$_Emplace_reallocate@U?$pair@MUTFlyVertexSet@@@std@@@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAEPAU?$pair@MUTFlyVertexSet@@@1@QAU21@$$QAU21@@Z ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Emplace_reallocate<std::pair<float,TFlyVertexSet> >
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Emplace_reallocate@ABQAVCFlyTrace@@@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@QAEPAPAVCFlyTrace@@QAPAV2@ABQAV2@@Z ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Emplace_reallocate<CFlyTrace * const &>
PUBLIC	??$_Destroy_in_place@PAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXAAPAU?$pair@MUD3DXVECTOR3@@@0@@Z ; std::_Destroy_in_place<std::pair<float,D3DXVECTOR3> *>
PUBLIC	??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z ; std::uninitialized_copy<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PAPAU?$pair@MUD3DXVECTOR3@@@std@@I@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<std::pair<float,D3DXVECTOR3> * *,unsigned int>
PUBLIC	??$_Destroy_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@@Z ; std::_Destroy_range<std::pair<float,D3DXVECTOR3> * *>
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@std@@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@QAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<float,TFlyVertexSet> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAXPAPAVCFlyTrace@@QAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyTrace *> >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Copy_memmove@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@00@Z ; std::_Copy_memmove<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>
PUBLIC	??$_Zero_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0@Z ; std::_Zero_range<std::pair<float,D3DXVECTOR3> * *>
PUBLIC	??$_Uninitialized_move@PAU?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@QAU10@0PAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<float,TFlyVertexSet> *,std::allocator<std::pair<float,TFlyVertexSet> > >
PUBLIC	??$_Uninitialized_move@PAPAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAPAPAVCFlyTrace@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z ; std::_Uninitialized_move<CFlyTrace * *,std::allocator<CFlyTrace *> >
PUBLIC	??$_Sort_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >
PUBLIC	??$_Copy_memmove@PAPAVCFlyTrace@@PAPAV1@@std@@YAPAPAVCFlyTrace@@PAPAV1@00@Z ; std::_Copy_memmove<CFlyTrace * *,CFlyTrace * *>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MUTFlyVertexSet@@@std@@PAU12@@0@PAU?$pair@MUTFlyVertexSet@@@0@0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >
PUBLIC	??$_Pop_heap_hole_by_index@PAU?$pair@MUTFlyVertexSet@@@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<std::pair<float,TFlyVertexSet> *,std::pair<float,TFlyVertexSet>,std::less<void> >
PUBLIC	??$_Guess_median_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@00U?$less@X@0@@Z ; std::_Guess_median_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >
PUBLIC	??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A ; CFlyTrace::ms_kPool
PUBLIC	??_7CFlyTrace@@6B@				; CFlyTrace::`vftable'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CFlyTrace@@6B@				; CFlyTrace::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFlyTrace@@@8				; CFlyTrace `RTTI Type Descriptor'
PUBLIC	??_R3CFlyTrace@@8				; CFlyTrace::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFlyTrace@@8				; CFlyTrace::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CFlyTrace@@8			; CFlyTrace::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CScreen@@8			; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCScreen@@@8				; CScreen `RTTI Type Descriptor'
PUBLIC	??_R3CScreen@@8					; CScreen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CScreen@@8					; CScreen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXVec3TransformNormal@12:PROC
EXTRN	?GetCurrentSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetCurrentSecond
EXTRN	?UpdateViewMatrix@CGraphicBase@@QAEXXZ:PROC	; CGraphicBase::UpdateViewMatrix
EXTRN	?ViewVolumeTest@Frustum@@QBE?AW4ViewState@@ABVVector3d@@M@Z:PROC ; Frustum::ViewVolumeTest
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SaveVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SaveVertexShader
EXTRN	?RestoreVertexShader@CStateManager@@QAEXXZ:PROC	; CStateManager::RestoreVertexShader
EXTRN	?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SaveTransform
EXTRN	?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z:PROC ; CStateManager::RestoreTransform
EXTRN	?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z:PROC ; CStateManager::DrawPrimitiveUP
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	??_ECFlyTrace@@UAEPAXI@Z:PROC			; CFlyTrace::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	?ms_frustum@CScreen@@1VFrustum@@A:BYTE		; CScreen::ms_frustum
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CFlyTrace@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CFlyTrace@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$r	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$r	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CScreen@@8
rdata$r	SEGMENT
??_R2CScreen@@8 DD FLAT:??_R1A@?0A@EA@CScreen@@8	; CScreen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CScreen@@8
rdata$r	SEGMENT
??_R3CScreen@@8 DD 00H					; CScreen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCScreen@@@8
data$r	SEGMENT
??_R0?AVCScreen@@@8 DD FLAT:??_7type_info@@6B@		; CScreen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCScreen@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CScreen@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CScreen@@8 DD FLAT:??_R0?AVCScreen@@@8	; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CFlyTrace@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFlyTrace@@8 DD FLAT:??_R0?AVCFlyTrace@@@8 ; CFlyTrace::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CFlyTrace@@8
rdata$r	ENDS
;	COMDAT ??_R2CFlyTrace@@8
rdata$r	SEGMENT
??_R2CFlyTrace@@8 DD FLAT:??_R1A@?0A@EA@CFlyTrace@@8	; CFlyTrace::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CScreen@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CFlyTrace@@8
rdata$r	SEGMENT
??_R3CFlyTrace@@8 DD 00H				; CFlyTrace::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CFlyTrace@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFlyTrace@@@8
data$r	SEGMENT
??_R0?AVCFlyTrace@@@8 DD FLAT:??_7type_info@@6B@	; CFlyTrace `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFlyTrace@@', 00H
data$r	ENDS
;	COMDAT ??_R4CFlyTrace@@6B@
rdata$r	SEGMENT
??_R4CFlyTrace@@6B@ DD 00H				; CFlyTrace::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFlyTrace@@@8
	DD	FLAT:??_R3CFlyTrace@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CFlyTrace@@6B@
CONST	SEGMENT
??_7CFlyTrace@@6B@ DD FLAT:??_R4CFlyTrace@@6B@		; CFlyTrace::`vftable'
	DD	FLAT:??_ECFlyTrace@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A DD FLAT:??_7?$CDynamicPool@VCFlyTrace@@@@6B@ ; CFlyTrace::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCFlyTrace@@@@QAEPAVCFlyTrace@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCFlyTrace@@@@QAEPAVCFlyTrace@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCFlyTrace@@@@QAEPAVCFlyTrace@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCFlyTrace@@@@QAEPAVCFlyTrace@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@CFlyTrace@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@CFlyTrace@@SAPAV1@XZ$0
__ehfuncinfo$?New@CFlyTrace@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@CFlyTrace@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CFlyTrace@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CFlyTrace@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Render@CFlyTrace@@QAEXXZ$1
__ehfuncinfo$?Render@CFlyTrace@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Render@CFlyTrace@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CFlyTrace@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFlyTrace@@QAE@XZ$0
__ehfuncinfo$??0CFlyTrace@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CFlyTrace@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z
_TEXT	SEGMENT
__Tmp$1 = -144						; size = 144
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z PROC ; std::swap<float,TFlyVertexSet,0>, COMDAT

; 336  : void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 320  :         if (this != _STD addressof(_Right)) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]

; 336  : void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {

  00006	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 320  :         if (this != _STD addressof(_Right)) {

  0000c	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000f	3b ca		 cmp	 ecx, edx
  00011	74 3e		 je	 SHORT $LN4@swap

; 106  :     _Ty _Tmp = _STD move(_Left);

  00013	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 107  :     _Left    = _STD move(_Right);

  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	56		 push	 esi
  0001a	89 01		 mov	 DWORD PTR [ecx], eax

; 322  :             _Swap_adl(second, _Right.second);

  0001c	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 106  :     _Ty _Tmp = _STD move(_Left);

  0001f	57		 push	 edi

; 108  :     _Right   = _STD move(_Tmp);

  00020	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 106  :     _Ty _Tmp = _STD move(_Left);

  00024	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR __Tmp$1[ebp]
  0002a	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0002f	8b f0		 mov	 esi, eax
  00031	f3 a5		 rep movsd
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00033	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00038	8d 72 04	 lea	 esi, DWORD PTR [edx+4]
  0003b	8b f8		 mov	 edi, eax
  0003d	f3 a5		 rep movsd
  0003f	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00044	8d b5 70 ff ff
	ff		 lea	 esi, DWORD PTR __Tmp$1[ebp]
  0004a	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  0004d	f3 a5		 rep movsd
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
$LN4@swap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 338  : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ENDP ; std::swap<float,TFlyVertexSet,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@00U?$less@X@0@@Z
_TEXT	SEGMENT
tv899 = -8						; size = 4
__Last$1$ = -4						; size = 4
__First$1$ = 8						; size = 4
tv902 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@00U?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >, COMDAT

; 4019 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4020 :     // sort median element to middle
; 4021 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 4022 :     const _Diff _Count = _Last - _First;

  00006	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  0000b	53		 push	 ebx
  0000c	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000f	8b cb		 mov	 ecx, ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00015	2b ce		 sub	 ecx, esi
  00017	f7 e9		 imul	 ecx

; 4023 :     if (40 < _Count) { // Tukey's ninther

  00019	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0001d	57		 push	 edi
  0001e	03 d1		 add	 edx, ecx
  00020	c1 fa 07	 sar	 edx, 7
  00023	8b c2		 mov	 eax, edx
  00025	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00028	03 c2		 add	 eax, edx
  0002a	83 f8 28	 cmp	 eax, 40			; 00000028H
  0002d	0f 8e 3d 01 00
	00		 jle	 $LN2@Guess_medi

; 4024 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  00033	40		 inc	 eax
  00034	c1 f8 03	 sar	 eax, 3

; 4026 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00037	69 c8 28 01 00
	00		 imul	 ecx, eax, 296
  0003d	69 c0 94 00 00
	00		 imul	 eax, eax, 148
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00043	f3 0f 10 0c 30	 movss	 xmm1, DWORD PTR [eax+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4026 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00048	8d 1c 30	 lea	 ebx, DWORD PTR [eax+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0004b	0f 2f c1	 comiss	 xmm0, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4026 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0004e	89 4d f8	 mov	 DWORD PTR tv899[ebp], ecx
  00051	89 45 08	 mov	 DWORD PTR tv902[ebp], eax
  00054	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00057	76 0e		 jbe	 SHORT $LN6@Guess_medi

; 83   :     swap(*_Left, *_Right);

  00059	56		 push	 esi
  0005a	53		 push	 ebx
  0005b	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  00060	f3 0f 10 0b	 movss	 xmm1, DWORD PTR [ebx]
  00064	83 c4 08	 add	 esp, 8
$LN6@Guess_medi:

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00067	0f 2f 0f	 comiss	 xmm1, DWORD PTR [edi]
  0006a	76 1d		 jbe	 SHORT $LN8@Guess_medi

; 83   :     swap(*_Left, *_Right);

  0006c	53		 push	 ebx
  0006d	57		 push	 edi
  0006e	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00073	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]

; 83   :     swap(*_Left, *_Right);

  00077	83 c4 08	 add	 esp, 8

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0007a	0f 2f 03	 comiss	 xmm0, DWORD PTR [ebx]
  0007d	76 0a		 jbe	 SHORT $LN8@Guess_medi

; 83   :     swap(*_Left, *_Right);

  0007f	56		 push	 esi
  00080	53		 push	 ebx
  00081	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  00086	83 c4 08	 add	 esp, 8
$LN8@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4027 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00089	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  0008c	8b fe		 mov	 edi, esi
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR tv902[ebp]
  00091	2b f9		 sub	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00093	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00097	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4027 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  0009b	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0009e	0f 2f c1	 comiss	 xmm0, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4027 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  000a1	89 45 fc	 mov	 DWORD PTR __Last$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000a4	76 11		 jbe	 SHORT $LN38@Guess_medi

; 83   :     swap(*_Left, *_Right);

  000a6	57		 push	 edi
  000a7	56		 push	 esi
  000a8	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  000ad	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  000b1	83 c4 08	 add	 esp, 8
  000b4	8b 45 fc	 mov	 eax, DWORD PTR __Last$1$[ebp]
$LN38@Guess_medi:

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000b7	0f 2f 08	 comiss	 xmm1, DWORD PTR [eax]
  000ba	76 1d		 jbe	 SHORT $LN40@Guess_medi

; 83   :     swap(*_Left, *_Right);

  000bc	56		 push	 esi
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000c3	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]

; 83   :     swap(*_Left, *_Right);

  000c7	83 c4 08	 add	 esp, 8

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000ca	0f 2f 06	 comiss	 xmm0, DWORD PTR [esi]
  000cd	76 0a		 jbe	 SHORT $LN40@Guess_medi

; 83   :     swap(*_Left, *_Right);

  000cf	57		 push	 edi
  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  000d6	83 c4 08	 add	 esp, 8
$LN40@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4028 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  000d9	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  000dc	8b f8		 mov	 edi, eax
  000de	2b 7d 08	 sub	 edi, DWORD PTR tv902[ebp]
  000e1	8b c8		 mov	 ecx, eax
  000e3	2b 4d f8	 sub	 ecx, DWORD PTR tv899[ebp]
  000e6	89 4d 08	 mov	 DWORD PTR __First$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000e9	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  000ed	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  000f1	0f 2f c1	 comiss	 xmm0, xmm1
  000f4	76 11		 jbe	 SHORT $LN70@Guess_medi

; 83   :     swap(*_Left, *_Right);

  000f6	51		 push	 ecx
  000f7	57		 push	 edi
  000f8	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  000fd	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  00101	83 c4 08	 add	 esp, 8
  00104	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
$LN70@Guess_medi:

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00107	0f 2f 08	 comiss	 xmm1, DWORD PTR [eax]
  0010a	76 20		 jbe	 SHORT $LN72@Guess_medi

; 83   :     swap(*_Left, *_Right);

  0010c	57		 push	 edi
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00113	8b 45 08	 mov	 eax, DWORD PTR __First$1$[ebp]

; 83   :     swap(*_Left, *_Right);

  00116	83 c4 08	 add	 esp, 8

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00119	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0011d	0f 2f 07	 comiss	 xmm0, DWORD PTR [edi]
  00120	76 0a		 jbe	 SHORT $LN72@Guess_medi

; 83   :     swap(*_Left, *_Right);

  00122	50		 push	 eax
  00123	57		 push	 edi
  00124	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  00129	83 c4 08	 add	 esp, 8
$LN72@Guess_medi:

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0012c	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00130	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  00134	0f 2f c1	 comiss	 xmm0, xmm1
  00137	76 0e		 jbe	 SHORT $LN102@Guess_medi

; 83   :     swap(*_Left, *_Right);

  00139	53		 push	 ebx
  0013a	56		 push	 esi
  0013b	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  00140	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00144	83 c4 08	 add	 esp, 8
$LN102@Guess_medi:

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00147	0f 2f 0f	 comiss	 xmm1, DWORD PTR [edi]
  0014a	76 60		 jbe	 SHORT $LN136@Guess_medi

; 83   :     swap(*_Left, *_Right);

  0014c	56		 push	 esi
  0014d	57		 push	 edi
  0014e	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00153	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]

; 83   :     swap(*_Left, *_Right);

  00157	83 c4 08	 add	 esp, 8

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0015a	0f 2f 06	 comiss	 xmm0, DWORD PTR [esi]
  0015d	76 4d		 jbe	 SHORT $LN136@Guess_medi

; 83   :     swap(*_Left, *_Right);

  0015f	53		 push	 ebx
  00160	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4033 : }

  00161	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  00166	83 c4 08	 add	 esp, 8
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
$LN2@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00170	8b 7d 0c	 mov	 edi, DWORD PTR __Mid$[ebp]
  00173	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  00177	0f 2f c1	 comiss	 xmm0, xmm1
  0017a	76 0e		 jbe	 SHORT $LN134@Guess_medi

; 83   :     swap(*_Left, *_Right);

  0017c	56		 push	 esi
  0017d	57		 push	 edi
  0017e	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  00183	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  00187	83 c4 08	 add	 esp, 8
$LN134@Guess_medi:

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0018a	0f 2f 0b	 comiss	 xmm1, DWORD PTR [ebx]
  0018d	76 1d		 jbe	 SHORT $LN136@Guess_medi

; 83   :     swap(*_Left, *_Right);

  0018f	57		 push	 edi
  00190	53		 push	 ebx
  00191	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00196	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]

; 83   :     swap(*_Left, *_Right);

  0019a	83 c4 08	 add	 esp, 8

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0019d	0f 2f 07	 comiss	 xmm0, DWORD PTR [edi]
  001a0	76 0a		 jbe	 SHORT $LN136@Guess_medi

; 83   :     swap(*_Left, *_Right);

  001a2	56		 push	 esi
  001a3	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4033 : }

  001a4	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  001a9	83 c4 08	 add	 esp, 8
$LN136@Guess_medi:
  001ac	5f		 pop	 edi
  001ad	5e		 pop	 esi
  001ae	5b		 pop	 ebx
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
??$_Guess_median_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@00U?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAU?$pair@MUTFlyVertexSet@@@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@HH$$QAU10@U?$less@X@0@@Z
_TEXT	SEGMENT
tv516 = -8						; size = 4
__Max_sequence_non_leaf$1$ = -4				; size = 4
__Idx$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Top$1$ = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAU?$pair@MUTFlyVertexSet@@@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@HH$$QAU10@U?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<std::pair<float,TFlyVertexSet> *,std::pair<float,TFlyVertexSet>,std::less<void> >, COMDAT

; 3354 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3355 :     // percolate _Hole to _Bottom, then push _Val, using _Pred
; 3356 :     _STL_INTERNAL_CHECK(_Bottom != 0);
; 3357 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 3358 :     const _Diff _Top = _Hole;
; 3359 :     _Diff _Idx       = _Hole;
; 3360 : 
; 3361 :     // Check whether _Idx can have a child before calculating that child's index, since
; 3362 :     // calculating the child's index can trigger integer overflows
; 3363 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Bottom$[ebp]
  00009	53		 push	 ebx

; 3364 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	49		 dec	 ecx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  00013	8b d7		 mov	 edx, edi
  00015	89 4d f8	 mov	 DWORD PTR tv516[ebp], ecx
  00018	8b c7		 mov	 eax, edi
  0001a	d1 f9		 sar	 ecx, 1
  0001c	89 55 0c	 mov	 DWORD PTR __Top$1$[ebp], edx
  0001f	89 4d fc	 mov	 DWORD PTR __Max_sequence_non_leaf$1$[ebp], ecx
  00022	3b f9		 cmp	 edi, ecx
  00024	7d 64		 jge	 SHORT $LN3@Pop_heap_h
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@Pop_heap_h:

; 3365 :         _Idx = 2 * _Idx + 2;

  00030	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]

; 3366 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00033	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00036	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
  0003c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0003f	69 c0 94 00 00
	00		 imul	 eax, eax, 148

; 3369 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00045	f3 0f 10 04 18	 movss	 xmm0, DWORD PTR [eax+ebx]
  0004a	33 c0		 xor	 eax, eax
  0004c	0f 2f 04 19	 comiss	 xmm0, DWORD PTR [ecx+ebx]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00050	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3369 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00055	0f 96 c0	 setbe	 al
  00058	69 ff 94 00 00
	00		 imul	 edi, edi, 148
  0005e	40		 inc	 eax
  0005f	03 fb		 add	 edi, ebx
  00061	03 c2		 add	 eax, edx
  00063	69 f0 94 00 00
	00		 imul	 esi, eax, 148
  00069	89 45 08	 mov	 DWORD PTR __Idx$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  0006c	8b 04 1e	 mov	 eax, DWORD PTR [esi+ebx]
  0006f	89 07		 mov	 DWORD PTR [edi], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00071	83 c7 04	 add	 edi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3370 :         _Hole             = _Idx;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Idx$1$[ebp]
  00077	03 f3		 add	 esi, ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00079	83 c6 04	 add	 esi, 4
  0007c	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3364 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __Max_sequence_non_leaf$1$[ebp]

; 3370 :         _Hole             = _Idx;

  00081	8b f8		 mov	 edi, eax
  00083	3b c1		 cmp	 eax, ecx
  00085	7c a9		 jl	 SHORT $LL2@Pop_heap_h
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Top$1$[ebp]
$LN3@Pop_heap_h:

; 3371 :     }
; 3372 : 
; 3373 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  0008a	3b c1		 cmp	 eax, ecx
  0008c	75 33		 jne	 SHORT $LN5@Pop_heap_h
  0008e	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00091	a8 01		 test	 al, 1
  00093	75 2c		 jne	 SHORT $LN5@Pop_heap_h

; 3374 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  00095	69 ff 94 00 00
	00		 imul	 edi, edi, 148
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0009b	8d b3 70 ff ff
	ff		 lea	 esi, DWORD PTR [ebx-144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3374 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a1	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
  000a7	03 fb		 add	 edi, ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  000a9	03 f1		 add	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  000ab	8b 84 19 6c ff
	ff ff		 mov	 eax, DWORD PTR [ecx+ebx-148]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  000b2	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  000b7	89 07		 mov	 DWORD PTR [edi], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  000b9	83 c7 04	 add	 edi, 4
  000bc	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3375 :         _Hole             = _Bottom - 1;

  000be	8b 7d f8	 mov	 edi, DWORD PTR tv516[ebp]
$LN5@Pop_heap_h:

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000c1	3b d7		 cmp	 edx, edi
  000c3	8b 55 14	 mov	 edx, DWORD PTR __Val$[ebp]
  000c6	7d 43		 jge	 SHORT $LN54@Pop_heap_h
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL25@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000d0	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3320 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  000d4	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  000d7	d1 f8		 sar	 eax, 1

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000d9	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000df	f3 0f 10 0c 19	 movss	 xmm1, DWORD PTR [ecx+ebx]
  000e4	0f 2f c1	 comiss	 xmm0, xmm1
  000e7	76 22		 jbe	 SHORT $LN54@Pop_heap_h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3324 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  000e9	69 ff 94 00 00
	00		 imul	 edi, edi, 148
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  000ef	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3324 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  000f2	03 fb		 add	 edi, ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  000f4	03 f1		 add	 esi, ecx
  000f6	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  000fb	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  000ff	83 c7 04	 add	 edi, 4
  00102	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3325 :         _Hole             = _Idx;

  00104	8b f8		 mov	 edi, eax
  00106	39 45 0c	 cmp	 DWORD PTR __Top$1$[ebp], eax
  00109	7c c5		 jl	 SHORT $LL25@Pop_heap_h
$LN54@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  0010b	8b 02		 mov	 eax, DWORD PTR [edx]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0010d	8d 72 04	 lea	 esi, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3328 :     *(_First + _Hole) = _STD move(_Val); // drop _Val into final hole

  00110	69 ff 94 00 00
	00		 imul	 edi, edi, 148
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00116	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3328 :     *(_First + _Hole) = _STD move(_Val); // drop _Val into final hole

  0011b	03 fb		 add	 edi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  0011d	89 07		 mov	 DWORD PTR [edi], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0011f	83 c7 04	 add	 edi, 4
  00122	f3 a5		 rep movsd
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3379 : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAU?$pair@MUTFlyVertexSet@@@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@HH$$QAU10@U?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<std::pair<float,TFlyVertexSet> *,std::pair<float,TFlyVertexSet>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MUTFlyVertexSet@@@std@@PAU12@@0@PAU?$pair@MUTFlyVertexSet@@@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
tv755 = -12						; size = 4
__Gfirst$1$ = -8					; size = 4
__Glast$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Partition_by_median_guess_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MUTFlyVertexSet@@@std@@PAU12@@0@PAU?$pair@MUTFlyVertexSet@@@0@0U?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >, COMDAT

; 4036 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4037 :     // partition [_First, _Last), using _Pred
; 4038 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  00006	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  0000b	53		 push	 ebx
  0000c	8b 5d 0c	 mov	 ebx, DWORD PTR __First$[ebp]
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  00014	8b cf		 mov	 ecx, edi

; 4039 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  00016	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00019	2b cb		 sub	 ecx, ebx
  0001b	f7 e9		 imul	 ecx
  0001d	03 d1		 add	 edx, ecx
  0001f	c1 fa 07	 sar	 edx, 7
  00022	8b c2		 mov	 eax, edx
  00024	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00027	03 c2		 add	 eax, edx
  00029	d1 f8		 sar	 eax, 1
  0002b	69 f0 94 00 00
	00		 imul	 esi, eax, 148
  00031	8d 87 6c ff ff
	ff		 lea	 eax, DWORD PTR [edi-148]
  00037	50		 push	 eax
  00038	03 f3		 add	 esi, ebx
  0003a	56		 push	 esi
  0003b	53		 push	 ebx
  0003c	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@00U?$less@X@0@@Z ; std::_Guess_median_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >

; 4040 :     _RanIt _Pfirst = _Mid;
; 4041 :     _RanIt _Plast  = _Next_iter(_Pfirst);
; 4042 : 
; 4043 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 4044 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00041	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00044	8d 9e 94 00 00
	00		 lea	 ebx, DWORD PTR [esi+148]
  0004a	83 c4 10	 add	 esp, 16			; 00000010H
  0004d	3b d6		 cmp	 edx, esi
  0004f	73 2e		 jae	 SHORT $LN140@Partition_
  00051	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00060	f3 0f 10 86 6c
	ff ff ff	 movss	 xmm0, DWORD PTR [esi-148]
  00068	0f 2f c8	 comiss	 xmm1, xmm0
  0006b	77 12		 ja	 SHORT $LN140@Partition_
  0006d	0f 2f c1	 comiss	 xmm0, xmm1
  00070	77 0d		 ja	 SHORT $LN140@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4045 :         --_Pfirst;

  00072	81 c6 6c ff ff
	ff		 add	 esi, -148		; ffffff6cH
  00078	0f 28 c8	 movaps	 xmm1, xmm0
  0007b	3b d6		 cmp	 edx, esi
  0007d	72 e1		 jb	 SHORT $LL2@Partition_
$LN140@Partition_:

; 4048 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  0007f	8b cf		 mov	 ecx, edi
  00081	3b d9		 cmp	 ebx, ecx
  00083	73 23		 jae	 SHORT $LN141@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00085	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Partition_:
  00090	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  00094	0f 2f c8	 comiss	 xmm1, xmm0
  00097	77 0f		 ja	 SHORT $LN141@Partition_
  00099	0f 2f c1	 comiss	 xmm0, xmm1
  0009c	77 0a		 ja	 SHORT $LN141@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4048 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  0009e	81 c3 94 00 00
	00		 add	 ebx, 148		; 00000094H
  000a4	3b d9		 cmp	 ebx, ecx
  000a6	72 e8		 jb	 SHORT $LL4@Partition_
$LN141@Partition_:

; 4049 :         ++_Plast;
; 4050 :     }
; 4051 : 
; 4052 :     _RanIt _Gfirst = _Plast;

  000a8	8b fb		 mov	 edi, ebx

; 4053 :     _RanIt _Glast  = _Pfirst;

  000aa	8b c6		 mov	 eax, esi
  000ac	89 7d f8	 mov	 DWORD PTR __Gfirst$1$[ebp], edi
  000af	89 45 fc	 mov	 DWORD PTR __Glast$1$[ebp], eax
$LL6@Partition_:

; 4054 : 
; 4055 :     for (;;) { // partition
; 4056 :         for (; _Gfirst < _Last; ++_Gfirst) {

  000b2	3b f9		 cmp	 edi, ecx
  000b4	73 50		 jae	 SHORT $LN74@Partition_
  000b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL11@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000c0	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  000c4	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  000c8	0f 2f c1	 comiss	 xmm0, xmm1
  000cb	77 26		 ja	 SHORT $LN9@Partition_
  000cd	0f 2f c8	 comiss	 xmm1, xmm0
  000d0	77 2b		 ja	 SHORT $LN142@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4060 :             } else if (_Plast != _Gfirst) {

  000d2	8d 83 94 00 00
	00		 lea	 eax, DWORD PTR [ebx+148]
  000d8	89 45 f4	 mov	 DWORD PTR tv755[ebp], eax
  000db	3b df		 cmp	 ebx, edi
  000dd	74 12		 je	 SHORT $LN19@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 83   :     swap(*_Left, *_Right);

  000df	57		 push	 edi
  000e0	53		 push	 ebx
  000e1	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4062 :                 ++_Plast;

  000e6	8b 5d f4	 mov	 ebx, DWORD PTR tv755[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 83   :     swap(*_Left, *_Right);

  000e9	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4063 :             } else {

  000ec	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000ef	eb 02		 jmp	 SHORT $LN9@Partition_
$LN19@Partition_:

; 4064 :                 ++_Plast;

  000f1	8b d8		 mov	 ebx, eax
$LN9@Partition_:

; 4054 : 
; 4055 :     for (;;) { // partition
; 4056 :         for (; _Gfirst < _Last; ++_Gfirst) {

  000f3	81 c7 94 00 00
	00		 add	 edi, 148		; 00000094H
  000f9	3b f9		 cmp	 edi, ecx
  000fb	72 c3		 jb	 SHORT $LL11@Partition_
$LN142@Partition_:
  000fd	8b 45 fc	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  00100	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00103	89 7d f8	 mov	 DWORD PTR __Gfirst$1$[ebp], edi
$LN74@Partition_:

; 4068 :         for (; _First < _Glast; --_Glast) {

  00106	89 7d f4	 mov	 DWORD PTR $T2[ebp], edi
  00109	3b d0		 cmp	 edx, eax
  0010b	73 4a		 jae	 SHORT $LN90@Partition_
  0010d	8d b8 6c ff ff
	ff		 lea	 edi, DWORD PTR [eax-148]
$LL14@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00113	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  00117	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0011b	0f 2f c1	 comiss	 xmm0, xmm1
  0011e	77 1f		 ja	 SHORT $LN12@Partition_
  00120	0f 2f c8	 comiss	 xmm1, xmm0
  00123	77 2c		 ja	 SHORT $LN143@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4072 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  00125	81 ee 94 00 00
	00		 sub	 esi, 148		; 00000094H
  0012b	3b f7		 cmp	 esi, edi
  0012d	74 10		 je	 SHORT $LN12@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 83   :     swap(*_Left, *_Right);

  0012f	57		 push	 edi
  00130	56		 push	 esi
  00131	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  00136	8b 45 fc	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  00139	83 c4 08	 add	 esp, 8
  0013c	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
$LN12@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4068 :         for (; _First < _Glast; --_Glast) {

  0013f	2d 94 00 00 00	 sub	 eax, 148		; 00000094H
  00144	81 ef 94 00 00
	00		 sub	 edi, 148		; 00000094H
  0014a	89 45 fc	 mov	 DWORD PTR __Glast$1$[ebp], eax
  0014d	3b d0		 cmp	 edx, eax
  0014f	72 c2		 jb	 SHORT $LL14@Partition_
$LN143@Partition_:
  00151	8b 7d f8	 mov	 edi, DWORD PTR __Gfirst$1$[ebp]
  00154	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
$LN90@Partition_:

; 4073 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 4074 :             }
; 4075 :         }
; 4076 : 
; 4077 :         if (_Glast == _First && _Gfirst == _Last) {

  00157	89 75 f0	 mov	 DWORD PTR $T1[ebp], esi
  0015a	3b c2		 cmp	 eax, edx
  0015c	75 26		 jne	 SHORT $LN27@Partition_
  0015e	3b f9		 cmp	 edi, ecx
  00160	74 75		 je	 SHORT $LN114@Partition_

; 4079 :         }
; 4080 : 
; 4081 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 4082 :             if (_Plast != _Gfirst) {

  00162	3b df		 cmp	 ebx, edi
  00164	74 0a		 je	 SHORT $LN29@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 83   :     swap(*_Left, *_Right);

  00166	53		 push	 ebx
  00167	56		 push	 esi
  00168	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  0016d	83 c4 08	 add	 esp, 8
$LN29@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4089 :             ++_Gfirst;

  00170	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00173	81 c3 94 00 00
	00		 add	 ebx, 148		; 00000094H
  00179	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  0017c	81 c6 94 00 00
	00		 add	 esi, 148		; 00000094H
  00182	eb 32		 jmp	 SHORT $LN144@Partition_
$LN27@Partition_:

; 4090 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  00184	05 6c ff ff ff	 add	 eax, -148		; ffffff6cH
  00189	89 45 fc	 mov	 DWORD PTR __Glast$1$[ebp], eax
  0018c	3b f9		 cmp	 edi, ecx
  0018e	75 20		 jne	 SHORT $LN30@Partition_

; 4091 :             if (--_Glast != --_Pfirst) {

  00190	81 ee 94 00 00
	00		 sub	 esi, 148		; 00000094H
  00196	3b c6		 cmp	 eax, esi
  00198	74 0a		 je	 SHORT $LN32@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 83   :     swap(*_Left, *_Right);

  0019a	56		 push	 esi
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  001a1	83 c4 08	 add	 esp, 8
$LN32@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4095 :             _STD iter_swap(_Pfirst, --_Plast);

  001a4	81 eb 94 00 00
	00		 sub	 ebx, 148		; 00000094H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 83   :     swap(*_Left, *_Right);

  001aa	8b ce		 mov	 ecx, esi
  001ac	8b c3		 mov	 eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4096 :         } else {

  001ae	eb 0f		 jmp	 SHORT $LN31@Partition_
$LN30@Partition_:

; 4097 :             _STD iter_swap(_Gfirst, --_Glast);
; 4098 :             ++_Gfirst;

  001b0	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  001b3	89 45 fc	 mov	 DWORD PTR __Glast$1$[ebp], eax
$LN144@Partition_:

; 4099 :         }
; 4100 :     }

  001b6	81 c7 94 00 00
	00		 add	 edi, 148		; 00000094H
  001bc	89 7d f8	 mov	 DWORD PTR __Gfirst$1$[ebp], edi
$LN31@Partition_:
  001bf	50		 push	 eax
  001c0	51		 push	 ecx
  001c1	e8 00 00 00 00	 call	 ??$swap@MUTFlyVertexSet@@$0A@@std@@YAXAAU?$pair@MUTFlyVertexSet@@@0@0@Z ; std::swap<float,TFlyVertexSet,0>
  001c6	8b 45 fc	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  001c9	83 c4 08	 add	 esp, 8
  001cc	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  001cf	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  001d2	e9 db fe ff ff	 jmp	 $LL6@Partition_
$LN114@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001d7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4078 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  001da	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001db	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4078 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  001dd	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001de	89 58 04	 mov	 DWORD PTR [eax+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4078 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  001e1	5b		 pop	 ebx

; 4101 : }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MUTFlyVertexSet@@@std@@PAU12@@0@PAU?$pair@MUTFlyVertexSet@@@0@0U?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCFlyTrace@@PAPAV1@@std@@YAPAPAVCFlyTrace@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCFlyTrace@@PAPAV1@@std@@YAPAPAVCFlyTrace@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CFlyTrace * *,CFlyTrace * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCFlyTrace@@PAPAV1@@std@@YAPAPAVCFlyTrace@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CFlyTrace * *,CFlyTrace * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Val$1 = -176						; size = 148
__Val$2 = -176						; size = 148
__Val$3 = -176						; size = 148
tv1083 = -28						; size = 4
tv1090 = -24						; size = 4
__Hole$1$ = -20						; size = 4
__Idx$1$ = -16						; size = 4
__Bottom$1$ = -12					; size = 4
__Mid$4 = -8						; size = 8
tv1073 = -4						; size = 4
__Max_sequence_non_leaf$1$ = 8				; size = 4
tv1075 = 8						; size = 4
__Next$1$ = 8						; size = 4
__First$ = 8						; size = 4
tv1082 = 12						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@0HU?$less@X@0@@Z PROC ; std::_Sort_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >, COMDAT

; 4104 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00009	53		 push	 ebx

; 4105 :     // order [_First, _Last), using _Pred
; 4106 :     for (;;) {
; 4107 :         if (_Last - _First <= _ISORT_MAX) { // small

  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00011	8b c6		 mov	 eax, esi
  00013	2b c3		 sub	 eax, ebx
  00015	57		 push	 edi
  00016	3d 14 13 00 00	 cmp	 eax, 4884		; 00001314H
  0001b	0f 8c 94 00 00
	00		 jl	 $LN124@Sort_unche
  00021	8b 7d 10	 mov	 edi, DWORD PTR __Ideal$[ebp]
$LL2@Sort_unche:

; 4108 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 4109 :             return;
; 4110 :         }
; 4111 : 
; 4112 :         if (_Ideal <= 0) { // heap sort if too many divisions

  00024	85 ff		 test	 edi, edi
  00026	0f 8e ff 00 00
	00		 jle	 $LN125@Sort_unche

; 4115 :             return;
; 4116 :         }
; 4117 : 
; 4118 :         // divide and conquer by quicksort
; 4119 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  0002c	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0002f	8d 45 f8	 lea	 eax, DWORD PTR __Mid$4[ebp]
  00032	56		 push	 esi
  00033	53		 push	 ebx
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MUTFlyVertexSet@@@std@@PAU12@@0@PAU?$pair@MUTFlyVertexSet@@@0@0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >

; 4120 : 
; 4121 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  0003a	8b c7		 mov	 eax, edi

; 4122 : 
; 4123 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  0003c	8b ce		 mov	 ecx, esi
  0003e	2b 4d fc	 sub	 ecx, DWORD PTR __Mid$4[ebp+4]
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	c1 f8 02	 sar	 eax, 2
  00047	d1 ff		 sar	 edi, 1
  00049	03 f8		 add	 edi, eax
  0004b	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00050	f7 e9		 imul	 ecx
  00052	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00057	03 d1		 add	 edx, ecx
  00059	8b 4d f8	 mov	 ecx, DWORD PTR __Mid$4[ebp]
  0005c	c1 fa 07	 sar	 edx, 7
  0005f	2b cb		 sub	 ecx, ebx
  00061	8b f2		 mov	 esi, edx
  00063	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00066	03 f2		 add	 esi, edx
  00068	f7 e9		 imul	 ecx
  0006a	03 d1		 add	 edx, ecx
  0006c	c1 fa 07	 sar	 edx, 7
  0006f	8b c2		 mov	 eax, edx
  00071	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00074	03 c2		 add	 eax, edx
  00076	3b c6		 cmp	 eax, esi
  00078	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  0007b	50		 push	 eax
  0007c	57		 push	 edi
  0007d	7d 12		 jge	 SHORT $LN7@Sort_unche

; 4124 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  0007f	8b 75 f8	 mov	 esi, DWORD PTR __Mid$4[ebp]
  00082	56		 push	 esi
  00083	53		 push	 ebx
  00084	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >

; 4125 :             _First = _Mid.second;

  00089	8b 5d fc	 mov	 ebx, DWORD PTR __Mid$4[ebp+4]

; 4126 :         } else { // loop on first half

  0008c	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0008f	eb 12		 jmp	 SHORT $LN159@Sort_unche
$LN7@Sort_unche:

; 4127 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  00091	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00094	8b 45 fc	 mov	 eax, DWORD PTR __Mid$4[ebp+4]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >

; 4128 :             _Last = _Mid.first;

  0009d	8b 75 f8	 mov	 esi, DWORD PTR __Mid$4[ebp]
  000a0	89 75 0c	 mov	 DWORD PTR __Last$[ebp], esi
$LN159@Sort_unche:

; 4105 :     // order [_First, _Last), using _Pred
; 4106 :     for (;;) {
; 4107 :         if (_Last - _First <= _ISORT_MAX) { // small

  000a3	8b c6		 mov	 eax, esi
  000a5	83 c4 10	 add	 esp, 16			; 00000010H
  000a8	2b c3		 sub	 eax, ebx
  000aa	3d 14 13 00 00	 cmp	 eax, 4884		; 00001314H
  000af	0f 8d 6f ff ff
	ff		 jge	 $LL2@Sort_unche
$LN124@Sort_unche:

; 3981 :     if (_First != _Last) {

  000b5	3b de		 cmp	 ebx, esi
  000b7	0f 84 c4 02 00
	00		 je	 $LN103@Sort_unche

; 3982 :         for (_BidIt _Next = _First; ++_Next != _Last;) { // order next element

  000bd	8d 83 94 00 00
	00		 lea	 eax, DWORD PTR [ebx+148]
  000c3	89 45 08	 mov	 DWORD PTR __Next$1$[ebp], eax
  000c6	3b c6		 cmp	 eax, esi
  000c8	0f 84 b3 02 00
	00		 je	 $LN103@Sort_unche
  000ce	66 90		 npad	 2
$LL11@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000d0	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3984 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Next);

  000d4	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR __Val$3[ebp]
  000da	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  000df	8b f0		 mov	 esi, eax
  000e1	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000e3	f3 0f 10 8d 50
	ff ff ff	 movss	 xmm1, DWORD PTR __Val$3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3983 :             _BidIt _Next1              = _Next;

  000eb	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  000ed	0f 2f c1	 comiss	 xmm0, xmm1
  000f0	0f 87 34 02 00
	00		 ja	 $LN140@Sort_unche
  000f6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL16@Sort_unche:
  00100	f3 0f 10 80 6c
	ff ff ff	 movss	 xmm0, DWORD PTR [eax-148]
  00108	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3990 :                 for (_BidIt _First1 = _Next1; _DEBUG_LT_PRED(_Pred, _Val, *--_First1); _Next1 = _First1) {

  0010b	2d 94 00 00 00	 sub	 eax, 148		; 00000094H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00110	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00115	0f 2f c1	 comiss	 xmm0, xmm1
  00118	0f 86 03 02 00
	00		 jbe	 $LN155@Sort_unche

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  0011e	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00122	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  00125	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3990 :                 for (_BidIt _First1 = _Next1; _DEBUG_LT_PRED(_Pred, _Val, *--_First1); _Next1 = _First1) {

  00127	8b d0		 mov	 edx, eax
  00129	eb d5		 jmp	 SHORT $LL16@Sort_unche
$LN125@Sort_unche:

; 3419 :     _Diff _Bottom = _Last - _First;

  0012b	8b ce		 mov	 ecx, esi
  0012d	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00132	2b cb		 sub	 ecx, ebx
  00134	f7 e9		 imul	 ecx
  00136	89 4d fc	 mov	 DWORD PTR tv1073[ebp], ecx
  00139	03 d1		 add	 edx, ecx
  0013b	c1 fa 07	 sar	 edx, 7
  0013e	8b c2		 mov	 eax, edx
  00140	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00143	03 c2		 add	 eax, edx

; 3420 :     for (_Diff _Hole = _Bottom >> 1; 0 < _Hole;) { // shift for codegen

  00145	8b d0		 mov	 edx, eax
  00147	89 45 f4	 mov	 DWORD PTR __Bottom$1$[ebp], eax
  0014a	d1 fa		 sar	 edx, 1
  0014c	85 d2		 test	 edx, edx
  0014e	0f 8e 42 01 00
	00		 jle	 $LN57@Sort_unche
  00154	48		 dec	 eax
  00155	89 45 e8	 mov	 DWORD PTR tv1090[ebp], eax
  00158	d1 f8		 sar	 eax, 1
  0015a	89 45 08	 mov	 DWORD PTR __Max_sequence_non_leaf$1$[ebp], eax

; 3397 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 3398 :     }
; 3399 : }
; 3400 : 
; 3401 : template <class _RanIt, class _Pr>
; 3402 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 3403 :     // pop *_First to *(_Last - 1) and reheap, using _Pred
; 3404 :     _Adl_verify_range(_First, _Last);
; 3405 :     _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
; 3406 : }
; 3407 : 
; 3408 : template <class _RanIt>
; 3409 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last) {
; 3410 :     // pop *_First to *(_Last - 1) and reheap, using operator<
; 3411 :     _STD pop_heap(_First, _Last, less<>());
; 3412 : }
; 3413 : 
; 3414 : // FUNCTION TEMPLATE make_heap
; 3415 : template <class _RanIt, class _Pr>
; 3416 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 3417 :     // make nontrivial [_First, _Last) into a heap, using _Pred
; 3418 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 3419 :     _Diff _Bottom = _Last - _First;

  0015d	69 c2 94 00 00
	00		 imul	 eax, edx, 148
  00163	03 c3		 add	 eax, ebx
  00165	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL56@Sort_unche:

; 3421 :         // reheap top half, bottom to top
; 3422 :         --_Hole;

  00170	2d 94 00 00 00	 sub	 eax, 148		; 00000094H

; 3423 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00175	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR __Val$2[ebp]
  0017b	4a		 dec	 edx
  0017c	89 45 e4	 mov	 DWORD PTR tv1083[ebp], eax
  0017f	8b f0		 mov	 esi, eax
  00181	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H

; 3359 :     _Diff _Idx       = _Hole;

  00186	8b c2		 mov	 eax, edx

; 3422 :         --_Hole;

  00188	89 55 ec	 mov	 DWORD PTR __Hole$1$[ebp], edx

; 3423 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  0018b	f3 a5		 rep movsd

; 3424 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  0018d	8b fa		 mov	 edi, edx

; 3364 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0018f	3b 55 08	 cmp	 edx, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
  00192	7d 58		 jge	 SHORT $LN62@Sort_unche
$LL61@Sort_unche:

; 3365 :         _Idx = 2 * _Idx + 2;

  00194	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]

; 3366 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00197	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0019a	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
  001a0	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001a3	69 c0 94 00 00
	00		 imul	 eax, eax, 148

; 3369 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  001a9	f3 0f 10 04 18	 movss	 xmm0, DWORD PTR [eax+ebx]
  001ae	33 c0		 xor	 eax, eax
  001b0	0f 2f 04 19	 comiss	 xmm0, DWORD PTR [ecx+ebx]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  001b4	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3369 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  001b9	0f 96 c0	 setbe	 al
  001bc	69 ff 94 00 00
	00		 imul	 edi, edi, 148
  001c2	40		 inc	 eax
  001c3	03 fb		 add	 edi, ebx
  001c5	03 c2		 add	 eax, edx
  001c7	69 f0 94 00 00
	00		 imul	 esi, eax, 148
  001cd	89 45 f0	 mov	 DWORD PTR __Idx$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  001d0	8b 04 1e	 mov	 eax, DWORD PTR [esi+ebx]
  001d3	89 07		 mov	 DWORD PTR [edi], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  001d5	83 c7 04	 add	 edi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3370 :         _Hole             = _Idx;

  001d8	8b 45 f0	 mov	 eax, DWORD PTR __Idx$1$[ebp]
  001db	03 f3		 add	 esi, ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  001dd	83 c6 04	 add	 esi, 4
  001e0	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3370 :         _Hole             = _Idx;

  001e2	8b f8		 mov	 edi, eax
  001e4	3b 45 08	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
  001e7	7c ab		 jl	 SHORT $LL61@Sort_unche
  001e9	8b 55 ec	 mov	 edx, DWORD PTR __Hole$1$[ebp]
$LN62@Sort_unche:

; 3371 :     }
; 3372 : 
; 3373 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  001ec	3b 7d 08	 cmp	 edi, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
  001ef	75 33		 jne	 SHORT $LN64@Sort_unche
  001f1	8b 45 f4	 mov	 eax, DWORD PTR __Bottom$1$[ebp]
  001f4	a8 01		 test	 al, 1
  001f6	75 2c		 jne	 SHORT $LN64@Sort_unche

; 3374 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  001f8	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
  001fe	69 ff 94 00 00
	00		 imul	 edi, edi, 148
  00204	03 fb		 add	 edi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  00206	8b 84 19 6c ff
	ff ff		 mov	 eax, DWORD PTR [ecx+ebx-148]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0020d	8d b1 70 ff ff
	ff		 lea	 esi, DWORD PTR [ecx-144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  00213	89 07		 mov	 DWORD PTR [edi], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00215	03 f3		 add	 esi, ebx
  00217	83 c7 04	 add	 edi, 4
  0021a	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0021f	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3375 :         _Hole             = _Bottom - 1;

  00221	8b 7d e8	 mov	 edi, DWORD PTR tv1090[ebp]
$LN64@Sort_unche:

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00224	f3 0f 10 8d 50
	ff ff ff	 movss	 xmm1, DWORD PTR __Val$2[ebp]
  0022c	3b d7		 cmp	 edx, edi
  0022e	7d 36		 jge	 SHORT $LN158@Sort_unche
$LL84@Sort_unche:

; 3320 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00230	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00233	d1 f8		 sar	 eax, 1

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00235	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0023b	f3 0f 10 04 19	 movss	 xmm0, DWORD PTR [ecx+ebx]
  00240	0f 2f c8	 comiss	 xmm1, xmm0
  00243	76 21		 jbe	 SHORT $LN158@Sort_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3324 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00245	69 ff 94 00 00
	00		 imul	 edi, edi, 148
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0024b	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3324 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0024e	03 fb		 add	 edi, ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00250	03 f3		 add	 esi, ebx
  00252	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  00257	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0025b	83 c7 04	 add	 edi, 4
  0025e	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3325 :         _Hole             = _Idx;

  00260	8b f8		 mov	 edi, eax
  00262	3b d0		 cmp	 edx, eax
  00264	7c ca		 jl	 SHORT $LL84@Sort_unche
$LN158@Sort_unche:

; 3420 :     for (_Diff _Hole = _Bottom >> 1; 0 < _Hole;) { // shift for codegen

  00266	8b 45 e4	 mov	 eax, DWORD PTR tv1083[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00269	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR __Val$2[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3328 :     *(_First + _Hole) = _STD move(_Val); // drop _Val into final hole

  0026f	69 ff 94 00 00
	00		 imul	 edi, edi, 148
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00275	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3328 :     *(_First + _Hole) = _STD move(_Val); // drop _Val into final hole

  0027a	03 fb		 add	 edi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  0027c	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00280	83 c7 04	 add	 edi, 4
  00283	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3420 :     for (_Diff _Hole = _Bottom >> 1; 0 < _Hole;) { // shift for codegen

  00285	85 d2		 test	 edx, edx
  00287	0f 8f e3 fe ff
	ff		 jg	 $LL56@Sort_unche
  0028d	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00290	8b 45 f4	 mov	 eax, DWORD PTR __Bottom$1$[ebp]
  00293	8b 4d fc	 mov	 ecx, DWORD PTR tv1073[ebp]
$LN57@Sort_unche:

; 3509 :     for (; 2 <= _Last - _First; --_Last) {

  00296	83 f8 02	 cmp	 eax, 2
  00299	0f 8c e2 00 00
	00		 jl	 $LN103@Sort_unche

; 4113 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 4114 :             _Sort_heap_unchecked(_First, _Last, _Pred);

  0029f	8d 86 6c ff ff
	ff		 lea	 eax, DWORD PTR [esi-148]
  002a5	8d 91 6c ff ff
	ff		 lea	 edx, DWORD PTR [ecx-148]
  002ab	89 45 0c	 mov	 DWORD PTR tv1082[ebp], eax
  002ae	89 55 08	 mov	 DWORD PTR tv1075[ebp], edx
$LL104@Sort_unche:

; 3388 :     _Pop_heap_hole_by_index(_First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD move(_Val), _Pred);

  002b1	ff 75 14	 push	 DWORD PTR __Pred$[ebp]

; 3396 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  002b4	8b f0		 mov	 esi, eax
  002b6	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR __Val$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  002bc	8b 03		 mov	 eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3396 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  002be	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  002c3	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  002c5	8b 4d 0c	 mov	 ecx, DWORD PTR tv1082[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  002c8	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  002cb	8d 3c 16	 lea	 edi, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  002ce	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3388 :     _Pop_heap_hole_by_index(_First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD move(_Val), _Pred);

  002d0	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  002d5	f7 ea		 imul	 edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  002d7	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3388 :     _Pop_heap_hole_by_index(_First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD move(_Val), _Pred);

  002dc	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Val$1[ebp]
  002e2	03 55 08	 add	 edx, DWORD PTR tv1075[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  002e5	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3388 :     _Pop_heap_hole_by_index(_First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD move(_Val), _Pred);

  002e7	c1 fa 07	 sar	 edx, 7
  002ea	8b f2		 mov	 esi, edx
  002ec	50		 push	 eax
  002ed	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  002f0	03 f2		 add	 esi, edx
  002f2	56		 push	 esi
  002f3	6a 00		 push	 0
  002f5	53		 push	 ebx
  002f6	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAU?$pair@MUTFlyVertexSet@@@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<std::pair<float,TFlyVertexSet> *,std::pair<float,TFlyVertexSet>,std::less<void> >

; 3509 :     for (; 2 <= _Last - _First; --_Last) {

  002fb	8b 45 0c	 mov	 eax, DWORD PTR tv1082[ebp]

; 3388 :     _Pop_heap_hole_by_index(_First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD move(_Val), _Pred);

  002fe	83 c4 14	 add	 esp, 20			; 00000014H

; 3509 :     for (; 2 <= _Last - _First; --_Last) {

  00301	8b 55 08	 mov	 edx, DWORD PTR tv1075[ebp]
  00304	2d 94 00 00 00	 sub	 eax, 148		; 00000094H
  00309	81 ea 94 00 00
	00		 sub	 edx, 148		; 00000094H
  0030f	89 45 0c	 mov	 DWORD PTR tv1082[ebp], eax
  00312	89 55 08	 mov	 DWORD PTR tv1075[ebp], edx
  00315	83 fe 02	 cmp	 esi, 2
  00318	7d 97		 jge	 SHORT $LL104@Sort_unche

; 4129 :         }
; 4130 :     }
; 4131 : }

  0031a	5f		 pop	 edi
  0031b	5e		 pop	 esi
  0031c	5b		 pop	 ebx
  0031d	8b e5		 mov	 esp, ebp
  0031f	5d		 pop	 ebp
  00320	c3		 ret	 0
$LN155@Sort_unche:
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00321	8b 45 08	 mov	 eax, DWORD PTR __Next$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  00324	f3 0f 11 0a	 movss	 DWORD PTR [edx], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00328	eb 3e		 jmp	 SHORT $LN160@Sort_unche
$LN140@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4444 :     while (_First != _Last) {

  0032a	3b c3		 cmp	 eax, ebx
  0032c	74 2e		 je	 SHORT $LN30@Sort_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3987 :                 _Move_backward_unchecked(_First, _Next, ++_Next1);

  0032e	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
$LL131@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  00331	8b 82 68 ff ff
	ff		 mov	 eax, DWORD PTR [edx-152]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4445 :         *--_Dest = _STD move(*--_Last);

  00337	81 ea 94 00 00
	00		 sub	 edx, 148		; 00000094H
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0033d	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00342	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  00344	89 82 90 00 00
	00		 mov	 DWORD PTR [edx+144], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  0034a	8d ba 94 00 00
	00		 lea	 edi, DWORD PTR [edx+148]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4444 :     while (_First != _Last) {

  00350	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00353	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4444 :     while (_First != _Last) {

  00355	3b c3		 cmp	 eax, ebx
  00357	75 d8		 jne	 SHORT $LL131@Sort_unche
  00359	8b 45 08	 mov	 eax, DWORD PTR __Next$1$[ebp]
$LN30@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 292  :         first  = _STD forward<_Ty1>(_Right.first);

  0035c	f3 0f 11 0b	 movss	 DWORD PTR [ebx], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 110  : 		memcpy(v,rhs.v,sizeof(v));

  00360	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  00363	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
$LN160@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3982 :         for (_BidIt _Next = _First; ++_Next != _Last;) { // order next element

  00368	05 94 00 00 00	 add	 eax, 148		; 00000094H
  0036d	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR __Val$3[ebp+4]
  00373	f3 a5		 rep movsd
  00375	89 45 08	 mov	 DWORD PTR __Next$1$[ebp], eax
  00378	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0037b	0f 85 4f fd ff
	ff		 jne	 $LL11@Sort_unche
$LN103@Sort_unche:
  00381	5f		 pop	 edi

; 4129 :         }
; 4130 :     }
; 4131 : }

  00382	5e		 pop	 esi
  00383	5b		 pop	 ebx
  00384	8b e5		 mov	 esp, ebp
  00386	5d		 pop	 ebp
  00387	c3		 ret	 0
??$_Sort_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@0HU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAPAPAVCFlyTrace@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAPAPAVCFlyTrace@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z PROC ; std::_Uninitialized_move<CFlyTrace * *,std::allocator<CFlyTrace *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCFlyTrace@@PAPAV1@@std@@YAPAPAVCFlyTrace@@PAPAV1@00@Z ; std::_Copy_memmove<CFlyTrace * *,CFlyTrace * *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAPAPAVCFlyTrace@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z ENDP ; std::_Uninitialized_move<CFlyTrace * *,std::allocator<CFlyTrace *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@QAU10@0PAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAU?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@QAU10@0PAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::pair<float,TFlyVertexSet> *,std::allocator<std::pair<float,TFlyVertexSet> > >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00009	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 1e		 je	 SHORT $LN3@Uninitiali
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL4@Uninitiali:

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00013	8b f2		 mov	 esi, edx
  00015	8b f8		 mov	 edi, eax

; 1509 :         ++_Last;

  00017	81 c2 94 00 00
	00		 add	 edx, 148		; 00000094H

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0001d	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H

; 1509 :         ++_Last;

  00022	05 94 00 00 00	 add	 eax, 148		; 00000094H

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00027	f3 a5		 rep movsd

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00029	3b d3		 cmp	 edx, ebx
  0002b	75 e6		 jne	 SHORT $LL4@Uninitiali

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
$LN3@Uninitiali:
  0002f	5b		 pop	 ebx

; 1664 :     }
; 1665 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Uninitialized_move@PAU?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@QAU10@0PAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::pair<float,TFlyVertexSet> *,std::allocator<std::pair<float,TFlyVertexSet> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Zero_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0@Z PROC ; std::_Zero_range<std::pair<float,D3DXVECTOR3> * *>, COMDAT

; 1814 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1815 :     char* const _First_ch = reinterpret_cast<char*>(_First);
; 1816 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);
; 1817 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 1818 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1819 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0@Z ENDP ; std::_Zero_range<std::pair<float,D3DXVECTOR3> * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@00@Z PROC ; std::_Copy_memmove<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@00@Z ENDP ; std::_Copy_memmove<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1084 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Obj$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 998  : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	6a 08		 push	 8
  00005	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0000d	83 c4 08	 add	 esp, 8

; 999  :     // deallocate a plain pointer using an allocator
; 1000 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1001 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1002 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);
; 1003 :     } else {
; 1004 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1005 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1006 :     }
; 1007 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAXPAPAVCFlyTrace@@QAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAXPAPAVCFlyTrace@@QAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CFlyTrace *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAXPAPAVCFlyTrace@@QAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CFlyTrace *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@std@@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@QAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@std@@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@QAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<float,TFlyVertexSet> > >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@std@@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@QAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<float,TFlyVertexSet> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Destroy_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@@Z PROC ; std::_Destroy_range<std::pair<float,D3DXVECTOR3> * *>, COMDAT

; 969  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 970  :     if _CONSTEXPR_IF (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 971  :         for (; _First != _Last; ++_First) {
; 972  :             _Destroy_in_place(*_First);
; 973  :         }
; 974  :     }
; 975  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@@Z ENDP ; std::_Destroy_range<std::pair<float,D3DXVECTOR3> * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PAPAU?$pair@MUD3DXVECTOR3@@@std@@I@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@I@Z
_TEXT	SEGMENT
__UFirst$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Uninitialized_value_construct_n_unchecked1@PAPAU?$pair@MUD3DXVECTOR3@@@std@@I@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@I@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<std::pair<float,D3DXVECTOR3> * *,unsigned int>, COMDAT

; 1874 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1875 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1876 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1877 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1878 :         return _Zero_range(_UFirst, _UFirst + _Count);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000c	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  0000f	89 4d 08	 mov	 DWORD PTR __UFirst$[ebp], ecx

; 1879 :     } else {
; 1880 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 1881 :         for (; 0 < _Count; --_Count) {
; 1882 :             _Backout._Emplace_back();
; 1883 :         }
; 1884 : 
; 1885 :         return _Backout._Release();
; 1886 :     }
; 1887 : }

  00012	5d		 pop	 ebp

; 1875 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1876 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1877 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1878 :         return _Zero_range(_UFirst, _UFirst + _Count);

  00013	e9 00 00 00 00	 jmp	 ??$_Zero_range@PAPAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0@Z ; std::_Zero_range<std::pair<float,D3DXVECTOR3> * *>
??$_Uninitialized_value_construct_n_unchecked1@PAPAU?$pair@MUD3DXVECTOR3@@@std@@I@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@I@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<std::pair<float,D3DXVECTOR3> * *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z PROC ; std::uninitialized_copy<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>, COMDAT

; 1591 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1599 :     } else {
; 1600 :         _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};
; 1601 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1602 :             _Backout._Emplace_back(*_UFirst);
; 1603 :         }
; 1604 : 
; 1605 :         _UDest = _Backout._Release();
; 1606 :     }
; 1607 : 
; 1608 :     _Seek_wrapped(_Dest, _UDest);
; 1609 :     return _Dest;
; 1610 : }

  00003	5d		 pop	 ebp

; 1592 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1593 :     _Adl_verify_range(_First, _Last);
; 1594 :     auto _UFirst      = _Get_unwrapped(_First);
; 1595 :     const auto _ULast = _Get_unwrapped(_Last);
; 1596 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1597 :     if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
; 1598 :         _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);

  00004	e9 00 00 00 00	 jmp	 ??$_Copy_memmove@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@00@Z ; std::_Copy_memmove<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>
??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z ENDP ; std::uninitialized_copy<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXAAPAU?$pair@MUD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXAAPAU?$pair@MUD3DXVECTOR3@@@0@@Z PROC ; std::_Destroy_in_place<std::pair<float,D3DXVECTOR3> *>, COMDAT

; 268  :     _Obj.~_Ty();
; 269  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAU?$pair@MUD3DXVECTOR3@@@std@@@std@@YAXAAPAU?$pair@MUD3DXVECTOR3@@@0@@Z ENDP ; std::_Destroy_in_place<std::pair<float,D3DXVECTOR3> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCFlyTrace@@@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@QAEPAPAVCFlyTrace@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
tv436 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv435 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCFlyTrace@@@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@QAEPAPAVCFlyTrace@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Emplace_reallocate<CFlyTrace * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 be 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00045	8b c7		 mov	 eax, edi
  00047	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00049	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004c	3b c7		 cmp	 eax, edi
  0004e	0f 42 c7	 cmovb	 eax, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 8f 00 00
	00		 ja	 $LN40@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00060	89 45 f4	 mov	 DWORD PTR tv436[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00063	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006d	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00073	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00076	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	3b da		 cmp	 ebx, edx
  00084	75 07		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00086	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0008b	eb 17		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008d	56		 push	 esi
  0008e	57		 push	 edi
  0008f	53		 push	 ebx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAPAPAVCFlyTrace@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z ; std::_Uninitialized_move<CFlyTrace * *,std::allocator<CFlyTrace *> >
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009e	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000a4	56		 push	 esi
  000a5	50		 push	 eax
  000a6	52		 push	 edx
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@YAPAPAVCFlyTrace@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCFlyTrace@@@0@@Z ; std::_Uninitialized_move<CFlyTrace * *,std::allocator<CFlyTrace *> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000b2	85 c9		 test	 ecx, ecx
  000b4	74 12		 je	 SHORT $LN33@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	83 e0 fc	 and	 eax, -4			; fffffffcH
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c5	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000cb	8b c3		 mov	 eax, ebx

; 1680 :         _Myfirst = _Newvec;

  000cd	89 3e		 mov	 DWORD PTR [esi], edi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000cf	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  000d2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv436[ebp]
  000d8	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000da	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000db	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 767  :     }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@CAXXZ ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000eb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f0	cc		 int	 3
??$_Emplace_reallocate@ABQAVCFlyTrace@@@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@QAEPAPAVCFlyTrace@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Emplace_reallocate<CFlyTrace * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1027 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1028 :     using _Ty = typename _Alloc::value_type;
; 1029 :     _Ptr->~_Ty();
; 1030 :     _Deallocate_plain(_Al, _Ptr);

  00000	e9 00 00 00 00	 jmp	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@U?$pair@MUTFlyVertexSet@@@std@@@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAEPAU?$pair@MUTFlyVertexSet@@@1@QAU21@$$QAU21@@Z
_TEXT	SEGMENT
tv404 = -16						; size = 4
__Oldsize$1$ = -12					; size = 4
__Newvec$1$ = -8					; size = 4
tv403 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@U?$pair@MUTFlyVertexSet@@@std@@@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAEPAU?$pair@MUTFlyVertexSet@@@1@QAU21@$$QAU21@@Z PROC ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Emplace_reallocate<std::pair<float,TFlyVertexSet> >, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00009	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR __Whereptr$[ebp]
  00012	57		 push	 edi
  00013	2b 33		 sub	 esi, DWORD PTR [ebx]

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00015	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00018	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  0001a	f7 ee		 imul	 esi
  0001c	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00021	03 d6		 add	 edx, esi
  00023	c1 fa 07	 sar	 edx, 7
  00026	8b fa		 mov	 edi, edx
  00028	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0002b	03 fa		 add	 edi, edx
  0002d	f7 e9		 imul	 ecx
  0002f	03 d1		 add	 edx, ecx
  00031	c1 fa 07	 sar	 edx, 7
  00034	8b c2		 mov	 eax, edx
  00036	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00039	03 c2		 add	 eax, edx
  0003b	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0003e	3d 91 cf ba 01	 cmp	 eax, 29020049		; 01bacf91H
  00043	0f 84 fb 00 00
	00		 je	 $LN41@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00049	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0004c	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004f	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00051	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00056	f7 e9		 imul	 ecx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00058	b8 91 cf ba 01	 mov	 eax, 29020049		; 01bacf91H

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0005d	03 d1		 add	 edx, ecx
  0005f	c1 fa 07	 sar	 edx, 7
  00062	8b ca		 mov	 ecx, edx
  00064	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00067	03 ca		 add	 ecx, edx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00069	8b d1		 mov	 edx, ecx
  0006b	d1 ea		 shr	 edx, 1
  0006d	2b c2		 sub	 eax, edx
  0006f	3b c8		 cmp	 ecx, eax
  00071	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00073	8b c6		 mov	 eax, esi
  00075	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00077	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0007a	3b c6		 cmp	 eax, esi
  0007c	0f 42 c6	 cmovb	 eax, esi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0007f	3d 91 cf ba 01	 cmp	 eax, 29020049		; 01bacf91H
  00084	0f 87 bf 00 00
	00		 ja	 $LN42@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0008a	69 c0 94 00 00
	00		 imul	 eax, eax, 148

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00090	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00091	89 45 f0	 mov	 DWORD PTR tv404[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00094	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00099	8b 75 0c	 mov	 esi, DWORD PTR _<_Val_0>$[ebp]

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0009c	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0009e	69 c7 94 00 00
	00		 imul	 eax, edi, 148
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000a4	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000a9	83 c4 04	 add	 esp, 4
  000ac	89 55 f8	 mov	 DWORD PTR __Newvec$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000af	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000b1	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000b3	89 45 fc	 mov	 DWORD PTR tv403[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000b6	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000b8	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000bb	8b 75 08	 mov	 esi, DWORD PTR __Whereptr$[ebp]
  000be	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c0	3b f1		 cmp	 esi, ecx
  000c2	75 05		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  000c4	8b 7d fc	 mov	 edi, DWORD PTR tv403[ebp]
  000c7	eb 1a		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000c9	53		 push	 ebx
  000ca	52		 push	 edx
  000cb	56		 push	 esi
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAU?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@QAU10@0PAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<float,TFlyVertexSet> *,std::allocator<std::pair<float,TFlyVertexSet> > >

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d2	8b 7d fc	 mov	 edi, DWORD PTR tv403[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000d5	83 c4 10	 add	 esp, 16			; 00000010H
  000d8	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000db	8b c6		 mov	 eax, esi

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000dd	8d 97 94 00 00
	00		 lea	 edx, DWORD PTR [edi+148]
$LN5@Emplace_re:
  000e3	53		 push	 ebx
  000e4	52		 push	 edx
  000e5	51		 push	 ecx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAU?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@QAU10@0PAU10@AAV?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<float,TFlyVertexSet> *,std::allocator<std::pair<float,TFlyVertexSet> > >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ec	8b 33		 mov	 esi, DWORD PTR [ebx]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000ee	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000f1	85 f6		 test	 esi, esi
  000f3	74 28		 je	 SHORT $LN35@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000f5	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000f8	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  000fd	2b ce		 sub	 ecx, esi
  000ff	f7 e9		 imul	 ecx
  00101	03 d1		 add	 edx, ecx
  00103	c1 fa 07	 sar	 edx, 7
  00106	8b c2		 mov	 eax, edx
  00108	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010b	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0010d	69 c0 94 00 00
	00		 imul	 eax, eax, 148
  00113	50		 push	 eax
  00114	56		 push	 esi
  00115	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0011a	83 c4 08	 add	 esp, 8
$LN35@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  00120	8b 45 f8	 mov	 eax, DWORD PTR __Newvec$1$[ebp]
  00123	41		 inc	 ecx
  00124	69 c9 94 00 00
	00		 imul	 ecx, ecx, 148
  0012a	89 03		 mov	 DWORD PTR [ebx], eax
  0012c	03 c8		 add	 ecx, eax
  0012e	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00131	8b 4d f0	 mov	 ecx, DWORD PTR tv404[ebp]
  00134	03 c8		 add	 ecx, eax

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  00136	8b c7		 mov	 eax, edi
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0013a	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  0013d	5b		 pop	 ebx

; 767  :     }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 08 00	 ret	 8
$LN41@Emplace_re:

; 738  :             _Xlength();

  00144	e8 00 00 00 00	 call	 ?_Xlength@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@CAXXZ ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Xlength
$LN42@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00149	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN39@Emplace_re:
  0014e	cc		 int	 3
??$_Emplace_reallocate@U?$pair@MUTFlyVertexSet@@@std@@@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAEPAU?$pair@MUTFlyVertexSet@@@1@QAU21@$$QAU21@@Z ENDP ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Emplace_reallocate<std::pair<float,TFlyVertexSet> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Const_cast@$$CBU?$pair@MUTFlyVertexSet@@@std@@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@PBU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBU?$pair@MUTFlyVertexSet@@@std@@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@PBU10@@Z PROC ; std::_Const_cast<std::pair<float,TFlyVertexSet> const >, COMDAT

; 282  : auto _Const_cast(_Ty* _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :     return const_cast<remove_const_t<_Ty>*>(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 284  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Const_cast@$$CBU?$pair@MUTFlyVertexSet@@@std@@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@PBU10@@Z ENDP ; std::_Const_cast<std::pair<float,TFlyVertexSet> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::~vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 3e		 je	 SHORT $LN4@vector

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	56		 push	 esi
  0000a	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0000d	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00012	2b f1		 sub	 esi, ecx
  00014	f7 ee		 imul	 esi
  00016	03 d6		 add	 edx, esi
  00018	c1 fa 07	 sar	 edx, 7
  0001b	8b c2		 mov	 eax, edx
  0001d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00020	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00022	69 c0 94 00 00
	00		 imul	 eax, eax, 148
  00028	50		 push	 eax
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0002f	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00032	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1698 :             _Mylast  = pointer();

  00038	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  0003f	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00046	5e		 pop	 esi
$LN4@vector:
  00047	5f		 pop	 edi

; 673  :         _Tidy();
; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00048	c3		 ret	 0
??1?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::~vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ??0TFlyVertex@@QAE@XZ
_TEXT	SEGMENT
??0TFlyVertex@@QAE@XZ PROC				; TFlyVertex::TFlyVertex, COMDAT
; _this$ = ecx

; 93   : 	TFlyVertex(){};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0TFlyVertex@@QAE@XZ ENDP				; TFlyVertex::TFlyVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CFlyTrace::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A ; CFlyTrace::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCFlyTrace@@@@UAE@XZ ; CDynamicPool<CFlyTrace>::~CDynamicPool<CFlyTrace>
??__F?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CFlyTrace::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ??__E?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CFlyTrace::ms_kPool'', COMDAT

; 8    : CDynamicPool<CFlyTrace>		CFlyTrace::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CFlyTrace::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CFlyTrace::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCFlyTrace@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCFlyTrace@@@@UAEPAXI@Z PROC		; CDynamicPool<CFlyTrace>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCFlyTrace@@@@UAE@XZ ; CDynamicPool<CFlyTrace>::~CDynamicPool<CFlyTrace>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCFlyTrace@@@@UAEPAXI@Z ENDP		; CDynamicPool<CFlyTrace>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@CAXXZ PROC ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@CAXXZ ENDP ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCFlyTrace@@@@KAXPAVCFlyTrace@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCFlyTrace@@@@KAXPAVCFlyTrace@@@Z PROC ; CDynamicPool<CFlyTrace>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 			delete pkData;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkData$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN3@Delete
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN3@Delete:

; 111  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Delete@?$CDynamicPool@VCFlyTrace@@@@KAXPAVCFlyTrace@@@Z ENDP ; CDynamicPool<CFlyTrace>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCFlyTrace@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCFlyTrace@@@@UAE@XZ PROC		; CDynamicPool<CFlyTrace>::~CDynamicPool<CFlyTrace>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCFlyTrace@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 27		 je	 SHORT $LN6@CDynamicPo

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00013	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e0 fc	 and	 eax, -4			; fffffffcH
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00026	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00029	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1699 :             _Myend   = pointer();

  00030	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN6@CDynamicPo:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00037	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 27		 je	 SHORT $LN13@CDynamicPo

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0003e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00041	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00043	83 e0 fc	 and	 eax, -4			; fffffffcH
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0004d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1698 :             _Mylast  = pointer();

  00057	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1699 :             _Myend   = pointer();

  0005e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN13@CDynamicPo:
  00065	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 26   : 		}

  00066	c3		 ret	 0
??1?$CDynamicPool@VCFlyTrace@@@@UAE@XZ ENDP		; CDynamicPool<CFlyTrace>::~CDynamicPool<CFlyTrace>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCFlyTrace@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFlyTrace@@UAEPAXI@Z PROC				; CFlyTrace::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CFlyTrace@@UAE@XZ	; CFlyTrace::~CFlyTrace
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 28		 push	 40			; 00000028H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCFlyTrace@@UAEPAXI@Z ENDP				; CFlyTrace::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?Delete@CFlyTrace@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkInst$ = 8						; size = 4
?Delete@CFlyTrace@@SAXPAV1@@Z PROC			; CFlyTrace::Delete, COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 22   : 	pkInst->Destroy();

  00004	8b 75 08	 mov	 esi, DWORD PTR _pkInst$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?Destroy@CFlyTrace@@QAEXXZ ; CFlyTrace::Destroy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0000e	a1 14 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+20
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 23   : 	ms_kPool.Free(pkInst);

  00013	89 75 08	 mov	 DWORD PTR _pkData$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00016	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+24
  0001c	74 0c		 je	 SHORT $LN8@Delete

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	89 30		 mov	 DWORD PTR [eax], esi

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00020	83 05 14 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+20, 4
  00027	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 24   : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN8@Delete:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002a	8d 4d 08	 lea	 ecx, DWORD PTR _pkData$[ebp]
  0002d	51		 push	 ecx
  0002e	50		 push	 eax
  0002f	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+16
  00034	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCFlyTrace@@@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@QAEPAPAVCFlyTrace@@QAPAV2@ABQAV2@@Z ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Emplace_reallocate<CFlyTrace * const &>
  00039	5e		 pop	 esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 24   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?Delete@CFlyTrace@@SAXPAV1@@Z ENDP			; CFlyTrace::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?New@CFlyTrace@@SAPAV1@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
_pkNewData$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?New@CFlyTrace@@SAPAV1@XZ PROC				; CFlyTrace::New, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@CFlyTrace@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00024	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+20
  0002a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+16, ecx
  00030	0f 85 84 00 00
	00		 jne	 $LN4@New

; 65   : 				T* pkNewData=new T;

  00036	6a 28		 push	 40			; 00000028H
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN6@New
  0004e	8b c8		 mov	 ecx, eax
  00050	e8 00 00 00 00	 call	 ??0CFlyTrace@@QAE@XZ	; CFlyTrace::CFlyTrace
  00055	8b f0		 mov	 esi, eax
  00057	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  00059	33 f6		 xor	 esi, esi
$LN7@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0005b	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+8
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 65   : 				T* pkNewData=new T;

  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	89 75 f0	 mov	 DWORD PTR _pkNewData$3[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0006a	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+12
  00070	74 21		 je	 SHORT $LN14@New

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00072	89 30		 mov	 DWORD PTR [eax], esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 17   : 	return ms_kPool.Alloc();

  00074	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00076	83 05 08 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+8, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0007d	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+32
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 18   : }

  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN14@New:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00093	8d 4d f0	 lea	 ecx, DWORD PTR _pkNewData$3[ebp]
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+4
  0009d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCFlyTrace@@@?$vector@PAVCFlyTrace@@V?$allocator@PAVCFlyTrace@@@std@@@std@@QAEPAPAVCFlyTrace@@QAPAV2@ABQAV2@@Z ; std::vector<CFlyTrace *,std::allocator<CFlyTrace *> >::_Emplace_reallocate<CFlyTrace * const &>
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000a2	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+32
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 17   : 	return ms_kPool.Alloc();

  000a8	8b c6		 mov	 eax, esi

; 18   : }

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5e		 pop	 esi
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN4@New:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ba	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1559 :         return _My_data._Mylast[-1];

  000bd	83 c1 fc	 add	 ecx, -4			; fffffffcH

; 1338 :         --_Mylast;

  000c0	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+20, ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 18   : }

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@CFlyTrace@@SAPAV1@XZ$0:
  00000	6a 28		 push	 40			; 00000028H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$?New@CFlyTrace@@SAPAV1@XZ:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@CFlyTrace@@SAPAV1@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@CFlyTrace@@SAPAV1@XZ ENDP				; CFlyTrace::New
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?DestroySystem@CFlyTrace@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CFlyTrace@@SAXXZ PROC			; CFlyTrace::DestroySystem, COMDAT

; 11   : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 11   : {

  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 234  :     const auto _ULast = _Get_unwrapped(_Last);

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+8

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0000e	3b f7		 cmp	 esi, edi
  00010	74 2a		 je	 SHORT $LN30@DestroySys
$LL20@DestroySys:
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 110  : 			delete pkData;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN18@DestroySys
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 01		 push	 1
  0001c	ff 10		 call	 DWORD PTR [eax]
$LN18@DestroySys:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 235  :     for (; _UFirst != _ULast; ++_UFirst) {

  0001e	83 c6 04	 add	 esi, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL20@DestroySys
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 51   : 			m_kVct_pkData.clear();

  00025	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+4
  0002a	a3 08 00 00 00	 mov	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+8, eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 13   : }

  0002f	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+16
  00034	5f		 pop	 edi
  00035	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+20, eax
  0003a	5e		 pop	 esi
  0003b	c3		 ret	 0
$LN30@DestroySys:
  0003c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+16
  00041	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\eterLib\Pool.h

; 51   : 			m_kVct_pkData.clear();

  00042	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+8, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 13   : }

  00048	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CFlyTrace@@2V?$CDynamicPool@VCFlyTrace@@@@A+20, eax
  0004d	5e		 pop	 esi
  0004e	c3		 ret	 0
?DestroySystem@CFlyTrace@@SAXXZ ENDP			; CFlyTrace::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
;	COMDAT ?_Tidy@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@AAEXXZ PROC ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Tidy, COMDAT
; _this$ = ecx

; 1464 :     void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1009 :         return _Mysize() == 0;

  00003	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00006	85 c9		 test	 ecx, ecx

; 1465 :         _Orphan_all();
; 1466 : 
; 1467 :         _Alpty _Almap(_Getal());
; 1468 :         while (!empty()) {

  00008	74 15		 je	 SHORT $LN30@Tidy
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Tidy:

; 1143 :         if (--_Mysize() == 0) {

  00010	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00013	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00016	8b c8		 mov	 ecx, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 f4		 jne	 SHORT $LL2@Tidy

; 1144 :             _Myoff() = 0;

  0001c	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN30@Tidy:
  0001f	57		 push	 edi

; 1472 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00020	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00023	85 ff		 test	 edi, edi
  00025	74 1a		 je	 SHORT $LN5@Tidy
$LL25@Tidy:

; 1473 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	4f		 dec	 edi
  0002b	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0002e	85 c0		 test	 eax, eax
  00030	74 0b		 je	 SHORT $LN7@Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00032	6a 10		 push	 16			; 00000010H
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003a	83 c4 08	 add	 esp, 8
$LN7@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1472 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  0003d	85 ff		 test	 edi, edi
  0003f	75 e6		 jne	 SHORT $LL25@Tidy
$LN5@Tidy:

; 1474 :                 _Getal().deallocate(_Map()[_Block], _DEQUESIZ);
; 1475 :                 _Destroy_in_place(_Map()[_Block]);
; 1476 :             }
; 1477 :         }
; 1478 : 
; 1479 :         if (_Map() != _Mapptr()) {

  00041	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00044	5f		 pop	 edi
  00045	85 c9		 test	 ecx, ecx
  00047	74 10		 je	 SHORT $LN32@Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00049	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004c	c1 e0 02	 shl	 eax, 2
  0004f	50		 push	 eax
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00056	83 c4 08	 add	 esp, 8
$LN32@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1485 :     }

  00059	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00060	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00067	5e		 pop	 esi
  00068	c3		 ret	 0
?_Tidy@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@AAEXXZ ENDP ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
;	COMDAT ?_Xlen@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@ABEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@ABEXXZ PROC ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Xlen, COMDAT
; _this$ = ecx

; 1418 :         _Xlength_error("deque<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@ABEXXZ ENDP ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
;	COMDAT ?push_front@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@QAEX$$QAU?$pair@MUD3DXVECTOR3@@@2@@Z
_TEXT	SEGMENT
tv592 = -8						; size = 4
__Newmap$1$ = -4					; size = 4
__Val$ = 8						; size = 4
?push_front@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@QAEX$$QAU?$pair@MUD3DXVECTOR3@@@2@@Z PROC ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::push_front, COMDAT
; _this$ = ecx

; 787  :     void push_front(_Ty&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 789  :         _PUSH_FRONT_BEGIN;

  0000b	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0000e	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00011	40		 inc	 eax
  00012	3b d0		 cmp	 edx, eax
  00014	0f 87 de 00 00
	00		 ja	 $LN45@push_front

; 1429 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  0001a	85 d2		 test	 edx, edx
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	0f 45 c2	 cmovne	 eax, edx
$LL8@push_front:

; 1430 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _DEQUEMAPSIZ) {

  00024	8b f0		 mov	 esi, eax
  00026	2b f2		 sub	 esi, edx
  00028	83 fe 01	 cmp	 esi, 1
  0002b	72 05		 jb	 SHORT $LN10@push_front
  0002d	83 f8 08	 cmp	 eax, 8
  00030	73 13		 jae	 SHORT $LN9@push_front
$LN10@push_front:

; 1431 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1432 :             if (max_size() / _DEQUESIZ - _Newsize < _Newsize) {

  00032	b9 ff ff ff 0f	 mov	 ecx, 268435455		; 0fffffffH
  00037	2b c8		 sub	 ecx, eax
  00039	3b c8		 cmp	 ecx, eax
  0003b	0f 82 04 01 00
	00		 jb	 $LN41@push_front

; 1434 :             }
; 1435 : 
; 1436 :             _Newsize *= 2;

  00041	03 c0		 add	 eax, eax

; 1437 :         }

  00043	eb df		 jmp	 SHORT $LL8@push_front
$LN9@push_front:

; 1438 :         _Count = _Newsize - _Mapsize();
; 1439 : 
; 1440 :         size_type _Myboff = _Myoff() / _DEQUESIZ;

  00045	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00048	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0004d	0f 87 f9 00 00
	00		 ja	 $LN49@push_front

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00053	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1444 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  0005c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0005f	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00066	89 4d f8	 mov	 DWORD PTR tv592[ebp], ecx
  00069	03 c8		 add	 ecx, eax
  0006b	51		 push	 ecx
  0006c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006f	89 45 fc	 mov	 DWORD PTR __Newmap$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1444 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  00072	8d 04 9a	 lea	 eax, DWORD PTR [edx+ebx*4]
  00075	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  00078	51		 push	 ecx
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z ; std::uninitialized_copy<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>
  0007f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00082	83 c4 10	 add	 esp, 16			; 00000010H

; 1445 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

  00085	50		 push	 eax
  00086	3b de		 cmp	 ebx, esi
  00088	77 1d		 ja	 SHORT $LN12@push_front

; 1446 :             _Myptr = _STD uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr); // copy rest of old

  0008a	8d 04 99	 lea	 eax, DWORD PTR [ecx+ebx*4]
  0008d	50		 push	 eax
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z ; std::uninitialized_copy<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>

; 1447 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count - _Myboff); // clear suffix of new

  00094	8b ce		 mov	 ecx, esi
  00096	2b cb		 sub	 ecx, ebx
  00098	51		 push	 ecx
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAU?$pair@MUD3DXVECTOR3@@@std@@I@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<std::pair<float,D3DXVECTOR3> * *,unsigned int>

; 1448 :             _Uninitialized_value_construct_n_unchecked1(_Newmap, _Myboff); // clear prefix of new

  0009f	8b 45 fc	 mov	 eax, DWORD PTR __Newmap$1$[ebp]
  000a2	83 c4 14	 add	 esp, 20			; 00000014H

; 1449 :         } else { // increment not greater than offset of initial block

  000a5	eb 24		 jmp	 SHORT $LN13@push_front
$LN12@push_front:

; 1450 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

  000a7	8d 04 b1	 lea	 eax, DWORD PTR [ecx+esi*4]
  000aa	50		 push	 eax
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z ; std::uninitialized_copy<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>

; 1451 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  000b1	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000b4	ff 75 fc	 push	 DWORD PTR __Newmap$1$[ebp]
  000b7	8b 45 f8	 mov	 eax, DWORD PTR tv592[ebp]
  000ba	03 c1		 add	 eax, ecx
  000bc	50		 push	 eax
  000bd	8d 04 b1	 lea	 eax, DWORD PTR [ecx+esi*4]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAU?$pair@MUD3DXVECTOR3@@@std@@PAPAU12@@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@QAPAU10@0PAPAU10@@Z ; std::uninitialized_copy<std::pair<float,D3DXVECTOR3> * *,std::pair<float,D3DXVECTOR3> * *>
  000c6	83 c4 18	 add	 esp, 24			; 00000018H

; 1452 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count); // clear rest to initial block

  000c9	8b de		 mov	 ebx, esi
$LN13@push_front:

; 1453 :         }
; 1454 : 
; 1455 :         _Destroy_range(_Map() + _Myboff, _Map() + _Mapsize());
; 1456 :         if (_Map() != _Mapptr()) {

  000cb	53		 push	 ebx
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAU?$pair@MUD3DXVECTOR3@@@std@@I@std@@YAPAPAU?$pair@MUD3DXVECTOR3@@@0@PAPAU10@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<std::pair<float,D3DXVECTOR3> * *,unsigned int>
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	83 c4 08	 add	 esp, 8
  000d8	85 c9		 test	 ecx, ecx
  000da	74 10		 je	 SHORT $LN14@push_front
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000dc	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000df	c1 e0 02	 shl	 eax, 2
  000e2	50		 push	 eax
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000e9	83 c4 08	 add	 esp, 8
$LN14@push_front:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1460 :         _Map() = _Newmap; // point at new

  000ec	8b 45 fc	 mov	 eax, DWORD PTR __Newmap$1$[ebp]
  000ef	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1461 :         _Mapsize() += _Count;

  000f2	01 77 08	 add	 DWORD PTR [edi+8], esi
  000f5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
$LN45@push_front:

; 789  :         _PUSH_FRONT_BEGIN;

  000f8	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000fb	21 47 0c	 and	 DWORD PTR [edi+12], eax
  000fe	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  00101	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00104	0f 44 f2	 cmove	 esi, edx
  00107	4e		 dec	 esi

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00108	23 c6		 and	 eax, esi

; 789  :         _PUSH_FRONT_BEGIN;

  0010a	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]
  00111	83 3c 0b 00	 cmp	 DWORD PTR [ebx+ecx], 0
  00115	75 13		 jne	 SHORT $LN3@push_front
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00117	6a 10		 push	 16			; 00000010H
  00119	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 789  :         _PUSH_FRONT_BEGIN;

  0011e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00121	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 789  :         _PUSH_FRONT_BEGIN;

  00124	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax
  00127	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
$LN3@push_front:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0012a	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0012d	8b 0c 0b	 mov	 ecx, DWORD PTR [ebx+ecx]
  00130	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00133	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 791  :         _PUSH_FRONT_END;

  00136	ff 47 10	 inc	 DWORD PTR [edi+16]
  00139	89 77 0c	 mov	 DWORD PTR [edi+12], esi
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx

; 792  :     }

  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c2 04 00	 ret	 4
$LN41@push_front:

; 1433 :                 _Xlen(); // result too long

  00145	8b cf		 mov	 ecx, edi
  00147	e8 00 00 00 00	 call	 ?_Xlen@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@ABEXXZ ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Xlen
$LN49@push_front:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0014c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN47@push_front:
  00151	cc		 int	 3
?push_front@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@QAEX$$QAU?$pair@MUD3DXVECTOR3@@@2@@Z ENDP ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::push_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?__Initialize@CFlyTrace@@IAEXXZ
_TEXT	SEGMENT
?__Initialize@CFlyTrace@@IAEXXZ PROC			; CFlyTrace::__Initialize, COMDAT
; _this$ = ecx

; 48   : 	m_bRectShape=false;

  00000	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 49   : 	m_dwColor=0;

  00004	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 50   : 	m_fSize=0.0f;

  0000b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 51   : 	m_fTailLength=0.0f;

  00012	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 52   : }

  00019	c3		 ret	 0
?__Initialize@CFlyTrace@@IAEXXZ ENDP			; CFlyTrace::__Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\cmath
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\cmath
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SphereLib\vector.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\SphereLib\vector.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?Render@CFlyTrace@@QAEXXZ
_TEXT	SEGMENT
$T10 = -552						; size = 148
_E$11 = -404						; size = 12
_B$1$sroa$2107$1$ = -392				; size = 4
_B$1$sroa$2108$1$ = -388				; size = 4
$T12 = -384						; size = 1
tv3692 = -384						; size = 4
_pCurrentCamera$1$ = -380				; size = 4
_VSVector$ = -376					; size = 12
_F$ = -364						; size = 12
_VSVector$2$ = -352					; size = 4
_s$ = -348						; size = 4
_E$3$ = -344						; size = 4
__Mycont$1$ = -344					; size = 4
_this$GSCopy$1$ = -340					; size = 4
_it2$$sroa$2109$1$ = -336				; size = 4
_it2$$sroa$2111$1$ = -332				; size = 4
_E$2$ = -328						; size = 4
__Mycont$1$ = -328					; size = 4
tv2027 = -328						; size = 4
tv2010 = -328						; size = 4
_E$1$ = -324						; size = 4
_rate1$1$ = -324					; size = 4
__Mycont$1$ = -324					; size = 4
_rkOld$1$ = -324					; size = 4
_it1$$sroa$2112$1$ = -320				; size = 4
tv3785 = -320						; size = 4
_it1$$sroa$2110$1$ = -316				; size = 4
_matWorld$ = -312					; size = 64
_c$13 = -248						; size = 12
_m$ = -236						; size = 64
_U$14 = -172						; size = 12
_v$15 = -160						; size = 144
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Render@CFlyTrace@@QAEXXZ PROC				; CFlyTrace::Render, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CFlyTrace@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b c1		 mov	 eax, ecx
  0002f	89 85 ac fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax

; 119  : 	if (m_TimePositionDeque.size()<=1)

  00035	83 78 24 01	 cmp	 DWORD PTR [eax+36], 1
  00039	0f 86 23 0c 00
	00		 jbe	 $LN429@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0003f	33 c0		 xor	 eax, eax
  00041	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _VSVector$[ebp], 0
  0004b	33 ff		 xor	 edi, edi
  0004d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _VSVector$2$[ebp], eax
  00053	89 bd 8c fe ff
	ff		 mov	 DWORD PTR _VSVector$[ebp+4], edi
  00059	89 85 90 fe ff
	ff		 mov	 DWORD PTR _VSVector$[ebp+8], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 124  : 	STATEMANAGER.SaveRenderState(D3DRS_ZFUNC,D3DCMP_LESS);

  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00065	6a 02		 push	 2
  00067	6a 17		 push	 23			; 00000017H
  00069	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  0006c	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 130  : 	STATEMANAGER.SaveTransform(D3DTS_WORLD, &matWorld);

  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00077	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _matWorld$[ebp]
  0007d	50		 push	 eax
  0007e	68 00 01 00 00	 push	 256			; 00000100H
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00083	89 bd 00 ff ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+56], edi
  00089	89 bd fc fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+52], edi
  0008f	89 bd f8 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+48], edi
  00095	89 bd f4 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+44], edi
  0009b	89 bd ec fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+36], edi
  000a1	89 bd e8 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+32], edi
  000a7	89 bd e4 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+28], edi
  000ad	89 bd e0 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+24], edi
  000b3	89 bd d8 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+16], edi
  000b9	89 bd d4 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+12], edi
  000bf	89 bd d0 fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+8], edi
  000c5	89 bd cc fe ff
	ff		 mov	 DWORD PTR _matWorld$[ebp+4], edi

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  000cb	c7 85 04 ff ff
	ff 00 00 80 3f	 mov	 DWORD PTR _matWorld$[ebp+60], 1065353216 ; 3f800000H
  000d5	c7 85 f0 fe ff
	ff 00 00 80 3f	 mov	 DWORD PTR _matWorld$[ebp+40], 1065353216 ; 3f800000H
  000df	c7 85 dc fe ff
	ff 00 00 80 3f	 mov	 DWORD PTR _matWorld$[ebp+20], 1065353216 ; 3f800000H
  000e9	c7 85 c8 fe ff
	ff 00 00 80 3f	 mov	 DWORD PTR _matWorld$[ebp], 1065353216 ; 3f800000H
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 130  : 	STATEMANAGER.SaveTransform(D3DTS_WORLD, &matWorld);

  000f3	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 131  : 	STATEMANAGER.SaveVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);

  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000fe	68 42 01 00 00	 push	 322			; 00000142H
  00103	e8 00 00 00 00	 call	 ?SaveVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SaveVertexShader

; 132  : 	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0010e	6a 01		 push	 1
  00110	6a 16		 push	 22			; 00000016H
  00112	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 133  : 
; 134  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0011d	6a 01		 push	 1
  0011f	6a 1b		 push	 27			; 0000001bH
  00121	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 135  : 	STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  00126	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0012c	6a 05		 push	 5
  0012e	6a 13		 push	 19			; 00000013H
  00130	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 136  : 	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

  00135	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0013b	6a 02		 push	 2
  0013d	6a 14		 push	 20			; 00000014H
  0013f	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 137  : 
; 138  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, TRUE);

  00144	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0014a	6a 01		 push	 1
  0014c	6a 0f		 push	 15			; 0000000fH
  0014e	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 139  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00159	6a 05		 push	 5
  0015b	6a 19		 push	 25			; 00000019H
  0015d	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 140  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAREF, 0x00000000);

  00162	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00168	57		 push	 edi
  00169	6a 18		 push	 24			; 00000018H
  0016b	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 141  : 
; 142  : 	STATEMANAGER.SaveRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD );

  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00176	6a 01		 push	 1
  00178	68 ab 00 00 00	 push	 171			; 000000abH
  0017d	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 143  : 	//STATEMANAGER.SaveRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD );
; 144  : 
; 145  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);

  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00188	57		 push	 edi
  00189	6a 02		 push	 2
  0018b	57		 push	 edi
  0018c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 146  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);

  00191	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00197	6a 02		 push	 2
  00199	6a 03		 push	 3
  0019b	57		 push	 edi
  0019c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 147  : 	//STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, /*(m_bUseTexture)?D3DTOP_SELECTARG2:*/D3DTOP_SELECTARG2);
; 148  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

  001a1	6a 02		 push	 2
  001a3	6a 01		 push	 1
  001a5	57		 push	 edi
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ac	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 149  : 
; 150  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

  001b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b7	57		 push	 edi
  001b8	6a 05		 push	 5
  001ba	57		 push	 edi
  001bb	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 151  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);

  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c6	6a 02		 push	 2
  001c8	6a 06		 push	 6
  001ca	57		 push	 edi
  001cb	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 152  : 	//STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
; 153  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, /*(m_bUseTexture)?D3DTOP_SELECTARG2:*/D3DTOP_SELECTARG1);

  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d6	6a 02		 push	 2
  001d8	6a 04		 push	 4
  001da	57		 push	 edi
  001db	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 154  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e6	6a 01		 push	 1
  001e8	6a 01		 push	 1
  001ea	6a 01		 push	 1
  001ec	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 155  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

  001f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f7	6a 01		 push	 1
  001f9	6a 04		 push	 4
  001fb	6a 01		 push	 1
  001fd	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 156  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00202	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00208	57		 push	 edi
  00209	68 89 00 00 00	 push	 137			; 00000089H
  0020e	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 157  : 	STATEMANAGER.SetTexture(0, NULL);

  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00219	57		 push	 edi
  0021a	57		 push	 edi
  0021b	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 158  : 	STATEMANAGER.SetTexture(1, NULL);

  00220	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00226	57		 push	 edi
  00227	6a 01		 push	 1
  00229	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 159  : 
; 160  : 
; 161  : 	D3DXMATRIX m;
; 162  : 	CScreen s;s.UpdateViewMatrix();

  0022e	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00234	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00239	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0023f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00243	e8 00 00 00 00	 call	 ?UpdateViewMatrix@CGraphicBase@@QAEXXZ ; CGraphicBase::UpdateViewMatrix

; 163  : 	CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00248	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0024e	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  00253	89 85 84 fe ff
	ff		 mov	 DWORD PTR _pCurrentCamera$1$[ebp], eax

; 164  : 	if (!pCurrentCamera)

  00259	85 c0		 test	 eax, eax
  0025b	75 10		 jne	 SHORT $LN18@Render

; 165  : 		return;

  0025d	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00263	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  00268	e9 f5 09 00 00	 jmp	 $LN429@Render
$LN18@Render:
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0026d	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+56], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1174 :             _Myproxy = nullptr;

  00277	33 f6		 xor	 esi, esi
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00279	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+52], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1174 :             _Myproxy = nullptr;

  00283	33 d2		 xor	 edx, edx
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00285	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+48], 0
  0028f	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+44], 0
  00299	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+28], 0
  002a3	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+24], 0
  002ad	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+16], 0
  002b7	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+12], 0
  002c1	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+8], 0
  002cb	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _m$[ebp+4], 0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  002d5	c7 85 50 ff ff
	ff 00 00 80 3f	 mov	 DWORD PTR _m$[ebp+60], 1065353216 ; 3f800000H
  002df	c7 85 28 ff ff
	ff 00 00 80 3f	 mov	 DWORD PTR _m$[ebp+20], 1065353216 ; 3f800000H
  002e9	c7 85 14 ff ff
	ff 00 00 80 3f	 mov	 DWORD PTR _m$[ebp], 1065353216 ; 3f800000H
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 169  : 	D3DXVECTOR3 F(pCurrentCamera->GetView());

  002f3	f3 0f 7e 40 54	 movq	 xmm0, QWORD PTR [eax+84]
  002f8	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  002fb	89 85 9c fe ff
	ff		 mov	 DWORD PTR _F$[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 255  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  00301	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 169  : 	D3DXVECTOR3 F(pCurrentCamera->GetView());

  00307	66 0f d6 85 94
	fe ff ff	 movq	 QWORD PTR _F$[ebp], xmm0

; 170  : 	m._31 = F.x;

  0030f	f3 0f 10 bd 94
	fe ff ff	 movss	 xmm7, DWORD PTR _F$[ebp]

; 172  : 	m._33 = F.z;

  00317	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _F$[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1166 :             _Myproxy = _Parent_proxy;

  0031f	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 255  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  00322	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 170  : 	m._31 = F.x;

  00325	f3 0f 11 bd 34
	ff ff ff	 movss	 DWORD PTR _m$[ebp+32], xmm7

; 171  : 	m._32 = F.y;

  0032d	f3 0f 10 bd 98
	fe ff ff	 movss	 xmm7, DWORD PTR _F$[ebp+4]
  00335	f3 0f 11 bd 38
	ff ff ff	 movss	 DWORD PTR _m$[ebp+36], xmm7

; 172  : 	m._33 = F.z;

  0033d	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _m$[ebp+40], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1174 :             _Myproxy = nullptr;

  00345	89 b5 b4 fe ff
	ff		 mov	 DWORD PTR _it2$$sroa$2111$1$[ebp], esi

; 1128 :         if (_Myproxy != _Right._Myproxy) {

  0034b	85 ff		 test	 edi, edi
  0034d	74 08		 je	 SHORT $LN103@Render

; 1129 :             if (_Right._Myproxy) {
; 1130 :                 _Adopt(_Right._Myproxy->_Mycont);

  0034f	8b 17		 mov	 edx, DWORD PTR [edi]

; 1152 :         if (_Parent) {

  00351	85 d2		 test	 edx, edx
  00353	74 16		 je	 SHORT $LN102@Render

; 1166 :             _Myproxy = _Parent_proxy;

  00355	8b 12		 mov	 edx, DWORD PTR [edx]
$LN103@Render:
  00357	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _it1$$sroa$2110$1$[ebp], ecx

; 1128 :         if (_Myproxy != _Right._Myproxy) {

  0035d	85 d2		 test	 edx, edx
  0035f	74 1c		 je	 SHORT $LN116@Render

; 1129 :             if (_Right._Myproxy) {
; 1130 :                 _Adopt(_Right._Myproxy->_Mycont);

  00361	8b 32		 mov	 esi, DWORD PTR [edx]

; 1152 :         if (_Parent) {

  00363	85 f6		 test	 esi, esi
  00365	74 0e		 je	 SHORT $LN115@Render

; 1166 :             _Myproxy = _Parent_proxy;

  00367	8b 36		 mov	 esi, DWORD PTR [esi]

; 1167 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1168 :         } else {

  00369	eb 0c		 jmp	 SHORT $LN470@Render
$LN102@Render:

; 1174 :             _Myproxy = nullptr;

  0036b	33 d2		 xor	 edx, edx
  0036d	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _it1$$sroa$2110$1$[ebp], ecx
  00373	eb 08		 jmp	 SHORT $LN116@Render
$LN115@Render:
  00375	33 f6		 xor	 esi, esi
$LN470@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 283  :         ++_Myoff;

  00377	89 b5 b4 fe ff
	ff		 mov	 DWORD PTR _it2$$sroa$2111$1$[ebp], esi
$LN116@Render:
  0037d	41		 inc	 ecx
$LN471@Render:

; 905  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  0037e	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00384	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00387	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f000000
  0038f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
  00397	03 47 24	 add	 eax, DWORD PTR [edi+36]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 180  : 	for(;it2!=m_TimePositionDeque.end();++it2,++it1)

  0039a	8b bd c4 fe ff
	ff		 mov	 edi, DWORD PTR _it1$$sroa$2110$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 905  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  003a0	89 8d b0 fe ff
	ff		 mov	 DWORD PTR _it2$$sroa$2109$1$[ebp], ecx
  003a6	89 95 c0 fe ff
	ff		 mov	 DWORD PTR tv3785[ebp], edx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 181  : 	{

  003ac	3b c8		 cmp	 ecx, eax
  003ae	0f 84 7b 07 00
	00		 je	 $LN3@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  003b4	85 d2		 test	 edx, edx
  003b6	74 04		 je	 SHORT $LN159@Render
  003b8	8b 02		 mov	 eax, DWORD PTR [edx]
  003ba	eb 02		 jmp	 SHORT $LN160@Render
$LN159@Render:
  003bc	33 c0		 xor	 eax, eax
$LN160@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  003be	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 182  : 		const D3DXVECTOR3& rkOld=it1->second;

  003c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  003c4	49		 dec	 ecx
  003c5	23 cf		 and	 ecx, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 182  : 		const D3DXVECTOR3& rkOld=it1->second;

  003c7	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  003ca	83 c0 04	 add	 eax, 4
  003cd	89 85 bc fe ff
	ff		 mov	 DWORD PTR _rkOld$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  003d3	85 f6		 test	 esi, esi
  003d5	74 04		 je	 SHORT $LN171@Render
  003d7	8b 06		 mov	 eax, DWORD PTR [esi]
  003d9	eb 02		 jmp	 SHORT $LN172@Render
$LN171@Render:
  003db	33 c0		 xor	 eax, eax
$LN172@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  003dd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 183  : 		const D3DXVECTOR3& rkNew=it2->second;

  003e0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  003e3	49		 dec	 ecx
  003e4	23 8d b0 fe ff
	ff		 and	 ecx, DWORD PTR _it2$$sroa$2109$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 183  : 		const D3DXVECTOR3& rkNew=it2->second;

  003ea	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  003ed	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR _rkOld$1$[ebp]
  003f3	f3 0f 10 68 08	 movss	 xmm5, DWORD PTR [eax+8]
  003f8	f3 0f 10 70 0c	 movss	 xmm6, DWORD PTR [eax+12]
  003fd	f3 0f 5c 69 04	 subss	 xmm5, DWORD PTR [ecx+4]
  00402	f3 0f 5c 71 08	 subss	 xmm6, DWORD PTR [ecx+8]
  00407	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]
  0040c	f3 0f 5c 21	 subss	 xmm4, DWORD PTR [ecx]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00410	0f 28 cd	 movaps	 xmm1, xmm5
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00413	f3 0f 11 ad 7c
	fe ff ff	 movss	 DWORD PTR _B$1$sroa$2108$1$[ebp], xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  0041b	0f 28 c6	 movaps	 xmm0, xmm6
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0041e	f3 0f 11 b5 78
	fe ff ff	 movss	 DWORD PTR _B$1$sroa$2107$1$[ebp], xmm6
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00426	0f 54 ca	 andps	 xmm1, xmm2
  00429	0f 54 c2	 andps	 xmm0, xmm2
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 186  : 		float radius = max(fabs(B.x),max(fabs(B.y),fabs(B.z)))/2;

  0042c	0f 2f c8	 comiss	 xmm1, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0042f	f3 0f 11 a5 80
	fe ff ff	 movss	 DWORD PTR tv3692[ebp], xmm4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 186  : 		float radius = max(fabs(B.x),max(fabs(B.y),fabs(B.z)))/2;

  00437	76 05		 jbe	 SHORT $LN22@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\cmath

; 99   :     return _CSTD fabsf(_Xx);

  00439	0f 28 d1	 movaps	 xmm2, xmm1

; 100  : }

  0043c	eb 03		 jmp	 SHORT $LN192@Render
$LN22@Render:

; 99   :     return _CSTD fabsf(_Xx);

  0043e	0f 28 d0	 movaps	 xmm2, xmm0
$LN192@Render:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00441	0f 28 dc	 movaps	 xmm3, xmm4
  00444	0f 54 1d 00 00
	00 00		 andps	 xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 186  : 		float radius = max(fabs(B.x),max(fabs(B.y),fabs(B.z)))/2;

  0044b	0f 2f da	 comiss	 xmm3, xmm2
  0044e	77 0d		 ja	 SHORT $LN216@Render
  00450	0f 2f c8	 comiss	 xmm1, xmm0
  00453	76 05		 jbe	 SHORT $LN24@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\cmath

; 99   :     return _CSTD fabsf(_Xx);

  00455	0f 28 d9	 movaps	 xmm3, xmm1

; 100  : }

  00458	eb 03		 jmp	 SHORT $LN216@Render
$LN24@Render:

; 99   :     return _CSTD fabsf(_Xx);

  0045a	0f 28 d8	 movaps	 xmm3, xmm0
$LN216@Render:
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 186  : 		float radius = max(fabs(B.x),max(fabs(B.y),fabs(B.z)))/2;

  0045d	f3 0f 59 df	 mulss	 xmm3, xmm7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00461	85 d2		 test	 edx, edx
  00463	74 3c		 je	 SHORT $LN227@Render
  00465	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv3785[ebp]
  0046b	8b f8		 mov	 edi, eax
  0046d	8b 12		 mov	 edx, DWORD PTR [edx]
  0046f	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _it1$$sroa$2112$1$[ebp], eax
  00475	89 95 a8 fe ff
	ff		 mov	 DWORD PTR __Mycont$1$[ebp], edx
  0047b	8b 00		 mov	 eax, DWORD PTR [eax]
  0047d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0047f	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00482	89 8d bc fe ff
	ff		 mov	 DWORD PTR __Mycont$1$[ebp], ecx
  00488	4a		 dec	 edx
  00489	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0048c	49		 dec	 ecx
  0048d	89 85 b8 fe ff
	ff		 mov	 DWORD PTR __Mycont$1$[ebp], eax
  00493	23 8d c4 fe ff
	ff		 and	 ecx, DWORD PTR _it1$$sroa$2110$1$[ebp]
  00499	23 95 c4 fe ff
	ff		 and	 edx, DWORD PTR _it1$$sroa$2110$1$[ebp]
  0049f	eb 2e		 jmp	 SHORT $LN252@Render
$LN227@Render:
  004a1	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ds:8
  004a7	33 c9		 xor	 ecx, ecx
  004a9	89 8d bc fe ff
	ff		 mov	 DWORD PTR __Mycont$1$[ebp], ecx
  004af	33 c0		 xor	 eax, eax
  004b1	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ds:8
  004b7	4a		 dec	 edx
  004b8	49		 dec	 ecx
  004b9	89 85 a8 fe ff
	ff		 mov	 DWORD PTR __Mycont$1$[ebp], eax
  004bf	23 cf		 and	 ecx, edi
  004c1	23 d7		 and	 edx, edi
  004c3	8b bd c0 fe ff
	ff		 mov	 edi, DWORD PTR tv3785[ebp]
  004c9	89 bd c0 fe ff
	ff		 mov	 DWORD PTR _it1$$sroa$2112$1$[ebp], edi
$LN252@Render:
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 187  : 		Vector3d c(it1->second.x+B.x*0.5f,

  004cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004d2	0f 28 d5	 movaps	 xmm2, xmm5
  004d5	f3 0f 59 d7	 mulss	 xmm2, xmm7
  004d9	0f 28 ce	 movaps	 xmm1, xmm6
  004dc	f3 0f 59 cf	 mulss	 xmm1, xmm7
  004e0	0f 28 c4	 movaps	 xmm0, xmm4
  004e3	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  004e6	f3 0f 59 c7	 mulss	 xmm0, xmm7
  004ea	f3 0f 58 50 08	 addss	 xmm2, DWORD PTR [eax+8]
  004ef	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR __Mycont$1$[ebp]
  004f5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004f8	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  004fb	f3 0f 58 48 0c	 addss	 xmm1, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00500	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR __Mycont$1$[ebp]
  00506	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 187  : 		Vector3d c(it1->second.x+B.x*0.5f,

  00509	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0050c	49		 dec	 ecx
  0050d	23 8d c4 fe ff
	ff		 and	 ecx, DWORD PTR _it1$$sroa$2110$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 191  : 		if (frustum.ViewVolumeTest(c, radius)==VS_OUTSIDE)

  00513	51		 push	 ecx
  00514	f3 0f 11 1c 24	 movss	 DWORD PTR [esp], xmm3
  00519	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0051c	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_frustum@CScreen@@1VFrustum@@A ; CScreen::ms_frustum
  00521	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  00526	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR _c$13[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\SphereLib\vector.h

; 38   : 		y = b;

  0052c	f3 0f 11 95 0c
	ff ff ff	 movss	 DWORD PTR _c$13[ebp+4], xmm2
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 191  : 		if (frustum.ViewVolumeTest(c, radius)==VS_OUTSIDE)

  00534	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\SphereLib\vector.h

; 39   : 		z = c;

  00535	f3 0f 11 8d 10
	ff ff ff	 movss	 DWORD PTR _c$13[ebp+8], xmm1
  0053d	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _c$13[ebp], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 191  : 		if (frustum.ViewVolumeTest(c, radius)==VS_OUTSIDE)

  00545	e8 00 00 00 00	 call	 ?ViewVolumeTest@Frustum@@QBE?AW4ViewState@@ABVVector3d@@M@Z ; Frustum::ViewVolumeTest
  0054a	83 f8 02	 cmp	 eax, 2
  0054d	0f 84 be 05 00
	00		 je	 $LN468@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00553	85 ff		 test	 edi, edi
  00555	74 04		 je	 SHORT $LN265@Render
  00557	8b 07		 mov	 eax, DWORD PTR [edi]
  00559	eb 02		 jmp	 SHORT $LN266@Render
$LN265@Render:
  0055b	33 c0		 xor	 eax, eax
$LN266@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0055d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 449  :         return pointer_traits<pointer>::pointer_to(**this);

  00560	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00563	49		 dec	 ecx
  00564	23 8d c4 fe ff
	ff		 and	 ecx, DWORD PTR _it1$$sroa$2110$1$[ebp]

; 449  :         return pointer_traits<pointer>::pointer_to(**this);

  0056a	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 194  : 		float rate1 = (1-(CTimer::Instance().GetCurrentSecond()-it1->first)/m_fTailLength);

  0056d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00573	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  00578	d8 26		 fsub	 DWORD PTR [esi]
  0057a	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00580	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00588	d9 9d b8 fe ff
	ff		 fstp	 DWORD PTR tv2010[ebp]
  0058e	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR tv2010[ebp]
  00596	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  0059b	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _it2$$sroa$2111$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 194  : 		float rate1 = (1-(CTimer::Instance().GetCurrentSecond()-it1->first)/m_fTailLength);

  005a1	f3 0f 5c c8	 subss	 xmm1, xmm0
  005a5	f3 0f 11 8d bc
	fe ff ff	 movss	 DWORD PTR _rate1$1$[ebp], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  005ad	85 c0		 test	 eax, eax
  005af	74 04		 je	 SHORT $LN277@Render
  005b1	8b 00		 mov	 eax, DWORD PTR [eax]
  005b3	eb 02		 jmp	 SHORT $LN278@Render
$LN277@Render:
  005b5	33 c0		 xor	 eax, eax
$LN278@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  005b7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 449  :         return pointer_traits<pointer>::pointer_to(**this);

  005ba	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  005bd	49		 dec	 ecx
  005be	23 8d b0 fe ff
	ff		 and	 ecx, DWORD PTR _it2$$sroa$2109$1$[ebp]

; 449  :         return pointer_traits<pointer>::pointer_to(**this);

  005c4	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 195  : 		float rate2 = (1-(CTimer::Instance().GetCurrentSecond()-it2->first)/m_fTailLength);

  005c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  005cd	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  005d2	d8 26		 fsub	 DWORD PTR [esi]
  005d4	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  005da	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000

; 196  : 		float size1 = m_fSize;
; 197  : 		float size2 = m_fSize;
; 198  : 		if (!m_bRectShape)

  005e2	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  005e6	d9 9d b8 fe ff
	ff		 fstp	 DWORD PTR tv2027[ebp]
  005ec	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR tv2027[ebp]
  005f4	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  005f9	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  005fe	f3 0f 5c d8	 subss	 xmm3, xmm0
  00602	0f 28 d1	 movaps	 xmm2, xmm1
  00605	75 0c		 jne	 SHORT $LN20@Render

; 199  : 		{
; 200  : 			size1 *= rate1;

  00607	f3 0f 59 8d bc
	fe ff ff	 mulss	 xmm1, DWORD PTR _rate1$1$[ebp]

; 201  : 			size2 *= rate2;

  0060f	f3 0f 59 d3	 mulss	 xmm2, xmm3
$LN20@Render:

; 94   : 	TFlyVertex(const D3DXVECTOR3& p, DWORD c, const D3DXVECTOR2 & t):p(p),c(c),t(t){}

  00613	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 202  : 		}
; 203  : 		TFlyVertex v[6] =
; 204  : 		{
; 205  : 			TFlyVertex(D3DXVECTOR3(0.0f,size1,0.0f), m_dwColor,D3DXVECTOR2(0.0f,0.0f)),
; 206  : 			TFlyVertex(D3DXVECTOR3(-size1,0.0f,0.0f),m_dwColor,D3DXVECTOR2(0.0f,0.5f)),

  00616	0f 28 c1	 movaps	 xmm0, xmm1
  00619	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 94   : 	TFlyVertex(const D3DXVECTOR3& p, DWORD c, const D3DXVECTOR2 & t):p(p),c(c),t(t){}

  00620	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _v$15[ebp+24], xmm0

; 207  : 			TFlyVertex(D3DXVECTOR3(size1,0.0f,0.0f), m_dwColor,D3DXVECTOR2(0.5f,0.0f)),
; 208  : 			TFlyVertex(D3DXVECTOR3(-size2,0.0f,0.0f),m_dwColor,D3DXVECTOR2(0.5f,1.0f)),

  00628	0f 28 c2	 movaps	 xmm0, xmm2
  0062b	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 94   : 	TFlyVertex(const D3DXVECTOR3& p, DWORD c, const D3DXVECTOR2 & t):p(p),c(c),t(t){}

  00632	89 85 6c ff ff
	ff		 mov	 DWORD PTR _v$15[ebp+12], eax
  00638	89 45 84	 mov	 DWORD PTR _v$15[ebp+36], eax
  0063b	89 45 9c	 mov	 DWORD PTR _v$15[ebp+60], eax
  0063e	89 45 b4	 mov	 DWORD PTR _v$15[ebp+84], eax
  00641	89 45 cc	 mov	 DWORD PTR _v$15[ebp+108], eax
  00644	89 45 e4	 mov	 DWORD PTR _v$15[ebp+132], eax

; 209  : 			TFlyVertex(D3DXVECTOR3(size2,0.0f,0.0f), m_dwColor,D3DXVECTOR2(1.0f,0.5f)),
; 210  : 			TFlyVertex(D3DXVECTOR3(0.0f,-size2,0.0f),m_dwColor,D3DXVECTOR2(1.0f,1.0f)),
; 211  : 
; 212  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f), ((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 213  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 214  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f), ((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 215  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 216  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f), ((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 217  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),*/
; 218  : 
; 219  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 220  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 221  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 222  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 223  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 224  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),*/
; 225  : 
; 226  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 227  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 228  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 229  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 230  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 231  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),*/
; 232  : 		};
; 233  : 
; 234  : 
; 235  : 		D3DXVECTOR3 E(M._41,M._42,M._43);
; 236  : 		E = pCurrentCamera->GetEye();

  00647	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _pCurrentCamera$1$[ebp]

; 94   : 	TFlyVertex(const D3DXVECTOR3& p, DWORD c, const D3DXVECTOR2 & t):p(p),c(c),t(t){}

  0064d	f3 0f 11 45 a8	 movss	 DWORD PTR _v$15[ebp+72], xmm0
  00652	f3 0f 11 45 dc	 movss	 DWORD PTR _v$15[ebp+124], xmm0
  00657	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$15[ebp], 0

; 209  : 			TFlyVertex(D3DXVECTOR3(size2,0.0f,0.0f), m_dwColor,D3DXVECTOR2(1.0f,0.5f)),
; 210  : 			TFlyVertex(D3DXVECTOR3(0.0f,-size2,0.0f),m_dwColor,D3DXVECTOR2(1.0f,1.0f)),
; 211  : 
; 212  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f), ((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 213  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 214  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f), ((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 215  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 216  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f), ((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 217  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),*/
; 218  : 
; 219  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 220  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 221  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 222  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 223  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 224  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),*/
; 225  : 
; 226  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 227  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 228  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 229  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 230  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 231  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),*/
; 232  : 		};
; 233  : 
; 234  : 
; 235  : 		D3DXVECTOR3 E(M._41,M._42,M._43);
; 236  : 		E = pCurrentCamera->GetEye();

  00661	f3 0f 7e 40 30	 movq	 xmm0, QWORD PTR [eax+48]
  00666	8b 40 38	 mov	 eax, DWORD PTR [eax+56]

; 94   : 	TFlyVertex(const D3DXVECTOR3& p, DWORD c, const D3DXVECTOR2 & t):p(p),c(c),t(t){}

  00669	f3 0f 11 8d 64
	ff ff ff	 movss	 DWORD PTR _v$15[ebp+4], xmm1
  00671	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$15[ebp+8], 0
  0067b	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$15[ebp+16], 0
  00685	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$15[ebp+20], 0
  0068f	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$15[ebp+28], 0
  00699	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+32], 0
  006a0	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+40], 0
  006a7	c7 45 8c 00 00
	00 3f		 mov	 DWORD PTR _v$15[ebp+44], 1056964608 ; 3f000000H
  006ae	f3 0f 11 4d 90	 movss	 DWORD PTR _v$15[ebp+48], xmm1
  006b3	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+52], 0
  006ba	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+56], 0
  006c1	c7 45 a0 00 00
	00 3f		 mov	 DWORD PTR _v$15[ebp+64], 1056964608 ; 3f000000H
  006c8	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+68], 0
  006cf	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+76], 0
  006d6	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+80], 0
  006dd	c7 45 b8 00 00
	00 3f		 mov	 DWORD PTR _v$15[ebp+88], 1056964608 ; 3f000000H
  006e4	c7 45 bc 00 00
	80 3f		 mov	 DWORD PTR _v$15[ebp+92], 1065353216 ; 3f800000H
  006eb	f3 0f 11 55 c0	 movss	 DWORD PTR _v$15[ebp+96], xmm2
  006f0	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+100], 0
  006f7	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+104], 0
  006fe	c7 45 d0 00 00
	80 3f		 mov	 DWORD PTR _v$15[ebp+112], 1065353216 ; 3f800000H
  00705	c7 45 d4 00 00
	00 3f		 mov	 DWORD PTR _v$15[ebp+116], 1056964608 ; 3f000000H
  0070c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+120], 0
  00713	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _v$15[ebp+128], 0
  0071a	c7 45 e8 00 00
	80 3f		 mov	 DWORD PTR _v$15[ebp+136], 1065353216 ; 3f800000H
  00721	c7 45 ec 00 00
	80 3f		 mov	 DWORD PTR _v$15[ebp+140], 1065353216 ; 3f800000H

; 209  : 			TFlyVertex(D3DXVECTOR3(size2,0.0f,0.0f), m_dwColor,D3DXVECTOR2(1.0f,0.5f)),
; 210  : 			TFlyVertex(D3DXVECTOR3(0.0f,-size2,0.0f),m_dwColor,D3DXVECTOR2(1.0f,1.0f)),
; 211  : 
; 212  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f), ((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 213  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 214  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f), ((DWORD)(0x40*rate1)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 215  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 216  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f), ((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 217  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),((DWORD)(0x40*rate2)<<24) + 0x0000ff,D3DXVECTOR2(0.0f,0.0f)),*/
; 218  : 
; 219  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 220  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 221  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 222  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 223  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),
; 224  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),0x20ff0000,D3DXVECTOR2(0.0f,0.0f)),*/
; 225  : 
; 226  : 			/*TVertex(D3DXVECTOR3(0.0f,size1,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 227  : 			TVertex(D3DXVECTOR3(-size1,0.0f,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 228  : 			TVertex(D3DXVECTOR3(size1,0.0f,0.0f),0xffff0000,D3DXVECTOR2(0.0f,0.0f)),
; 229  : 			TVertex(D3DXVECTOR3(-size2,0.0f,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 230  : 			TVertex(D3DXVECTOR3(size2,0.0f,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),
; 231  : 			TVertex(D3DXVECTOR3(0.0f,-size2,0.0f),0xff0000ff,D3DXVECTOR2(0.0f,0.0f)),*/
; 232  : 		};
; 233  : 
; 234  : 
; 235  : 		D3DXVECTOR3 E(M._41,M._42,M._43);
; 236  : 		E = pCurrentCamera->GetEye();

  00728	66 0f d6 85 6c
	fe ff ff	 movq	 QWORD PTR _E$11[ebp], xmm0
  00730	89 85 74 fe ff
	ff		 mov	 DWORD PTR _E$11[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00736	85 ff		 test	 edi, edi
  00738	74 04		 je	 SHORT $LN327@Render
  0073a	8b 07		 mov	 eax, DWORD PTR [edi]
  0073c	eb 02		 jmp	 SHORT $LN328@Render
$LN327@Render:
  0073e	33 c0		 xor	 eax, eax
$LN328@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00740	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 237  : 		E-=it1->second;

  00743	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00746	49		 dec	 ecx
  00747	23 8d c4 fe ff
	ff		 and	 ecx, DWORD PTR _it1$$sroa$2110$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 214  :     y -= v.y;

  0074d	f3 0f 10 b5 70
	fe ff ff	 movss	 xmm6, DWORD PTR _E$11[ebp+4]

; 215  :     z -= v.z;

  00755	f3 0f 10 bd 74
	fe ff ff	 movss	 xmm7, DWORD PTR _E$11[ebp+8]
  0075d	f3 0f 10 ad 6c
	fe ff ff	 movss	 xmm5, DWORD PTR _E$11[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 237  : 		E-=it1->second;

  00765	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00768	f3 0f 10 a5 80
	fe ff ff	 movss	 xmm4, DWORD PTR tv3692[ebp]

; 214  :     y -= v.y;

  00770	f3 0f 5c 70 08	 subss	 xmm6, DWORD PTR [eax+8]

; 215  :     z -= v.z;

  00775	f3 0f 5c 78 0c	 subss	 xmm7, DWORD PTR [eax+12]
  0077a	f3 0f 5c 68 04	 subss	 xmm5, DWORD PTR [eax+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 244  : 		D3DXVec3Normalize(&U,&U);

  0077f	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _U$14[ebp]
  00785	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00786	0f 28 c6	 movaps	 xmm0, xmm6

; 214  :     y -= v.y;

  00789	f3 0f 11 b5 b8
	fe ff ff	 movss	 DWORD PTR _E$2$[ebp], xmm6

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00791	f3 0f 59 85 78
	fe ff ff	 mulss	 xmm0, DWORD PTR _B$1$sroa$2107$1$[ebp]

; 215  :     z -= v.z;

  00799	0f 28 df	 movaps	 xmm3, xmm7
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 244  : 		D3DXVec3Normalize(&U,&U);

  0079c	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 215  :     z -= v.z;

  0079d	f3 0f 59 9d 7c
	fe ff ff	 mulss	 xmm3, DWORD PTR _B$1$sroa$2108$1$[ebp]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  007a5	0f 28 d5	 movaps	 xmm2, xmm5
  007a8	f3 0f 59 95 78
	fe ff ff	 mulss	 xmm2, DWORD PTR _B$1$sroa$2107$1$[ebp]
  007b0	f3 0f 5c d8	 subss	 xmm3, xmm0

; 213  :     x -= v.x;

  007b4	f3 0f 11 ad bc
	fe ff ff	 movss	 DWORD PTR _E$1$[ebp], xmm5

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  007bc	0f 28 c4	 movaps	 xmm0, xmm4

; 215  :     z -= v.z;

  007bf	f3 0f 11 bd a8
	fe ff ff	 movss	 DWORD PTR _E$3$[ebp], xmm7

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  007c7	f3 0f 59 c7	 mulss	 xmm0, xmm7
  007cb	f3 0f 59 e6	 mulss	 xmm4, xmm6
  007cf	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  007d3	0f 28 c5	 movaps	 xmm0, xmm5
  007d6	f3 0f 59 85 7c
	fe ff ff	 mulss	 xmm0, DWORD PTR _B$1$sroa$2108$1$[ebp]
  007de	f3 0f 5c e0	 subss	 xmm4, xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  007e2	0f 28 c2	 movaps	 xmm0, xmm2
  007e5	f3 0f 59 85 9c
	fe ff ff	 mulss	 xmm0, DWORD PTR _F$[ebp+8]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  007ed	f3 0f 59 95 94
	fe ff ff	 mulss	 xmm2, DWORD PTR _F$[ebp]

; 1281 :     *pOut = v;

  007f5	0f 28 cc	 movaps	 xmm1, xmm4

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  007f8	f3 0f 59 a5 94
	fe ff ff	 mulss	 xmm4, DWORD PTR _F$[ebp]

; 1281 :     *pOut = v;

  00800	f3 0f 59 8d 98
	fe ff ff	 mulss	 xmm1, DWORD PTR _F$[ebp+4]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00808	f3 0f 5c c8	 subss	 xmm1, xmm0
  0080c	0f 28 c3	 movaps	 xmm0, xmm3
  0080f	f3 0f 59 85 9c
	fe ff ff	 mulss	 xmm0, DWORD PTR _F$[ebp+8]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00817	f3 0f 59 9d 98
	fe ff ff	 mulss	 xmm3, DWORD PTR _F$[ebp+4]
  0081f	f3 0f 5c c4	 subss	 xmm0, xmm4

; 1280 : 
; 1281 :     *pOut = v;

  00823	f3 0f 11 8d 54
	ff ff ff	 movss	 DWORD PTR _U$14[ebp], xmm1
  0082b	f3 0f 5c d3	 subss	 xmm2, xmm3
  0082f	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _U$14[ebp+4], xmm0
  00837	f3 0f 11 95 5c
	ff ff ff	 movss	 DWORD PTR _U$14[ebp+8], xmm2
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 244  : 		D3DXVec3Normalize(&U,&U);

  0083f	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00844	f3 0f 10 ad 5c
	ff ff ff	 movss	 xmm5, DWORD PTR _U$14[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0084c	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _v$15[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00852	f3 0f 10 9d 58
	ff ff ff	 movss	 xmm3, DWORD PTR _U$14[ebp+4]
  0085a	0f 28 f5	 movaps	 xmm6, xmm5
  0085d	f3 0f 59 b5 98
	fe ff ff	 mulss	 xmm6, DWORD PTR _F$[ebp+4]
  00865	0f 28 c3	 movaps	 xmm0, xmm3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00868	bf 06 00 00 00	 mov	 edi, 6
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0086d	f3 0f 59 85 9c
	fe ff ff	 mulss	 xmm0, DWORD PTR _F$[ebp+8]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00875	0f 28 d3	 movaps	 xmm2, xmm3
  00878	f3 0f 10 8d 54
	ff ff ff	 movss	 xmm1, DWORD PTR _U$14[ebp]
  00880	f3 0f 59 95 94
	fe ff ff	 mulss	 xmm2, DWORD PTR _F$[ebp]
  00888	0f 28 e1	 movaps	 xmm4, xmm1
  0088b	f3 0f 59 a5 9c
	fe ff ff	 mulss	 xmm4, DWORD PTR _F$[ebp+8]
  00893	f3 0f 5c f0	 subss	 xmm6, xmm0
  00897	0f 28 c5	 movaps	 xmm0, xmm5
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 248  : 		m._21 = U.x;

  0089a	f3 0f 11 8d 24
	ff ff ff	 movss	 DWORD PTR _m$[ebp+16], xmm1
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  008a2	f3 0f 59 85 94
	fe ff ff	 mulss	 xmm0, DWORD PTR _F$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 249  : 		m._22 = U.y;

  008aa	f3 0f 11 9d 28
	ff ff ff	 movss	 DWORD PTR _m$[ebp+20], xmm3

; 250  : 		m._23 = U.z;

  008b2	f3 0f 11 ad 2c
	ff ff ff	 movss	 DWORD PTR _m$[ebp+24], xmm5
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  008ba	f3 0f 5c e0	 subss	 xmm4, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 251  : 		m._11 = R.x;

  008be	f3 0f 11 b5 14
	ff ff ff	 movss	 DWORD PTR _m$[ebp], xmm6
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  008c6	0f 28 c1	 movaps	 xmm0, xmm1
  008c9	f3 0f 59 85 98
	fe ff ff	 mulss	 xmm0, DWORD PTR _F$[ebp+4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 252  : 		m._12 = R.y;

  008d1	f3 0f 11 a5 18
	ff ff ff	 movss	 DWORD PTR _m$[ebp+4], xmm4
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  008d9	f3 0f 5c d0	 subss	 xmm2, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 253  : 		m._13 = R.z;

  008dd	f3 0f 11 95 1c
	ff ff ff	 movss	 DWORD PTR _m$[ebp+8], xmm2
$LL7@Render:

; 254  : 		int i;
; 255  : 		for(i=0;i<6;i++)
; 256  : 			D3DXVec3TransformNormal(&v[i].p,&v[i].p,&m);

  008e5	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _m$[ebp]
  008eb	50		 push	 eax
  008ec	56		 push	 esi
  008ed	56		 push	 esi
  008ee	e8 00 00 00 00	 call	 _D3DXVec3TransformNormal@12
  008f3	83 c6 18	 add	 esi, 24			; 00000018H
  008f6	83 ef 01	 sub	 edi, 1
  008f9	75 ea		 jne	 SHORT $LL7@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  008fb	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _it1$$sroa$2112$1$[ebp]
  00901	85 d2		 test	 edx, edx
  00903	74 04		 je	 SHORT $LN347@Render
  00905	8b 02		 mov	 eax, DWORD PTR [edx]
  00907	eb 02		 jmp	 SHORT $LN348@Render
$LN347@Render:
  00909	33 c0		 xor	 eax, eax
$LN348@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0090b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 258  : 			v[i].p += it1->second;

  0090e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00911	49		 dec	 ecx
  00912	8b b5 c4 fe ff
	ff		 mov	 esi, DWORD PTR _it1$$sroa$2110$1$[ebp]
  00918	23 ce		 and	 ecx, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 258  : 			v[i].p += it1->second;

  0091a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  0091d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00922	f3 0f 58 85 60
	ff ff ff	 addss	 xmm0, DWORD PTR _v$15[ebp]
  0092a	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _v$15[ebp], xmm0

; 205  :     y += v.y;

  00932	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00937	f3 0f 58 85 64
	ff ff ff	 addss	 xmm0, DWORD PTR _v$15[ebp+4]
  0093f	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _v$15[ebp+4], xmm0

; 206  :     z += v.z;

  00947	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0094c	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _v$15[ebp+8]
  00954	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v$15[ebp+8], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  0095c	85 d2		 test	 edx, edx
  0095e	74 04		 je	 SHORT $LN456@Render
  00960	8b 02		 mov	 eax, DWORD PTR [edx]
  00962	eb 02		 jmp	 SHORT $LN457@Render
$LN456@Render:
  00964	33 c0		 xor	 eax, eax
$LN457@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00966	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 258  : 			v[i].p += it1->second;

  00969	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0096c	49		 dec	 ecx
  0096d	23 ce		 and	 ecx, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 258  : 			v[i].p += it1->second;

  0096f	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  00972	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00977	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _v$15[ebp+24]
  0097f	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _v$15[ebp+24], xmm0

; 205  :     y += v.y;

  00987	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0098c	f3 0f 58 85 7c
	ff ff ff	 addss	 xmm0, DWORD PTR _v$15[ebp+28]
  00994	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _v$15[ebp+28], xmm0

; 206  :     z += v.z;

  0099c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  009a1	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _v$15[ebp+32]
  009a6	f3 0f 11 45 80	 movss	 DWORD PTR _v$15[ebp+32], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  009ab	85 d2		 test	 edx, edx
  009ad	74 04		 je	 SHORT $LN459@Render
  009af	8b 02		 mov	 eax, DWORD PTR [edx]
  009b1	eb 02		 jmp	 SHORT $LN460@Render
$LN459@Render:
  009b3	33 c0		 xor	 eax, eax
$LN460@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  009b5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  009b8	bf 03 00 00 00	 mov	 edi, 3
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 258  : 			v[i].p += it1->second;

  009bd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  009c0	49		 dec	 ecx
  009c1	23 ce		 and	 ecx, esi
  009c3	8d 75 b0	 lea	 esi, DWORD PTR _v$15[ebp+80]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 258  : 			v[i].p += it1->second;

  009c6	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  009c9	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  009ce	f3 0f 58 45 90	 addss	 xmm0, DWORD PTR _v$15[ebp+48]
  009d3	f3 0f 11 45 90	 movss	 DWORD PTR _v$15[ebp+48], xmm0

; 205  :     y += v.y;

  009d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  009dd	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _v$15[ebp+52]
  009e2	f3 0f 11 45 94	 movss	 DWORD PTR _v$15[ebp+52], xmm0

; 206  :     z += v.z;

  009e7	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  009ec	f3 0f 58 45 98	 addss	 xmm0, DWORD PTR _v$15[ebp+56]
  009f1	f3 0f 11 45 98	 movss	 DWORD PTR _v$15[ebp+56], xmm0
$LL451@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1180 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  009f6	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _it2$$sroa$2111$1$[ebp]
  009fc	85 c0		 test	 eax, eax
  009fe	74 04		 je	 SHORT $LN361@Render
  00a00	8b 00		 mov	 eax, DWORD PTR [eax]
  00a02	eb 02		 jmp	 SHORT $LN362@Render
$LN361@Render:
  00a04	33 c0		 xor	 eax, eax
$LN362@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00a06	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 260  : 			v[i].p += it2->second;

  00a09	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00a0c	49		 dec	 ecx
  00a0d	23 8d b0 fe ff
	ff		 and	 ecx, DWORD PTR _it2$$sroa$2109$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  00a13	f3 0f 10 46 f8	 movss	 xmm0, DWORD PTR [esi-8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 260  : 			v[i].p += it2->second;

  00a18	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  00a1b	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  00a20	f3 0f 11 46 f8	 movss	 DWORD PTR [esi-8], xmm0

; 205  :     y += v.y;

  00a25	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00a2a	f3 0f 58 46 fc	 addss	 xmm0, DWORD PTR [esi-4]
  00a2f	f3 0f 11 46 fc	 movss	 DWORD PTR [esi-4], xmm0

; 206  :     z += v.z;

  00a34	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00a39	f3 0f 58 06	 addss	 xmm0, DWORD PTR [esi]
  00a3d	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 259  : 		for(;i<6;i++)

  00a41	83 c6 18	 add	 esi, 24			; 00000018H
  00a44	83 ef 01	 sub	 edi, 1
  00a47	75 ad		 jne	 SHORT $LL451@Render
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00a49	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _pCurrentCamera$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00a4f	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _v$15[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00a55	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR _E$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00a5d	8d bd dc fd ff
	ff		 lea	 edi, DWORD PTR $T10[ebp+4]
  00a63	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00a68	89 95 c0 fe ff
	ff		 mov	 DWORD PTR _it1$$sroa$2112$1$[ebp], edx
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00a6e	f3 0f 10 48 58	 movss	 xmm1, DWORD PTR [eax+88]
  00a73	f3 0f 59 40 54	 mulss	 xmm0, DWORD PTR [eax+84]
  00a78	f3 0f 59 8d b8
	fe ff ff	 mulss	 xmm1, DWORD PTR _E$2$[ebp]
  00a80	f3 0f 58 c8	 addss	 xmm1, xmm0
  00a84	f3 0f 10 40 5c	 movss	 xmm0, DWORD PTR [eax+92]
  00a89	f3 0f 59 85 a8
	fe ff ff	 mulss	 xmm0, DWORD PTR _E$3$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00a91	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _VSVector$[ebp+4]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00a97	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 264  : 		VSVector.push_back(make_pair(-D3DXVec3Dot(&E,&pCurrentCamera->GetView()),TFlyVertexSet(v)));

  00a9b	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00aa2	f3 0f 11 8d d8
	fd ff ff	 movss	 DWORD PTR $T10[ebp], xmm1
  00aaa	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00aac	3b 85 a0 fe ff
	ff		 cmp	 eax, DWORD PTR _VSVector$2$[ebp]
  00ab2	74 38		 je	 SHORT $LN382@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00ab4	8b f8		 mov	 edi, eax
  00ab6	8d b5 d8 fd ff
	ff		 lea	 esi, DWORD PTR $T10[ebp]
  00abc	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00ac1	05 94 00 00 00	 add	 eax, 148		; 00000094H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00ac6	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 283  :         ++_Myoff;

  00ac8	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _it2$$sroa$2109$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00ace	8b b5 b4 fe ff
	ff		 mov	 esi, DWORD PTR _it2$$sroa$2111$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 283  :         ++_Myoff;

  00ad4	41		 inc	 ecx
  00ad5	ff 85 c4 fe ff
	ff		 inc	 DWORD PTR _it1$$sroa$2110$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00adb	89 85 8c fe ff
	ff		 mov	 DWORD PTR _VSVector$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 283  :         ++_Myoff;

  00ae1	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00ae7	e9 92 f8 ff ff	 jmp	 $LN471@Render
$LN382@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00aec	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00af2	51		 push	 ecx
  00af3	50		 push	 eax
  00af4	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _VSVector$[ebp]
  00afa	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@U?$pair@MUTFlyVertexSet@@@std@@@?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAEPAU?$pair@MUTFlyVertexSet@@@1@QAU21@$$QAU21@@Z ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::_Emplace_reallocate<std::pair<float,TFlyVertexSet> >
  00aff	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _VSVector$[ebp+8]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 191  : 		if (frustum.ViewVolumeTest(c, radius)==VS_OUTSIDE)

  00b05	8b b5 b4 fe ff
	ff		 mov	 esi, DWORD PTR _it2$$sroa$2111$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00b0b	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _VSVector$2$[ebp], eax
$LN468@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 283  :         ++_Myoff;

  00b11	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _it2$$sroa$2109$1$[ebp]
  00b17	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _it1$$sroa$2112$1$[ebp]
  00b1d	41		 inc	 ecx
  00b1e	ff 85 c4 fe ff
	ff		 inc	 DWORD PTR _it1$$sroa$2110$1$[ebp]
  00b24	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00b2a	e9 4f f8 ff ff	 jmp	 $LN471@Render
$LN3@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4138 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  00b2f	8b bd 8c fe ff
	ff		 mov	 edi, DWORD PTR _VSVector$[ebp+4]
  00b35	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00b3a	8b b5 88 fe ff
	ff		 mov	 esi, DWORD PTR _VSVector$[ebp]
  00b40	8b cf		 mov	 ecx, edi
  00b42	ff b5 80 fe ff
	ff		 push	 DWORD PTR $T12[ebp]
  00b48	2b ce		 sub	 ecx, esi
  00b4a	f7 e9		 imul	 ecx
  00b4c	03 d1		 add	 edx, ecx
  00b4e	c1 fa 07	 sar	 edx, 7
  00b51	8b c2		 mov	 eax, edx
  00b53	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00b56	03 c2		 add	 eax, edx
  00b58	50		 push	 eax
  00b59	57		 push	 edi
  00b5a	56		 push	 esi
  00b5b	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAU?$pair@MUTFlyVertexSet@@@std@@U?$less@X@2@@std@@YAXPAU?$pair@MUTFlyVertexSet@@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::pair<float,TFlyVertexSet> *,std::less<void> >
  00b60	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00b63	3b f7		 cmp	 esi, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 271  : 	for(TFlyVertexSetVector::iterator it = VSVector.begin();it!=VSVector.end();++it)

  00b65	74 28		 je	 SHORT $LN15@Render
$LL16@Render:

; 273  : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 4, it->second.v, sizeof(TVertex));

  00b67	6a 18		 push	 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00b69	56		 push	 esi
  00b6a	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MUTFlyVertexSet@@@std@@@std@@YAPAU?$pair@MUTFlyVertexSet@@@0@PBU10@@Z ; std::_Const_cast<std::pair<float,TFlyVertexSet> const >
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 273  : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 4, it->second.v, sizeof(TVertex));

  00b6f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00b75	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 273  : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 4, it->second.v, sizeof(TVertex));

  00b78	83 c0 04	 add	 eax, 4
  00b7b	50		 push	 eax
  00b7c	6a 04		 push	 4
  00b7e	6a 05		 push	 5
  00b80	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 75   :         ++_Ptr;

  00b85	81 c6 94 00 00
	00		 add	 esi, 148		; 00000094H

; 149  :         return _Ptr == _Right._Ptr;

  00b8b	3b f7		 cmp	 esi, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 271  : 	for(TFlyVertexSetVector::iterator it = VSVector.begin();it!=VSVector.end();++it)

  00b8d	75 d8		 jne	 SHORT $LL16@Render
$LN15@Render:

; 274  : 	}
; 275  : 	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  00b8f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00b95	6a 14		 push	 20			; 00000014H
  00b97	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 276  : 	STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);

  00b9c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ba2	6a 13		 push	 19			; 00000013H
  00ba4	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 277  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  00ba9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00baf	6a 1b		 push	 27			; 0000001bH
  00bb1	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 278  : 	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);

  00bb6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bbc	6a 16		 push	 22			; 00000016H
  00bbe	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 279  : 	STATEMANAGER.RestoreVertexShader();

  00bc3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bc9	e8 00 00 00 00	 call	 ?RestoreVertexShader@CStateManager@@QAEXXZ ; CStateManager::RestoreVertexShader

; 280  : 	STATEMANAGER.RestoreTransform(D3DTS_WORLD);

  00bce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bd4	68 00 01 00 00	 push	 256			; 00000100H
  00bd9	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 281  : 	//STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);
; 282  : 	STATEMANAGER.RestoreRenderState(D3DRS_ZFUNC);

  00bde	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00be4	6a 17		 push	 23			; 00000017H
  00be6	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 283  : 	STATEMANAGER.RestoreRenderState(D3DRS_BLENDOP);

  00beb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bf1	68 ab 00 00 00	 push	 171			; 000000abH
  00bf6	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 284  : 
; 285  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);

  00bfb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c01	6a 0f		 push	 15			; 0000000fH
  00c03	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 286  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAFUNC);

  00c08	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c0e	6a 19		 push	 25			; 00000019H
  00c10	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 287  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAREF);

  00c15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c1b	6a 18		 push	 24			; 00000018H
  00c1d	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 289  : }

  00c22	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00c28	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00c2d	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _VSVector$[ebp]
  00c33	85 c9		 test	 ecx, ecx
  00c35	74 2b		 je	 SHORT $LN429@Render

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00c37	8b b5 a0 fe ff
	ff		 mov	 esi, DWORD PTR _VSVector$2$[ebp]
  00c3d	b8 a7 c8 67 dd	 mov	 eax, -580400985		; dd67c8a7H
  00c42	2b f1		 sub	 esi, ecx
  00c44	f7 ee		 imul	 esi
  00c46	03 d6		 add	 edx, esi
  00c48	c1 fa 07	 sar	 edx, 7
  00c4b	8b c2		 mov	 eax, edx
  00c4d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00c50	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c52	69 c0 94 00 00
	00		 imul	 eax, eax, 148
  00c58	50		 push	 eax
  00c59	51		 push	 ecx
  00c5a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00c5f	83 c4 08	 add	 esp, 8
$LN429@Render:
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 289  : }

  00c62	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c65	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c6c	59		 pop	 ecx
  00c6d	5f		 pop	 edi
  00c6e	5e		 pop	 esi
  00c6f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c72	33 cd		 xor	 ecx, ebp
  00c74	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c79	8b e5		 mov	 esp, ebp
  00c7b	5d		 pop	 ebp
  00c7c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CFlyTrace@@QAEXXZ$0:
  00000	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _VSVector$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@U?$pair@MUTFlyVertexSet@@@std@@V?$allocator@U?$pair@MUTFlyVertexSet@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >::~vector<std::pair<float,TFlyVertexSet>,std::allocator<std::pair<float,TFlyVertexSet> > >
__unwindfunclet$?Render@CFlyTrace@@QAEXXZ$1:
  0000b	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$?Render@CFlyTrace@@QAEXXZ:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 8a d8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-552]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CFlyTrace@@QAEXXZ
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CFlyTrace@@QAEXXZ ENDP				; CFlyTrace::Render
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?Update@CFlyTrace@@QAEXXZ
_TEXT	SEGMENT
?Update@CFlyTrace@@QAEXXZ PROC				; CFlyTrace::Update, COMDAT
; _this$ = ecx

; 83   : 
; 84   : }

  00000	c2 00 00	 ret	 0
?Update@CFlyTrace@@QAEXXZ ENDP				; CFlyTrace::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?UpdateNewPosition@CFlyTrace@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Tmp$2 = -8						; size = 8
tv346 = -4						; size = 4
tv355 = 8						; size = 4
_v3Position$ = 8					; size = 4
?UpdateNewPosition@CFlyTrace@@QAEXABUD3DXVECTOR3@@@Z PROC ; CFlyTrace::UpdateNewPosition, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 63   : 	m_TimePositionDeque.push_front(TTimePosition(CTimer::Instance().GetCurrentSecond(),v3Position));

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00015	8b 45 08	 mov	 eax, DWORD PTR _v3Position$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 63   : 	m_TimePositionDeque.push_front(TTimePosition(CTimer::Instance().GetCurrentSecond(),v3Position));

  00018	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0001b	d9 5d f0	 fstp	 DWORD PTR $T1[ebp]
  0001e	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00022	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00025	89 45 fc	 mov	 DWORD PTR $T1[ebp+12], eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 63   : 	m_TimePositionDeque.push_front(TTimePosition(CTimer::Instance().GetCurrentSecond(),v3Position));

  00028	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  0002b	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0002c	66 0f d6 45 f4	 movq	 QWORD PTR $T1[ebp+4], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 63   : 	m_TimePositionDeque.push_front(TTimePosition(CTimer::Instance().GetCurrentSecond(),v3Position));

  00031	e8 00 00 00 00	 call	 ?push_front@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@QAEX$$QAU?$pair@MUD3DXVECTOR3@@@2@@Z ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::push_front
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1009 :         return _Mysize() == 0;

  00036	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 65   : 	while(!m_TimePositionDeque.empty() && m_TimePositionDeque.back().first+m_fTailLength<CTimer::Instance().GetCurrentSecond())

  0003a	74 4e		 je	 SHORT $LN3@UpdateNewP
  0003c	0f 1f 40 00	 npad	 4
$LL2@UpdateNewP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 921  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00040	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00043	03 46 24	 add	 eax, DWORD PTR [esi+36]

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00046	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 65   : 	while(!m_TimePositionDeque.empty() && m_TimePositionDeque.back().first+m_fTailLength<CTimer::Instance().GetCurrentSecond())

  00049	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0004e	49		 dec	 ecx

; 216  :         _Deque_unchecked_iterator _Tmp = *this;

  0004f	89 45 fc	 mov	 DWORD PTR __Tmp$2[ebp+4], eax

; 97   :         _Myoff -= _Off;

  00052	48		 dec	 eax

; 547  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00053	23 c8		 and	 ecx, eax

; 1067 :         return *(_Unchecked_end() - 1);

  00055	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00058	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 65   : 	while(!m_TimePositionDeque.empty() && m_TimePositionDeque.back().first+m_fTailLength<CTimer::Instance().GetCurrentSecond())

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00061	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  00065	f3 0f 11 45 fc	 movss	 DWORD PTR tv346[ebp], xmm0
  0006a	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  0006f	d9 5d 08	 fstp	 DWORD PTR tv355[ebp]
  00072	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv355[ebp]
  00077	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR tv346[ebp]
  0007b	76 0d		 jbe	 SHORT $LN3@UpdateNewP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1143 :         if (--_Mysize() == 0) {

  0007d	83 46 24 ff	 add	 DWORD PTR [esi+36], -1
  00081	75 bd		 jne	 SHORT $LL2@UpdateNewP

; 1144 :             _Myoff() = 0;

  00083	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN3@UpdateNewP:
  0008a	5f		 pop	 edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 69   : }

  0008b	5e		 pop	 esi
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?UpdateNewPosition@CFlyTrace@@QAEXABUD3DXVECTOR3@@@Z ENDP ; CFlyTrace::UpdateNewPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?Create@CFlyTrace@@QAEXABUTFlyingAttachData@CFlyingData@@@Z
_TEXT	SEGMENT
_rFlyingAttachData$ = 8					; size = 4
?Create@CFlyTrace@@QAEXABUTFlyingAttachData@CFlyingData@@@Z PROC ; CFlyTrace::Create, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	//assert(rFlyingAttachData.bHasTail);
; 74   : 	m_dwColor = rFlyingAttachData.dwTailColor;

  00003	8b 55 08	 mov	 edx, DWORD PTR _rFlyingAttachData$[ebp]
  00006	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00009	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 75   : 	m_fTailLength = rFlyingAttachData.fTailLength;

  0000c	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0000f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 76   : 	m_fSize = rFlyingAttachData.fTailSize;

  00012	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00015	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 77   : 	m_bRectShape = rFlyingAttachData.bRectShape;

  00018	8a 42 30	 mov	 al, BYTE PTR [edx+48]
  0001b	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 78   : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?Create@CFlyTrace@@QAEXABUTFlyingAttachData@CFlyingData@@@Z ENDP ; CFlyTrace::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ?Destroy@CFlyTrace@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CFlyTrace@@QAEXXZ PROC				; CFlyTrace::Destroy, COMDAT
; _this$ = ecx

; 55   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 56   : 	m_TimePositionDeque.clear();

  00003	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 1325 :         _Tidy();

  00006	e8 00 00 00 00	 call	 ?_Tidy@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@AAEXXZ ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Tidy
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 58   : 	__Initialize();

  0000b	8b ce		 mov	 ecx, esi
  0000d	5e		 pop	 esi
  0000e	e9 00 00 00 00	 jmp	 ?__Initialize@CFlyTrace@@IAEXXZ ; CFlyTrace::__Initialize
?Destroy@CFlyTrace@@QAEXXZ ENDP				; CFlyTrace::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ??1CFlyTrace@@UAE@XZ
_TEXT	SEGMENT
__Proxy_allocator$1 = -1				; size = 1
??1CFlyTrace@@UAE@XZ PROC				; CFlyTrace::~CFlyTrace, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CFlyTrace@@6B@

; 42   : 	Destroy();

  0000e	e8 00 00 00 00	 call	 ?Destroy@CFlyTrace@@QAEXXZ ; CFlyTrace::Destroy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 869  :         _Tidy();

  00013	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00016	e8 00 00 00 00	 call	 ?_Tidy@?$deque@U?$pair@MUD3DXVECTOR3@@@std@@V?$allocator@U?$pair@MUD3DXVECTOR3@@@std@@@2@@std@@AAEXXZ ; std::deque<std::pair<float,D3DXVECTOR3>,std::allocator<std::pair<float,D3DXVECTOR3> > >::_Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 599  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001b	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 871  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  0001e	50		 push	 eax
  0001f	8d 45 ff	 lea	 eax, DWORD PTR __Proxy_allocator$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 600  :     _Val         = static_cast<_Other&&>(_New_val);

  00022	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 871  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  0002f	83 c4 08	 add	 esp, 8
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 43   : }

  00032	8b cf		 mov	 ecx, edi
  00034	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1CFlyTrace@@UAE@XZ ENDP				; CFlyTrace::~CFlyTrace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp
;	COMDAT ??0CFlyTrace@@QAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CFlyTrace@@QAE@XZ PROC				; CFlyTrace::CFlyTrace, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CFlyTrace@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b d9		 mov	 ebx, ecx
  00028	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
  0002b	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00030	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CFlyTrace@@6B@
  00036	8d 7b 14	 lea	 edi, DWORD PTR [ebx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00039	6a 08		 push	 8
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 27   : {

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1092 :     _Container_base12() noexcept : _Myproxy(nullptr) {}

  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\deque

; 543  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  00048	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0004f	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00056	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  0005d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00064	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>

; 1102 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  00069	8b f0		 mov	 esi, eax

; 1103 :         _Construct_in_place(*_New_proxy, this);

  0006b	89 7d f0	 mov	 DWORD PTR $T2[ebp], edi
  0006e	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  00071	50		 push	 eax
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1104 :         _Myproxy            = _New_proxy;

  0007b	89 37		 mov	 DWORD PTR [edi], esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 28   : 	__Initialize();

  0007d	8b cb		 mov	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1105 :         _New_proxy->_Mycont = this;

  0007f	89 3e		 mov	 DWORD PTR [esi], edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\FlyTrace.cpp

; 28   : 	__Initialize();

  00081	e8 00 00 00 00	 call	 ?__Initialize@CFlyTrace@@IAEXXZ ; CFlyTrace::__Initialize

; 29   : 
; 30   : 	/*
; 31   : 	// Code for texture
; 32   : 	CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer("d:/ray.jpg");
; 33   : 	m_ImageInstance.SetImagePointer(pImage);
; 34   : 
; 35   : 	CGraphicTexture * pTexture = m_ImageInstance.GetTexturePointer();
; 36   : 	m_lpTexture = pTexture->GetD3DTexture();
; 37   : 	*/
; 38   : }

  00086	8b c3		 mov	 eax, ebx
  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFlyTrace@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0CFlyTrace@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CFlyTrace@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CFlyTrace@@QAE@XZ ENDP				; CFlyTrace::CFlyTrace
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
