; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0D3DXVECTOR4@@QAE@XZ				; D3DXVECTOR4::D3DXVECTOR4
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch
PUBLIC	??0SoftwareTransformPatch_STVertex@CMapOutdoor@@QAE@XZ ; CMapOutdoor::SoftwareTransformPatch_STVertex::SoftwareTransformPatch_STVertex
PUBLIC	??0SoftwareTransformPatch_STLVertex@CMapOutdoor@@QAE@XZ ; CMapOutdoor::SoftwareTransformPatch_STLVertex::SoftwareTransformPatch_STLVertex
PUBLIC	?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState
PUBLIC	?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Initialize
PUBLIC	?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ ; CMapOutdoor::__SoftwareTransformPatch_Create
PUBLIC	?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Destroy
PUBLIC	?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline
PUBLIC	?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z ; CMapOutdoor::__SoftwareTransformPatch_SetTransform
PUBLIC	?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream
PUBLIC	?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream
PUBLIC	?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState
PUBLIC	?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState
PUBLIC	?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat
PUBLIC	?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone
PUBLIC	??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >
PUBLIC	??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
PUBLIC	??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z		; std::_Refancy<int *,0>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
PUBLIC	??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
PUBLIC	??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
PUBLIC	??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	__real@3acccccd
PUBLIC	__real@3e000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@4144ec4c
PUBLIC	__real@437f0000
PUBLIC	__real@44480000
PUBLIC	__real@45480000
PUBLIC	__real@461c4000
PUBLIC	__real@bacccccd
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	_D3DXVec3Transform@12:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	?GetBackBufferSize@CGraphicBase@@SAXPAI0@Z:PROC	; CGraphicBase::GetBackBufferSize
EXTRN	?IsTLVertexClipping@CGraphicBase@@SA_NXZ:PROC	; CGraphicBase::IsTLVertexClipping
EXTRN	?IsFastTNL@CGraphicBase@@SA_NXZ:PROC		; CGraphicBase::IsFastTNL
EXTRN	?GetFogNearDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogNearDistance
EXTRN	?GetFogFarDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogFarDistance
EXTRN	?GetTextureCount@CTextureSet@@QAEKXZ:PROC	; CTextureSet::GetTextureCount
EXTRN	?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z:PROC ; CTextureSet::GetTexture
EXTRN	?IsIn@CTerrainPatchProxy@@QAE_NABUD3DXVECTOR3@@M@Z:PROC ; CTerrainPatchProxy::IsIn
EXTRN	?SoftwareTransformPatch_GetTerrainVertexDataPtr@CTerrainPatchProxy@@QAEPAUSoftwareTransformPatch_SSourceVertex@@XZ:PROC ; CTerrainPatchProxy::SoftwareTransformPatch_GetTerrainVertexDataPtr
EXTRN	?SoftwareTransformPatch_UpdateTerrainLighting@CTerrainPatchProxy@@QAEXKABU_D3DLIGHT8@@ABU_D3DMATERIAL8@@@Z:PROC ; CTerrainPatchProxy::SoftwareTransformPatch_UpdateTerrainLighting
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z:PROC ; CMapOutdoor::SelectIndexBuffer
EXTRN	?__GetNoFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetNoFogDistance
EXTRN	?__GetFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetFogDistance
EXTRN	?GetMaterial@CStateManager@@QAEXPAU_D3DMATERIAL8@@@Z:PROC ; CStateManager::GetMaterial
EXTRN	?GetLight@CStateManager@@QAEXKPAU_D3DLIGHT8@@@Z:PROC ; CStateManager::GetLight
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetBestFiltering@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetBestFiltering
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?GetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PAU_D3DMATRIX@@@Z:PROC ; CStateManager::GetTransform
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A:DWORD ; CGraphicBase::ms_lpd3dDevice
EXTRN	?ms_faceCount@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_faceCount
EXTRN	?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA:BYTE	; CSpeedTreeWrapper::ms_bSelfShadowOn
EXTRN	?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A:DWORD ; CTerrainImpl::ms_pTextureSet
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bacccccd
CONST	SEGMENT
__real@bacccccd DD 0bacccccdr			; -0.0015625
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@45480000
CONST	SEGMENT
__real@45480000 DD 045480000r			; 3200
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@4144ec4c
CONST	SEGMENT
__real@4144ec4c DD 04144ec4cr			; 12.3077
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3acccccd
CONST	SEGMENT
__real@3acccccd DD 03acccccdr			; 0.0015625
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_backward_memmove<int *,int *>, COMDAT

; 4284 : _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4285 :     // implement copy_backward-like function as memmove
; 4286 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4287 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4288 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4289 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b c8		 sub	 ecx, eax

; 4290 :     return static_cast<_BidIt2>(_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count));

  0000b	51		 push	 ecx
  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00010	2b c1		 sub	 eax, ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4291 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_backward_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z
_TEXT	SEGMENT
tv670 = -4						; size = 4
tv693 = 8						; size = 4
tv677 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Tmp$1$ = 16						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<int *,std::less<void> >, COMDAT

; 4019 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4020 :     // sort median element to middle
; 4021 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 4022 :     const _Diff _Count = _Last - _First;

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi

; 4023 :     if (40 < _Count) { // Tukey's ninther

  00013	83 f8 28	 cmp	 eax, 40			; 00000028H
  00016	0f 8e e1 00 00
	00		 jle	 $LN2@Guess_medi

; 4024 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001c	40		 inc	 eax
  0001d	c1 f8 03	 sar	 eax, 3
  00020	53		 push	 ebx

; 4026 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00021	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00028	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]
  0002f	89 55 fc	 mov	 DWORD PTR tv670[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00032	8b 3c 0b	 mov	 edi, DWORD PTR [ebx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4026 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00035	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4026 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0003a	89 5d 08	 mov	 DWORD PTR tv693[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0003d	3b f8		 cmp	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4005 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0003f	7d 06		 jge	 SHORT $LN15@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00041	89 02		 mov	 DWORD PTR [edx], eax

; 108  :     _Right   = _STD move(_Tmp);

  00043	89 39		 mov	 DWORD PTR [ecx], edi
  00045	8b 3a		 mov	 edi, DWORD PTR [edx]
$LN15@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00047	8b 45 fc	 mov	 eax, DWORD PTR tv670[ebp]
  0004a	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  0004d	3b c7		 cmp	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4009 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  0004f	7d 15		 jge	 SHORT $LN27@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00051	8b 75 fc	 mov	 esi, DWORD PTR tv670[ebp]
  00054	89 3c 0e	 mov	 DWORD PTR [esi+ecx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4012 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00057	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 108  :     _Right   = _STD move(_Tmp);

  0005a	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0005c	8b 39		 mov	 edi, DWORD PTR [ecx]
  0005e	3b c7		 cmp	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4012 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00060	7d 04		 jge	 SHORT $LN27@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00062	89 3a		 mov	 DWORD PTR [edx], edi

; 108  :     _Right   = _STD move(_Tmp);

  00064	89 01		 mov	 DWORD PTR [ecx], eax
$LN27@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4027 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00066	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00069	8b c8		 mov	 ecx, eax
  0006b	2b cb		 sub	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0006d	8b 38		 mov	 edi, DWORD PTR [eax]
  0006f	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00071	3b fb		 cmp	 edi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4005 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00073	7d 06		 jge	 SHORT $LN38@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00075	89 18		 mov	 DWORD PTR [eax], ebx

; 108  :     _Right   = _STD move(_Tmp);

  00077	89 39		 mov	 DWORD PTR [ecx], edi
  00079	8b 38		 mov	 edi, DWORD PTR [eax]
$LN38@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0007b	8b 5d 08	 mov	 ebx, DWORD PTR tv693[ebp]
  0007e	8b 1c 03	 mov	 ebx, DWORD PTR [ebx+eax]
  00081	3b df		 cmp	 ebx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4009 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00083	7d 15		 jge	 SHORT $LN50@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00085	8b 75 08	 mov	 esi, DWORD PTR tv693[ebp]
  00088	89 3c 06	 mov	 DWORD PTR [esi+eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4012 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0008b	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 108  :     _Right   = _STD move(_Tmp);

  0008e	89 18		 mov	 DWORD PTR [eax], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00090	8b 39		 mov	 edi, DWORD PTR [ecx]
  00092	3b df		 cmp	 ebx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4012 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00094	7d 04		 jge	 SHORT $LN50@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00096	89 38		 mov	 DWORD PTR [eax], edi

; 108  :     _Right   = _STD move(_Tmp);

  00098	89 19		 mov	 DWORD PTR [ecx], ebx
$LN50@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4028 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  0009a	8b ce		 mov	 ecx, esi
  0009c	8b fe		 mov	 edi, esi
  0009e	2b 4d 08	 sub	 ecx, DWORD PTR tv693[ebp]
  000a1	2b 7d fc	 sub	 edi, DWORD PTR tv670[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000a4	8b 19		 mov	 ebx, DWORD PTR [ecx]
  000a6	8b 07		 mov	 eax, DWORD PTR [edi]
  000a8	3b d8		 cmp	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4005 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000aa	7d 0b		 jge	 SHORT $LN61@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  000ac	8b f0		 mov	 esi, eax
  000ae	89 31		 mov	 DWORD PTR [ecx], esi
  000b0	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]

; 108  :     _Right   = _STD move(_Tmp);

  000b3	89 1f		 mov	 DWORD PTR [edi], ebx
  000b5	8b 19		 mov	 ebx, DWORD PTR [ecx]
$LN61@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	3b c3		 cmp	 eax, ebx
  000bb	89 45 10	 mov	 DWORD PTR __Tmp$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4009 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  000be	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000c1	7d 11		 jge	 SHORT $LN73@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  000c3	89 1e		 mov	 DWORD PTR [esi], ebx

; 108  :     _Right   = _STD move(_Tmp);

  000c5	8b 5d 10	 mov	 ebx, DWORD PTR __Tmp$1$[ebp]
  000c8	89 19		 mov	 DWORD PTR [ecx], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000ca	8b 37		 mov	 esi, DWORD PTR [edi]
  000cc	3b de		 cmp	 ebx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4012 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000ce	7d 04		 jge	 SHORT $LN73@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  000d0	89 31		 mov	 DWORD PTR [ecx], esi

; 108  :     _Right   = _STD move(_Tmp);

  000d2	89 1f		 mov	 DWORD PTR [edi], ebx
$LN73@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000d4	8b 30		 mov	 esi, DWORD PTR [eax]
  000d6	8b 3a		 mov	 edi, DWORD PTR [edx]
  000d8	5b		 pop	 ebx
  000d9	3b f7		 cmp	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4005 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000db	7d 06		 jge	 SHORT $LN84@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  000dd	89 38		 mov	 DWORD PTR [eax], edi

; 108  :     _Right   = _STD move(_Tmp);

  000df	89 32		 mov	 DWORD PTR [edx], esi
  000e1	8b 30		 mov	 esi, DWORD PTR [eax]
$LN84@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000e3	8b 39		 mov	 edi, DWORD PTR [ecx]
  000e5	3b fe		 cmp	 edi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4009 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  000e7	7d 39		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  000e9	89 31		 mov	 DWORD PTR [ecx], esi

; 108  :     _Right   = _STD move(_Tmp);

  000eb	89 38		 mov	 DWORD PTR [eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000ed	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000ef	3b f9		 cmp	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4012 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000f1	7d 2f		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  000f3	89 08		 mov	 DWORD PTR [eax], ecx

; 108  :     _Right   = _STD move(_Tmp);

  000f5	89 3a		 mov	 DWORD PTR [edx], edi
  000f7	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4033 : }

  000f8	5e		 pop	 esi
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN2@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000fd	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00100	8b 39		 mov	 edi, DWORD PTR [ecx]
  00102	8b 10		 mov	 edx, DWORD PTR [eax]
  00104	3b d7		 cmp	 edx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4005 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00106	7d 06		 jge	 SHORT $LN107@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00108	89 38		 mov	 DWORD PTR [eax], edi

; 108  :     _Right   = _STD move(_Tmp);

  0010a	89 11		 mov	 DWORD PTR [ecx], edx
  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
$LN107@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0010e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00110	3b fa		 cmp	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4009 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00112	7d 0e		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00114	89 16		 mov	 DWORD PTR [esi], edx

; 108  :     _Right   = _STD move(_Tmp);

  00116	89 38		 mov	 DWORD PTR [eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00118	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011a	3b fa		 cmp	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4012 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0011c	7d 04		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  0011e	89 10		 mov	 DWORD PTR [eax], edx

; 108  :     _Right   = _STD move(_Tmp);

  00120	89 39		 mov	 DWORD PTR [ecx], edi
$LN119@Guess_medi:
  00122	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4033 : }

  00123	5e		 pop	 esi
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv253 = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >, COMDAT

; 3354 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3355 :     // percolate _Hole to _Bottom, then push _Val, using _Pred
; 3356 :     _STL_INTERNAL_CHECK(_Bottom != 0);
; 3357 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 3358 :     const _Diff _Top = _Hole;
; 3359 :     _Diff _Idx       = _Hole;
; 3360 : 
; 3361 :     // Check whether _Idx can have a child before calculating that child's index, since
; 3362 :     // calculating the child's index can trigger integer overflows
; 3363 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Bottom$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00009	8b d0		 mov	 edx, eax
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00010	8b d8		 mov	 ebx, eax
  00012	57		 push	 edi
  00013	8b fe		 mov	 edi, esi
  00015	89 75 0c	 mov	 DWORD PTR tv253[ebp], esi

; 3364 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  00018	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0001b	d1 ff		 sar	 edi, 1
  0001d	3b c7		 cmp	 eax, edi
  0001f	7d 21		 jge	 SHORT $LN3@Pop_heap_h
$LL2@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00021	8b 4c d6 08	 mov	 ecx, DWORD PTR [esi+edx*8+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3365 :         _Idx = 2 * _Idx + 2;

  00025	8d 14 55 02 00
	00 00		 lea	 edx, DWORD PTR [edx*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0002c	3b 4c 96 fc	 cmp	 ecx, DWORD PTR [esi+edx*4-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3366 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00030	7d 01		 jge	 SHORT $LN4@Pop_heap_h

; 3367 :             --_Idx;

  00032	4a		 dec	 edx
$LN4@Pop_heap_h:

; 3368 :         }
; 3369 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00033	8b 0c 96	 mov	 ecx, DWORD PTR [esi+edx*4]
  00036	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx

; 3370 :         _Hole             = _Idx;

  00039	8b c2		 mov	 eax, edx
  0003b	3b d7		 cmp	 edx, edi
  0003d	7c e2		 jl	 SHORT $LL2@Pop_heap_h
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR __Bottom$[ebp]
$LN3@Pop_heap_h:

; 3371 :     }
; 3372 : 
; 3373 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00042	3b d7		 cmp	 edx, edi
  00044	75 0f		 jne	 SHORT $LN5@Pop_heap_h
  00046	f6 c1 01	 test	 cl, 1
  00049	75 0a		 jne	 SHORT $LN5@Pop_heap_h

; 3374 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  0004b	8b 4c 8e fc	 mov	 ecx, DWORD PTR [esi+ecx*4-4]
  0004f	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx

; 3375 :         _Hole             = _Bottom - 1;

  00052	8b 45 0c	 mov	 eax, DWORD PTR tv253[ebp]
$LN5@Pop_heap_h:

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00055	3b d8		 cmp	 ebx, eax
  00057	7d 26		 jge	 SHORT $LN24@Pop_heap_h
  00059	8b 7d 14	 mov	 edi, DWORD PTR __Val$[ebp]
  0005c	0f 1f 40 00	 npad	 4
$LL12@Pop_heap_h:

; 3320 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00060	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00063	d1 f9		 sar	 ecx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00065	8b 14 8e	 mov	 edx, DWORD PTR [esi+ecx*4]
  00068	3b 17		 cmp	 edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  0006a	7d 09		 jge	 SHORT $LN25@Pop_heap_h

; 3322 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 3323 :         // move _Hole up to parent
; 3324 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0006c	89 14 86	 mov	 DWORD PTR [esi+eax*4], edx

; 3325 :         _Hole             = _Idx;

  0006f	8b c1		 mov	 eax, ecx
  00071	3b d9		 cmp	 ebx, ecx
  00073	7c eb		 jl	 SHORT $LL12@Pop_heap_h
$LN25@Pop_heap_h:

; 3376 :     }
; 3377 : 
; 3378 :     _Push_heap_by_index(_First, _Hole, _Top, _STD move(_Val), _Pred);
; 3379 : }

  00075	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00077	5f		 pop	 edi
  00078	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN24@Pop_heap_h:

; 3328 :     *(_First + _Hole) = _STD move(_Val); // drop _Val into final hole

  0007f	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00082	5f		 pop	 edi
  00083	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 3376 :     }
; 3377 : 
; 3378 :     _Push_heap_by_index(_First, _Hole, _Top, _STD move(_Val), _Pred);
; 3379 : }

  00085	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z PROC ; std::_Refancy<std::pair<float,long> *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ENDP ; std::_Refancy<std::pair<float,long> *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z
_TEXT	SEGMENT
tv557 = -12						; size = 4
__Gfirst$1$ = -12					; size = 4
tv551 = -8						; size = 4
__Glast$1$ = -8						; size = 4
__Plast$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >, COMDAT

; 4036 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 4037 :     // partition [_First, _Last), using _Pred
; 4038 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	8b c3		 mov	 eax, ebx
  0000f	56		 push	 esi
  00010	2b c1		 sub	 eax, ecx
  00012	c1 f8 03	 sar	 eax, 3
  00015	57		 push	 edi

; 4039 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  00016	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00019	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  0001c	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  0001f	50		 push	 eax
  00020	56		 push	 esi
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
  00027	83 c4 10	 add	 esp, 16			; 00000010H

; 4040 :     _RanIt _Pfirst = _Mid;
; 4041 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  0002a	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0002d	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi

; 4044 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00030	39 75 0c	 cmp	 DWORD PTR __First$[ebp], esi
  00033	73 20		 jae	 SHORT $LN82@Partition_
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	8b 5d 0c	 mov	 ebx, DWORD PTR __First$[ebp]
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00040	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00043	3b c1		 cmp	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4044 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00045	7c 0b		 jl	 SHORT $LN107@Partition_
  00047	7f 09		 jg	 SHORT $LN107@Partition_

; 4045 :         --_Pfirst;

  00049	83 c6 fc	 add	 esi, -4			; fffffffcH
  0004c	8b c8		 mov	 ecx, eax
  0004e	3b de		 cmp	 ebx, esi
  00050	72 ee		 jb	 SHORT $LL2@Partition_
$LN107@Partition_:
  00052	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
$LN82@Partition_:

; 4048 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00055	3b fb		 cmp	 edi, ebx
  00057	73 17		 jae	 SHORT $LN5@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00059	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@Partition_:
  00060	39 0f		 cmp	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4048 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00062	7c 09		 jl	 SHORT $LN108@Partition_
  00064	7f 07		 jg	 SHORT $LN108@Partition_

; 4049 :         ++_Plast;

  00066	83 c7 04	 add	 edi, 4
  00069	3b fb		 cmp	 edi, ebx
  0006b	72 f3		 jb	 SHORT $LL4@Partition_
$LN108@Partition_:
  0006d	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
$LN5@Partition_:

; 4050 :     }
; 4051 : 
; 4052 :     _RanIt _Gfirst = _Plast;

  00070	8b d7		 mov	 edx, edi

; 4053 :     _RanIt _Glast  = _Pfirst;

  00072	8b de		 mov	 ebx, esi
$LN113@Partition_:

; 4054 : 
; 4055 :     for (;;) { // partition
; 4056 :         for (; _Gfirst < _Last; ++_Gfirst) {

  00074	89 5d f8	 mov	 DWORD PTR __Glast$1$[ebp], ebx
$LN112@Partition_:
  00077	89 55 f4	 mov	 DWORD PTR __Gfirst$1$[ebp], edx
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL6@Partition_:
  00080	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  00083	73 32		 jae	 SHORT $LN86@Partition_
  00085	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
$LL11@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00088	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0008a	39 0e		 cmp	 DWORD PTR [esi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4057 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  0008c	7c 19		 jl	 SHORT $LN9@Partition_

; 4058 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  0008e	7f 1e		 jg	 SHORT $LN109@Partition_

; 4059 :                 break;
; 4060 :             } else if (_Plast != _Gfirst) {

  00090	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00093	89 45 f4	 mov	 DWORD PTR tv557[ebp], eax
  00096	3b fa		 cmp	 edi, edx
  00098	74 0b		 je	 SHORT $LN19@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 106  :     _Ty _Tmp = _STD move(_Left);

  0009a	8b 07		 mov	 eax, DWORD PTR [edi]

; 107  :     _Left    = _STD move(_Right);

  0009c	89 0f		 mov	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4062 :                 ++_Plast;

  0009e	8b 7d f4	 mov	 edi, DWORD PTR tv557[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 108  :     _Right   = _STD move(_Tmp);

  000a1	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4063 :             } else {

  000a3	eb 02		 jmp	 SHORT $LN9@Partition_
$LN19@Partition_:

; 4064 :                 ++_Plast;

  000a5	8b f8		 mov	 edi, eax
$LN9@Partition_:

; 4054 : 
; 4055 :     for (;;) { // partition
; 4056 :         for (; _Gfirst < _Last; ++_Gfirst) {

  000a7	83 c2 04	 add	 edx, 4
  000aa	3b d3		 cmp	 edx, ebx
  000ac	72 da		 jb	 SHORT $LL11@Partition_
$LN109@Partition_:
  000ae	8b 5d f8	 mov	 ebx, DWORD PTR __Glast$1$[ebp]
  000b1	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
  000b4	89 55 f4	 mov	 DWORD PTR __Gfirst$1$[ebp], edx
$LN86@Partition_:

; 4068 :         for (; _First < _Glast; --_Glast) {

  000b7	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  000ba	3b d8		 cmp	 ebx, eax
  000bc	76 34		 jbe	 SHORT $LN111@Partition_
  000be	8d 4b fc	 lea	 ecx, DWORD PTR [ebx-4]
  000c1	8b f8		 mov	 edi, eax
$LL14@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000c3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c5	3b 06		 cmp	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4069 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  000c7	7c 11		 jl	 SHORT $LN12@Partition_

; 4070 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  000c9	7f 19		 jg	 SHORT $LN110@Partition_

; 4071 :                 break;
; 4072 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  000cb	83 ee 04	 sub	 esi, 4
  000ce	3b f1		 cmp	 esi, ecx
  000d0	74 08		 je	 SHORT $LN12@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 106  :     _Ty _Tmp = _STD move(_Left);

  000d2	8b 06		 mov	 eax, DWORD PTR [esi]

; 107  :     _Left    = _STD move(_Right);

  000d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d6	89 16		 mov	 DWORD PTR [esi], edx

; 108  :     _Right   = _STD move(_Tmp);

  000d8	89 01		 mov	 DWORD PTR [ecx], eax
$LN12@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4068 :         for (; _First < _Glast; --_Glast) {

  000da	83 eb 04	 sub	 ebx, 4
  000dd	83 e9 04	 sub	 ecx, 4
  000e0	3b fb		 cmp	 edi, ebx
  000e2	72 df		 jb	 SHORT $LL14@Partition_
$LN110@Partition_:
  000e4	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 4073 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 4074 :             }
; 4075 :         }
; 4076 : 
; 4077 :         if (_Glast == _First && _Gfirst == _Last) {

  000e7	3b d8		 cmp	 ebx, eax
  000e9	8b 55 f4	 mov	 edx, DWORD PTR __Gfirst$1$[ebp]
  000ec	8b 7d fc	 mov	 edi, DWORD PTR __Plast$1$[ebp]
  000ef	89 5d f8	 mov	 DWORD PTR __Glast$1$[ebp], ebx
$LN111@Partition_:
  000f2	75 2a		 jne	 SHORT $LN27@Partition_
  000f4	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  000f7	74 73		 je	 SHORT $LN88@Partition_

; 4079 :         }
; 4080 : 
; 4081 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 4082 :             if (_Plast != _Gfirst) {

  000f9	3b fa		 cmp	 edi, edx
  000fb	74 08		 je	 SHORT $LN63@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 106  :     _Ty _Tmp = _STD move(_Left);

  000fd	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 107  :     _Left    = _STD move(_Right);

  000ff	8b 07		 mov	 eax, DWORD PTR [edi]
  00101	89 06		 mov	 DWORD PTR [esi], eax

; 108  :     _Right   = _STD move(_Tmp);

  00103	89 0f		 mov	 DWORD PTR [edi], ecx
$LN63@Partition_:

; 106  :     _Ty _Tmp = _STD move(_Left);

  00105	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4086 :             ++_Plast;

  00107	83 c7 04	 add	 edi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4088 :             ++_Pfirst;

  0010e	83 c6 04	 add	 esi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 108  :     _Right   = _STD move(_Tmp);

  00111	89 0a		 mov	 DWORD PTR [edx], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4089 :             ++_Gfirst;

  00113	83 c2 04	 add	 edx, 4
  00116	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
  00119	e9 59 ff ff ff	 jmp	 $LN112@Partition_
$LN27@Partition_:

; 4090 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  0011e	83 c3 fc	 add	 ebx, -4			; fffffffcH
  00121	89 5d f8	 mov	 DWORD PTR __Glast$1$[ebp], ebx
  00124	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  00127	75 33		 jne	 SHORT $LN30@Partition_

; 4091 :             if (--_Glast != --_Pfirst) {

  00129	83 ee 04	 sub	 esi, 4
  0012c	3b de		 cmp	 ebx, esi
  0012e	74 19		 je	 SHORT $LN98@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00130	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4095 :             _STD iter_swap(_Pfirst, --_Plast);

  00132	83 ef 04	 sub	 edi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 106  :     _Ty _Tmp = _STD move(_Left);

  00135	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 107  :     _Left    = _STD move(_Right);

  00137	89 03		 mov	 DWORD PTR [ebx], eax

; 108  :     _Right   = _STD move(_Tmp);

  00139	89 0e		 mov	 DWORD PTR [esi], ecx

; 107  :     _Left    = _STD move(_Right);

  0013b	8b 07		 mov	 eax, DWORD PTR [edi]
  0013d	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4095 :             _STD iter_swap(_Pfirst, --_Plast);

  0013f	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 108  :     _Right   = _STD move(_Tmp);

  00142	89 0f		 mov	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4096 :         } else {

  00144	e9 37 ff ff ff	 jmp	 $LL6@Partition_
$LN98@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 108  :     _Right   = _STD move(_Tmp);

  00149	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4095 :             _STD iter_swap(_Pfirst, --_Plast);

  0014b	83 ef 04	 sub	 edi, 4
  0014e	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00151	8b 07		 mov	 eax, DWORD PTR [edi]
  00153	89 06		 mov	 DWORD PTR [esi], eax

; 108  :     _Right   = _STD move(_Tmp);

  00155	89 0f		 mov	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4096 :         } else {

  00157	e9 24 ff ff ff	 jmp	 $LL6@Partition_
$LN30@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 106  :     _Ty _Tmp = _STD move(_Left);

  0015c	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 107  :     _Left    = _STD move(_Right);

  0015e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00160	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4098 :             ++_Gfirst;

  00162	83 c2 04	 add	 edx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 108  :     _Right   = _STD move(_Tmp);

  00165	89 0b		 mov	 DWORD PTR [ebx], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4100 :     }

  00167	e9 08 ff ff ff	 jmp	 $LN113@Partition_
$LN88@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0016c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0016f	89 78 04	 mov	 DWORD PTR [eax+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4078 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00172	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00173	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4078 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx

; 4101 : }

  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z PROC		; std::_Refancy<int *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ENDP		; std::_Refancy<int *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4120 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
tv656 = -8						; size = 4
__Bottom$1$ = -4					; size = 4
__Val$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Val$2 = 12						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z PROC ; std::_Sort_unchecked<int *,std::less<void> >, COMDAT

; 4104 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 4105 :     // order [_First, _Last), using _Pred
; 4106 :     for (;;) {
; 4107 :         if (_Last - _First <= _ISORT_MAX) { // small

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000a	8b c3		 mov	 eax, ebx
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00010	2b c6		 sub	 eax, esi
  00012	83 e0 fc	 and	 eax, -4			; fffffffcH
  00015	57		 push	 edi
  00016	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0001b	7e 71		 jle	 SHORT $LN67@Sort_unche
  0001d	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00020	8b 7d 10	 mov	 edi, DWORD PTR __Ideal$[ebp]
$LL2@Sort_unche:

; 4108 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 4109 :             return;
; 4110 :         }
; 4111 : 
; 4112 :         if (_Ideal <= 0) { // heap sort if too many divisions

  00023	85 ff		 test	 edi, edi
  00025	0f 8e 97 00 00
	00		 jle	 $LN68@Sort_unche

; 4113 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 4114 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 4115 :             return;
; 4116 :         }
; 4117 : 
; 4118 :         // divide and conquer by quicksort
; 4119 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  0002b	51		 push	 ecx
  0002c	53		 push	 ebx
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00030	56		 push	 esi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >

; 4120 : 
; 4121 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 4122 : 
; 4123 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  00037	8b 55 f8	 mov	 edx, DWORD PTR __Mid$1[ebp+4]
  0003a	8b c7		 mov	 eax, edi
  0003c	c1 f8 02	 sar	 eax, 2
  0003f	8b cb		 mov	 ecx, ebx
  00041	d1 ff		 sar	 edi, 1
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	03 f8		 add	 edi, eax
  00048	2b ca		 sub	 ecx, edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0004d	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00050	2b c6		 sub	 eax, esi
  00052	83 e0 fc	 and	 eax, -4			; fffffffcH
  00055	3b c1		 cmp	 eax, ecx
  00057	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  0005a	50		 push	 eax
  0005b	57		 push	 edi
  0005c	7d 0f		 jge	 SHORT $LN7@Sort_unche

; 4124 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  0005e	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >

; 4125 :             _First = _Mid.second;

  00068	8b 75 f8	 mov	 esi, DWORD PTR __Mid$1[ebp+4]

; 4126 :         } else { // loop on first half

  0006b	eb 0d		 jmp	 SHORT $LN91@Sort_unche
$LN7@Sort_unche:

; 4127 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  0006d	53		 push	 ebx
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >

; 4128 :             _Last = _Mid.first;

  00074	8b 5d f4	 mov	 ebx, DWORD PTR __Mid$1[ebp]
  00077	89 5d 0c	 mov	 DWORD PTR __Last$[ebp], ebx
$LN91@Sort_unche:

; 4105 :     // order [_First, _Last), using _Pred
; 4106 :     for (;;) {
; 4107 :         if (_Last - _First <= _ISORT_MAX) { // small

  0007a	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  0007d	8b c3		 mov	 eax, ebx
  0007f	2b c6		 sub	 eax, esi
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	83 e0 fc	 and	 eax, -4			; fffffffcH
  00087	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0008c	7f 95		 jg	 SHORT $LL2@Sort_unche
$LN67@Sort_unche:

; 3981 :     if (_First != _Last) {

  0008e	3b f3		 cmp	 esi, ebx
  00090	0f 84 26 01 00
	00		 je	 $LN51@Sort_unche

; 3982 :         for (_BidIt _Next = _First; ++_Next != _Last;) { // order next element

  00096	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00099	3b fb		 cmp	 edi, ebx
  0009b	0f 84 1b 01 00
	00		 je	 $LN51@Sort_unche
$LL11@Sort_unche:

; 3983 :             _BidIt _Next1              = _Next;
; 3984 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Next);

  000a1	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000a3	8b d7		 mov	 edx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000a5	3b 1e		 cmp	 ebx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3986 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  000a7	0f 8d e3 00 00
	00		 jge	 $LN18@Sort_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4440 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  000ad	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000b0	50		 push	 eax
  000b1	57		 push	 edi
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3988 :                 *_First = _STD move(_Val);

  000bb	89 1e		 mov	 DWORD PTR [esi], ebx

; 3989 :             } else { // look for insertion point after first

  000bd	e9 ee 00 00 00	 jmp	 $LN19@Sort_unche
$LN68@Sort_unche:

; 3419 :     _Diff _Bottom = _Last - _First;

  000c2	2b de		 sub	 ebx, esi
  000c4	8b c3		 mov	 eax, ebx
  000c6	89 5d 0c	 mov	 DWORD PTR __Last$[ebp], ebx
  000c9	c1 f8 02	 sar	 eax, 2

; 3420 :     for (_Diff _Hole = _Bottom >> 1; 0 < _Hole;) { // shift for codegen

  000cc	8b f8		 mov	 edi, eax
  000ce	89 45 fc	 mov	 DWORD PTR __Bottom$1$[ebp], eax
  000d1	d1 ff		 sar	 edi, 1
  000d3	85 ff		 test	 edi, edi
  000d5	7e 79		 jle	 SHORT $LN31@Sort_unche
  000d7	48		 dec	 eax
  000d8	8b d8		 mov	 ebx, eax
  000da	89 45 f8	 mov	 DWORD PTR tv656[ebp], eax
  000dd	d1 fb		 sar	 ebx, 1
  000df	90		 npad	 1
$LL30@Sort_unche:

; 3421 :         // reheap top half, bottom to top
; 3422 :         --_Hole;
; 3423 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  000e0	8b 44 be fc	 mov	 eax, DWORD PTR [esi+edi*4-4]
  000e4	4f		 dec	 edi
  000e5	89 45 08	 mov	 DWORD PTR __Val$1$[ebp], eax

; 3424 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  000e8	8b d7		 mov	 edx, edi

; 3359 :     _Diff _Idx       = _Hole;

  000ea	8b cf		 mov	 ecx, edi

; 3360 : 
; 3361 :     // Check whether _Idx can have a child before calculating that child's index, since
; 3362 :     // calculating the child's index can trigger integer overflows
; 3363 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 3364 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  000ec	3b fb		 cmp	 edi, ebx
  000ee	7d 1e		 jge	 SHORT $LN36@Sort_unche
$LL35@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000f0	8b 44 ce 08	 mov	 eax, DWORD PTR [esi+ecx*8+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3365 :         _Idx = 2 * _Idx + 2;

  000f4	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000fb	3b 44 8e fc	 cmp	 eax, DWORD PTR [esi+ecx*4-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3366 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  000ff	7d 01		 jge	 SHORT $LN37@Sort_unche

; 3367 :             --_Idx;

  00101	49		 dec	 ecx
$LN37@Sort_unche:

; 3368 :         }
; 3369 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00102	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  00105	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 3370 :         _Hole             = _Idx;

  00108	8b d1		 mov	 edx, ecx
  0010a	3b cb		 cmp	 ecx, ebx
  0010c	7c e2		 jl	 SHORT $LL35@Sort_unche
$LN36@Sort_unche:

; 3371 :     }
; 3372 : 
; 3373 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  0010e	3b cb		 cmp	 ecx, ebx
  00110	75 11		 jne	 SHORT $LN38@Sort_unche
  00112	8b 45 fc	 mov	 eax, DWORD PTR __Bottom$1$[ebp]
  00115	a8 01		 test	 al, 1
  00117	75 0a		 jne	 SHORT $LN38@Sort_unche

; 3374 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  00119	8b 44 86 fc	 mov	 eax, DWORD PTR [esi+eax*4-4]
  0011d	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 3375 :         _Hole             = _Bottom - 1;

  00120	8b 55 f8	 mov	 edx, DWORD PTR tv656[ebp]
$LN38@Sort_unche:

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00123	3b fa		 cmp	 edi, edx
  00125	7d 16		 jge	 SHORT $LN90@Sort_unche
$LL45@Sort_unche:

; 3320 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00127	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  0012a	d1 f8		 sar	 eax, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0012c	8b 0c 86	 mov	 ecx, DWORD PTR [esi+eax*4]
  0012f	3b 4d 08	 cmp	 ecx, DWORD PTR __Val$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3321 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00132	7d 09		 jge	 SHORT $LN90@Sort_unche

; 3322 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 3323 :         // move _Hole up to parent
; 3324 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00134	89 0c 96	 mov	 DWORD PTR [esi+edx*4], ecx

; 3325 :         _Hole             = _Idx;

  00137	8b d0		 mov	 edx, eax
  00139	3b f8		 cmp	 edi, eax
  0013b	7c ea		 jl	 SHORT $LL45@Sort_unche
$LN90@Sort_unche:

; 3326 :     }
; 3327 : 
; 3328 :     *(_First + _Hole) = _STD move(_Val); // drop _Val into final hole

  0013d	8b 45 08	 mov	 eax, DWORD PTR __Val$1$[ebp]
  00140	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 3420 :     for (_Diff _Hole = _Bottom >> 1; 0 < _Hole;) { // shift for codegen

  00143	85 ff		 test	 edi, edi
  00145	7f 99		 jg	 SHORT $LL30@Sort_unche
  00147	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0014a	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  0014d	8b 45 fc	 mov	 eax, DWORD PTR __Bottom$1$[ebp]
$LN31@Sort_unche:

; 3509 :     for (; 2 <= _Last - _First; --_Last) {

  00150	83 f8 02	 cmp	 eax, 2
  00153	7c 67		 jl	 SHORT $LN51@Sort_unche
$LL52@Sort_unche:

; 3396 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00155	8b 44 1e fc	 mov	 eax, DWORD PTR [esi+ebx-4]
  00159	89 45 0c	 mov	 DWORD PTR __Val$2[ebp], eax

; 3386 :     *_Dest      = _STD move(*_First);

  0015c	8b 06		 mov	 eax, DWORD PTR [esi]
  0015e	89 44 1e fc	 mov	 DWORD PTR [esi+ebx-4], eax

; 3387 :     using _Diff = _Iter_diff_t<_RanIt>;
; 3388 :     _Pop_heap_hole_by_index(_First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD move(_Val), _Pred);

  00162	8d 45 0c	 lea	 eax, DWORD PTR __Val$2[ebp]
  00165	51		 push	 ecx
  00166	50		 push	 eax
  00167	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  0016a	c1 f8 02	 sar	 eax, 2
  0016d	50		 push	 eax
  0016e	6a 00		 push	 0
  00170	56		 push	 esi
  00171	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >

; 3509 :     for (; 2 <= _Last - _First; --_Last) {

  00176	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00179	83 eb 04	 sub	 ebx, 4
  0017c	8b c3		 mov	 eax, ebx

; 3388 :     _Pop_heap_hole_by_index(_First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD move(_Val), _Pred);

  0017e	83 c4 14	 add	 esp, 20			; 00000014H

; 3509 :     for (; 2 <= _Last - _First; --_Last) {

  00181	83 e0 fc	 and	 eax, -4			; fffffffcH
  00184	83 f8 08	 cmp	 eax, 8
  00187	7d cc		 jge	 SHORT $LL52@Sort_unche

; 4129 :         }
; 4130 :     }
; 4131 : }

  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
$LN18@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00190	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3990 :                 for (_BidIt _First1 = _Next1; _DEBUG_LT_PRED(_Pred, _Val, *--_First1); _Next1 = _First1) {

  00193	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00196	3b d9		 cmp	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3990 :                 for (_BidIt _First1 = _Next1; _DEBUG_LT_PRED(_Pred, _Val, *--_First1); _Next1 = _First1) {

  00198	7d 14		 jge	 SHORT $LN15@Sort_unche
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL16@Sort_unche:

; 3991 :                     *_Next1 = _STD move(*_First1); // move hole down

  001a0	89 0a		 mov	 DWORD PTR [edx], ecx
  001a2	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  001a4	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3990 :                 for (_BidIt _First1 = _Next1; _DEBUG_LT_PRED(_Pred, _Val, *--_First1); _Next1 = _First1) {

  001a7	83 e8 04	 sub	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  001aa	3b d9		 cmp	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3990 :                 for (_BidIt _First1 = _Next1; _DEBUG_LT_PRED(_Pred, _Val, *--_First1); _Next1 = _First1) {

  001ac	7c f2		 jl	 SHORT $LL16@Sort_unche
$LN15@Sort_unche:

; 3992 :                 }
; 3993 : 
; 3994 :                 *_Next1 = _STD move(_Val); // insert element in hole

  001ae	89 1a		 mov	 DWORD PTR [edx], ebx
$LN19@Sort_unche:

; 3982 :         for (_BidIt _Next = _First; ++_Next != _Last;) { // order next element

  001b0	83 c7 04	 add	 edi, 4
  001b3	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  001b6	0f 85 e5 fe ff
	ff		 jne	 $LL11@Sort_unche
$LN51@Sort_unche:
  001bc	5f		 pop	 edi

; 4129 :         }
; 4130 :     }
; 4131 : }

  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,std::allocator<int> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);
; 1652 :     const auto _ULast = _Get_unwrapped(_Last);
; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
tv436 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv435 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 be 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00045	8b c7		 mov	 eax, edi
  00047	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00049	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0004c	3b c7		 cmp	 eax, edi
  0004e	0f 42 c7	 cmovb	 eax, edi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 8f 00 00
	00		 ja	 $LN40@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005c	c1 e0 02	 shl	 eax, 2

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00060	89 45 f4	 mov	 DWORD PTR tv436[ebp], eax

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00063	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0006d	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00073	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00076	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	3b da		 cmp	 ebx, edx
  00084	75 07		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00086	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00089	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0008b	eb 17		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008d	56		 push	 esi
  0008e	57		 push	 edi
  0008f	53		 push	 ebx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009b	8b 5d fc	 mov	 ebx, DWORD PTR tv435[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009e	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000a4	56		 push	 esi
  000a5	50		 push	 eax
  000a6	52		 push	 edx
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000b2	85 c9		 test	 ecx, ecx
  000b4	74 12		 je	 SHORT $LN33@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b9	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	83 e0 fc	 and	 eax, -4			; fffffffcH
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c5	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000cb	8b c3		 mov	 eax, ebx

; 1680 :         _Myfirst = _Newvec;

  000cd	89 3e		 mov	 DWORD PTR [esi], edi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000cf	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  000d2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv436[ebp]
  000d8	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000da	5f		 pop	 edi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000db	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx

; 767  :     }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000eb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f0	cc		 int	 3
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z PROC ; std::_Const_cast<std::pair<float,long> const >, COMDAT

; 282  : auto _Const_cast(_Ty* _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :     return const_cast<remove_const_t<_Ty>*>(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 284  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ENDP ; std::_Const_cast<std::pair<float,long> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z PROC ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >, COMDAT

; 3557 : _NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 1724 :         return _Last - _First; // assume the iterator will do debug checking

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3557 : _NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {

  00006	57		 push	 edi

; 3538 :     auto _UFirst                = _Get_unwrapped(_First);

  00007	8b 7d 0c	 mov	 edi, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 1724 :         return _Last - _First; // assume the iterator will do debug checking

  0000a	2b cf		 sub	 ecx, edi
  0000c	c1 f9 03	 sar	 ecx, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3541 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 3f		 jle	 SHORT $LN5@upper_boun
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00013	53		 push	 ebx
  00014	8b 5d 14	 mov	 ebx, DWORD PTR __Val$[ebp]
  00017	56		 push	 esi
  00018	f3 0f 10 0b	 movss	 xmm1, DWORD PTR [ebx]
  0001c	0f 1f 40 00	 npad	 4
$LL4@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3542 :         _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

  00020	8b d1		 mov	 edx, ecx
  00022	d1 ea		 shr	 edx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00024	f3 0f 10 04 d7	 movss	 xmm0, DWORD PTR [edi+edx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 1644 :         _Where += _Off;

  00029	8d 34 d7	 lea	 esi, DWORD PTR [edi+edx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0002c	0f 2f c1	 comiss	 xmm0, xmm1
  0002f	77 19		 ja	 SHORT $LN28@upper_boun
  00031	0f 2f c8	 comiss	 xmm1, xmm0
  00034	77 08		 ja	 SHORT $LN6@upper_boun
  00036	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00039	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0003c	7c 0c		 jl	 SHORT $LN28@upper_boun
$LN6@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3548 :             _Count -= _Count2 + 1;

  0003e	83 c8 ff	 or	 eax, -1
  00041	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00044	2b c2		 sub	 eax, edx
  00046	03 c8		 add	 ecx, eax
  00048	eb 02		 jmp	 SHORT $LN7@upper_boun
$LN28@upper_boun:

; 3543 :         const auto _UMid             = _STD next(_UFirst, _Count2);
; 3544 :         if (_Pred(_Val, *_UMid)) {
; 3545 :             _Count = _Count2;

  0004a	8b ca		 mov	 ecx, edx
$LN7@upper_boun:

; 3541 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0004c	85 c9		 test	 ecx, ecx
  0004e	7f d0		 jg	 SHORT $LL4@upper_boun
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
$LN5@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3553 :     return _First;

  00058	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  0005b	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 3553 :     return _First;

  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 3558 :     // find first element that _Val is before, using operator<
; 3559 :     return _STD upper_bound(_First, _Last, _Val, less<>());

  00060	8b c1		 mov	 eax, ecx
  00062	5f		 pop	 edi

; 3560 : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ENDP ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
_pTerrain$ = -4720					; size = 4
_akDstVertex$ = -4716					; size = 4
_this$GSCopy$1$ = -4712					; size = 4
_fScreenHalfWidth$1$ = -4708				; size = 4
_fScreenHalfHeight$1$ = -4704				; size = 4
_ucTerrainNum$ = -4696					; size = 1
tv511 = -4696						; size = 4
_m4Frustum$ = -4692					; size = 64
_akTransVertex$ = -4628					; size = 4624
__$ArrayPad$ = -4					; size = 4
_rkTPRS$ = 8						; size = 4
_patchnum$ = 12						; size = 4
_wPrimitiveCount$ = 16					; size = 2
_ePrimitiveType$ = 20					; size = 4
?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone, COMDAT
; _this$ = ecx

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 70 12 00 00	 mov	 eax, 4720		; 00001270H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR _patchnum$[ebp]
  0001a	53		 push	 ebx
  0001b	8b d9		 mov	 ebx, ecx
  0001d	56		 push	 esi

; 271  : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone");
; 272  : 
; 273  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  0001e	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00025	89 9d 98 ed ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  0002b	2b d0		 sub	 edx, eax
  0002d	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]

; 274  : 
; 275  : 	if (!pTerrainPatchProxy->isUsed())

  00030	80 7c 90 04 00	 cmp	 BYTE PTR [eax+edx*4+4], 0
  00035	57		 push	 edi
  00036	8b 7d 08	 mov	 edi, DWORD PTR _rkTPRS$[ebp]
  00039	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]
  0003c	0f 84 a2 01 00
	00		 je	 $LN1@SoftwareTr

; 276  : 		return;
; 277  : 
; 278  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();
; 279  : 	if (sPatchNum < 0)

  00042	66 83 7e 06 00	 cmp	 WORD PTR [esi+6], 0
  00047	0f 8c 97 01 00
	00		 jl	 $LN1@SoftwareTr

; 280  : 		return;
; 281  : 
; 282  : 	BYTE ucTerrainNum = pTerrainPatchProxy->GetTerrainNum();

  0004d	8a 46 08	 mov	 al, BYTE PTR [esi+8]
  00050	88 85 a8 ed ff
	ff		 mov	 BYTE PTR _ucTerrainNum$[ebp], al

; 283  : 	if (0xFF == ucTerrainNum)

  00056	3c ff		 cmp	 al, 255			; 000000ffH
  00058	0f 84 86 01 00
	00		 je	 $LN1@SoftwareTr

; 284  : 		return;
; 285  : 
; 286  : 	CTerrain * pTerrain;
; 287  : 	if (!GetTerrainPointer(ucTerrainNum, &pTerrain))

  0005e	8d 85 90 ed ff
	ff		 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00064	50		 push	 eax
  00065	ff b5 a8 ed ff
	ff		 push	 DWORD PTR _ucTerrainNum$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00070	85 c0		 test	 eax, eax
  00072	0f 84 6c 01 00
	00		 je	 $LN1@SoftwareTr

; 288  : 		return;
; 289  : 
; 290  : 	WORD wCoordX, wCoordY;
; 291  : 	pTerrain->GetCoordinate(&wCoordX, &wCoordY);
; 292  : 
; 293  : 	SoftwareTransformPatch_SSourceVertex* akSrcVertex=pTerrainPatchProxy->SoftwareTransformPatch_GetTerrainVertexDataPtr();

  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?SoftwareTransformPatch_GetTerrainVertexDataPtr@CTerrainPatchProxy@@QAEPAUSoftwareTransformPatch_SSourceVertex@@XZ ; CTerrainPatchProxy::SoftwareTransformPatch_GetTerrainVertexDataPtr

; 294  : 	if (!akSrcVertex)

  0007f	85 c0		 test	 eax, eax
  00081	0f 84 5d 01 00
	00		 je	 $LN1@SoftwareTr

; 295  : 		return;
; 296  : 
; 297  : 	float fScreenHalfWidth=rkTPRS.m_fScreenHalfWidth;

  00087	f3 0f 10 87 7c
	01 00 00	 movss	 xmm0, DWORD PTR [edi+380]
  0008f	8b d8		 mov	 ebx, eax
  00091	f3 0f 11 85 9c
	ed ff ff	 movss	 DWORD PTR _fScreenHalfWidth$1$[ebp], xmm0

; 298  : 	float fScreenHalfHeight=rkTPRS.m_fScreenHalfHeight;

  00099	f3 0f 10 87 80
	01 00 00	 movss	 xmm0, DWORD PTR [edi+384]
  000a1	f3 0f 11 85 a0
	ed ff ff	 movss	 DWORD PTR _fScreenHalfHeight$1$[ebp], xmm0

; 299  : 
; 300  : 	D3DXMATRIX m4Frustum=rkTPRS.m_m4Frustum;

  000a9	0f 10 47 40	 movups	 xmm0, XMMWORD PTR [edi+64]

; 301  : 
; 302  : 	SoftwareTransformPatch_STVertex akTransVertex[CTerrainPatch::TERRAIN_VERTEX_COUNT];
; 303  : 
; 304  : 	D3DXVECTOR4* akPosition=(D3DXVECTOR4*)akTransVertex;

  000ad	c7 85 a8 ed ff
	ff 21 01 00 00	 mov	 DWORD PTR tv511[ebp], 289 ; 00000121H
  000b7	0f 11 85 ac ed
	ff ff		 movups	 XMMWORD PTR _m4Frustum$[ebp], xmm0
  000be	0f 10 47 50	 movups	 xmm0, XMMWORD PTR [edi+80]
  000c2	0f 11 85 bc ed
	ff ff		 movups	 XMMWORD PTR _m4Frustum$[ebp+16], xmm0
  000c9	0f 10 47 60	 movups	 xmm0, XMMWORD PTR [edi+96]
  000cd	0f 11 85 cc ed
	ff ff		 movups	 XMMWORD PTR _m4Frustum$[ebp+32], xmm0
  000d4	0f 10 47 70	 movups	 xmm0, XMMWORD PTR [edi+112]
  000d8	8d bd f4 ed ff
	ff		 lea	 edi, DWORD PTR _akTransVertex$[ebp+8]
  000de	0f 11 85 dc ed
	ff ff		 movups	 XMMWORD PTR _m4Frustum$[ebp+48], xmm0
$LL4@SoftwareTr:

; 305  : 	D3DXVECTOR4* pkPosition;
; 306  : 	for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)
; 307  : 	{
; 308  : 		pkPosition=akPosition+uIndex;
; 309  : 		D3DXVec3Transform(pkPosition, &akSrcVertex[uIndex].kPosition, &m4Frustum);

  000e5	8d 85 ac ed ff
	ff		 lea	 eax, DWORD PTR _m4Frustum$[ebp]
  000eb	50		 push	 eax
  000ec	53		 push	 ebx
  000ed	8d 77 f8	 lea	 esi, DWORD PTR [edi-8]
  000f0	56		 push	 esi
  000f1	e8 00 00 00 00	 call	 _D3DXVec3Transform@12

; 310  : 		pkPosition->w=1.0f/pkPosition->w;

  000f6	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  000fe	83 c3 1c	 add	 ebx, 28			; 0000001cH
  00101	0f 28 ca	 movaps	 xmm1, xmm2
  00104	f3 0f 5e 4f 04	 divss	 xmm1, DWORD PTR [edi+4]

; 311  : 		pkPosition->z*=pkPosition->w;

  00109	0f 28 c1	 movaps	 xmm0, xmm1
  0010c	f3 0f 11 4f 04	 movss	 DWORD PTR [edi+4], xmm1
  00111	f3 0f 59 07	 mulss	 xmm0, DWORD PTR [edi]
  00115	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 312  : 		pkPosition->y=(pkPosition->y*pkPosition->w-1.0f)*fScreenHalfHeight;

  00119	f3 0f 10 47 fc	 movss	 xmm0, DWORD PTR [edi-4]
  0011e	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 313  : 		pkPosition->x=(pkPosition->x*pkPosition->w+1.0f)*fScreenHalfWidth;

  00122	f3 0f 59 0e	 mulss	 xmm1, DWORD PTR [esi]
  00126	f3 0f 5c c2	 subss	 xmm0, xmm2
  0012a	f3 0f 58 ca	 addss	 xmm1, xmm2
  0012e	f3 0f 59 85 a0
	ed ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfHeight$1$[ebp]
  00136	f3 0f 59 8d 9c
	ed ff ff	 mulss	 xmm1, DWORD PTR _fScreenHalfWidth$1$[ebp]
  0013e	f3 0f 11 47 fc	 movss	 DWORD PTR [edi-4], xmm0
  00143	83 c7 10	 add	 edi, 16			; 00000010H
  00146	83 ad a8 ed ff
	ff 01		 sub	 DWORD PTR tv511[ebp], 1
  0014d	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1
  00151	75 92		 jne	 SHORT $LL4@SoftwareTr

; 314  : 	}
; 315  : 
; 316  : 
; 317  : 	IDirect3DVertexBuffer8* pkVB=m_kSTPD.m_pkVBNone[m_kSTPD.m_dwNonePos++];

  00153	8b 9d 98 ed ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  00159	8b 83 04 0a 00
	00		 mov	 eax, DWORD PTR [ebx+2564]
  0015f	8b b4 83 e0 09
	00 00		 mov	 esi, DWORD PTR [ebx+eax*4+2528]
  00166	40		 inc	 eax

; 318  : 	m_kSTPD.m_dwNonePos%=SoftwareTransformPatch_SData::NONE_VB_NUM;

  00167	83 e0 07	 and	 eax, 7
  0016a	89 83 04 0a 00
	00		 mov	 DWORD PTR [ebx+2564], eax

; 319  : 	if (!pkVB)

  00170	85 f6		 test	 esi, esi
  00172	74 70		 je	 SHORT $LN1@SoftwareTr

; 320  : 		return;
; 321  : 
; 322  : 	DWORD dwVBSize=sizeof(SoftwareTransformPatch_STVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT;
; 323  : 	SoftwareTransformPatch_STVertex* akDstVertex;
; 324  : 	if (FAILED(

  00174	8b 06		 mov	 eax, DWORD PTR [esi]
  00176	8d 8d 94 ed ff
	ff		 lea	 ecx, DWORD PTR _akDstVertex$[ebp]
  0017c	68 00 20 00 00	 push	 8192			; 00002000H
  00181	51		 push	 ecx
  00182	68 10 12 00 00	 push	 4624			; 00001210H
  00187	6a 00		 push	 0
  00189	56		 push	 esi
  0018a	ff 50 2c	 call	 DWORD PTR [eax+44]
  0018d	85 c0		 test	 eax, eax
  0018f	78 53		 js	 SHORT $LN1@SoftwareTr

; 325  : 		pkVB->Lock(0, dwVBSize, (BYTE**)&akDstVertex, D3DLOCK_DISCARD)
; 326  : 	)) return;
; 327  : 
; 328  : 	memcpy(akDstVertex, akTransVertex, dwVBSize);

  00191	68 10 12 00 00	 push	 4624			; 00001210H
  00196	8d 85 ec ed ff
	ff		 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  0019c	50		 push	 eax
  0019d	ff b5 94 ed ff
	ff		 push	 DWORD PTR _akDstVertex$[ebp]
  001a3	e8 00 00 00 00	 call	 _memcpy

; 329  : 
; 330  : 	pkVB->Unlock();

  001a8	8b 06		 mov	 eax, DWORD PTR [esi]
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ad	56		 push	 esi
  001ae	ff 50 30	 call	 DWORD PTR [eax+48]

; 331  : 
; 332  : 	STATEMANAGER.SetStreamSource(0, pkVB, sizeof(SoftwareTransformPatch_STVertex));

  001b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b7	6a 10		 push	 16			; 00000010H
  001b9	56		 push	 esi
  001ba	6a 00		 push	 0
  001bc	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 333  : 	STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  001c1	0f b7 75 10	 movzx	 esi, WORD PTR _wPrimitiveCount$[ebp]
  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001cb	56		 push	 esi
  001cc	6a 00		 push	 0
  001ce	ff b3 a0 09 00
	00		 push	 DWORD PTR [ebx+2464]
  001d4	6a 00		 push	 0
  001d6	ff 75 14	 push	 DWORD PTR _ePrimitiveType$[ebp]
  001d9	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 334  : 	ms_faceCount += wPrimitiveCount;

  001de	01 35 00 00 00
	00		 add	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, esi ; CGraphicBase::ms_faceCount
$LN1@SoftwareTr:

; 335  : }

  001e4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	33 cd		 xor	 ecx, ebp
  001eb	5b		 pop	 ebx
  001ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c2 10 00	 ret	 16			; 00000010H
?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\AreaTerrain.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\AreaTerrain.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\AreaTerrain.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\PRTerrainLib\Terrain.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\PRTerrainLib\Terrain.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\Client\PRTerrainLib\Terrain.h
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z
_TEXT	SEGMENT
_iPrevRenderedSplatNum$1$ = -16224			; size = 4
tv801 = -16220						; size = 4
_pTerrain$1$ = -16216					; size = 4
_sPatchNum$1$ = -16212					; size = 4
_rkTPRS$GSCopy$1$ = -16208				; size = 4
_isDynamicShadow$ = -16204				; size = 1
$T1 = -16204						; size = 4
_pTerrain$ = -16200					; size = 4
tv833 = -16196						; size = 4
_ucTerrainNum$ = -16196					; size = 1
_isFirst$1$ = -16189					; size = 1
_akTransVertex$ = -16188				; size = 16184
__$ArrayPad$ = -4					; size = 4
_rkTPRS$ = 8						; size = 4
_patchnum$ = 12						; size = 4
_wPrimitiveCount$ = 16					; size = 2
_ePrimitiveType$ = 20					; size = 4
_isFogEnable$ = 24					; size = 1
?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 60 3f 00 00	 mov	 eax, 16224		; 00003f60H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR _patchnum$[ebp]
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _rkTPRS$[ebp]
  00020	57		 push	 edi

; 134  : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat");
; 135  : 
; 136  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00021	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00028	89 8d b0 c0 ff
	ff		 mov	 DWORD PTR _rkTPRS$GSCopy$1$[ebp], ecx
  0002e	2b d0		 sub	 edx, eax
  00030	8b 46 64	 mov	 eax, DWORD PTR [esi+100]

; 137  : 
; 138  : 	if (!pTerrainPatchProxy->isUsed())

  00033	80 7c 90 04 00	 cmp	 BYTE PTR [eax+edx*4+4], 0
  00038	8d 3c 90	 lea	 edi, DWORD PTR [eax+edx*4]
  0003b	0f 84 f6 03 00
	00		 je	 $LN1@SoftwareTr

; 139  : 		return;
; 140  : 
; 141  : 	bool isDynamicShadow = pTerrainPatchProxy->IsIn(rkTPRS.m_v3Player, 3000.0f);

  00041	51		 push	 ecx
  00042	8d 81 6c 01 00
	00		 lea	 eax, DWORD PTR [ecx+364]
  00048	c7 04 24 00 80
	3b 45		 mov	 DWORD PTR [esp], 1161527296 ; 453b8000H
  0004f	50		 push	 eax
  00050	8b cf		 mov	 ecx, edi
  00052	e8 00 00 00 00	 call	 ?IsIn@CTerrainPatchProxy@@QAE_NABUD3DXVECTOR3@@M@Z ; CTerrainPatchProxy::IsIn

; 142  : 
; 143  : 	if (!m_bDrawChrShadow)

  00057	33 c9		 xor	 ecx, ecx
  00059	0f b6 c0	 movzx	 eax, al
  0005c	38 8e 32 01 00
	00		 cmp	 BYTE PTR [esi+306], cl
  00062	0f 44 c1	 cmove	 eax, ecx
  00065	89 85 a4 c0 ff
	ff		 mov	 DWORD PTR tv801[ebp], eax
  0006b	88 85 b4 c0 ff
	ff		 mov	 BYTE PTR _isDynamicShadow$[ebp], al

; 144  : 		isDynamicShadow = false;
; 145  : 
; 146  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();

  00071	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  00075	89 85 ac c0 ff
	ff		 mov	 DWORD PTR _sPatchNum$1$[ebp], eax

; 147  : 
; 148  : 	if (sPatchNum < 0)

  0007b	85 c0		 test	 eax, eax
  0007d	0f 88 b4 03 00
	00		 js	 $LN1@SoftwareTr

; 149  : 		return;
; 150  : 
; 151  : 	BYTE ucTerrainNum = pTerrainPatchProxy->GetTerrainNum();

  00083	8a 47 08	 mov	 al, BYTE PTR [edi+8]
  00086	88 85 bc c0 ff
	ff		 mov	 BYTE PTR _ucTerrainNum$[ebp], al

; 152  : 
; 153  : 	if (0xFF == ucTerrainNum)

  0008c	3c ff		 cmp	 al, 255			; 000000ffH
  0008e	0f 84 a3 03 00
	00		 je	 $LN1@SoftwareTr

; 154  : 		return;
; 155  : 
; 156  : 	CTerrain * pTerrain;
; 157  : 	if (!GetTerrainPointer(ucTerrainNum, &pTerrain))

  00094	8d 85 b8 c0 ff
	ff		 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0009a	8b ce		 mov	 ecx, esi
  0009c	50		 push	 eax
  0009d	ff b5 bc c0 ff
	ff		 push	 DWORD PTR _ucTerrainNum$[ebp]
  000a3	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  000a8	85 c0		 test	 eax, eax
  000aa	0f 84 87 03 00
	00		 je	 $LN1@SoftwareTr
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\AreaTerrain.h

; 92   : 			*usCoordX = m_wX;

  000b0	53		 push	 ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 166  : 	if (!__SoftwareTransformPatch_SetTransform(rkTPRS, akTransVertex, *pTerrainPatchProxy, wCoordX, wCoordY, isFogEnable, isDynamicShadow))

  000b1	ff b5 b4 c0 ff
	ff		 push	 DWORD PTR _isDynamicShadow$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\AreaTerrain.h

; 92   : 			*usCoordX = m_wX;

  000b7	8b 9d b8 c0 ff
	ff		 mov	 ebx, DWORD PTR _pTerrain$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 166  : 	if (!__SoftwareTransformPatch_SetTransform(rkTPRS, akTransVertex, *pTerrainPatchProxy, wCoordX, wCoordY, isFogEnable, isDynamicShadow))

  000bd	ff 75 18	 push	 DWORD PTR _isFogEnable$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\AreaTerrain.h

; 92   : 			*usCoordX = m_wX;

  000c0	89 9d a8 c0 ff
	ff		 mov	 DWORD PTR _pTerrain$1$[ebp], ebx

; 93   : 			*usCoordY = m_wY;

  000c6	0f b7 83 6e a5
	06 00		 movzx	 eax, WORD PTR [ebx+435566]
  000cd	0f b7 8b 6c a5
	06 00		 movzx	 ecx, WORD PTR [ebx+435564]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 166  : 	if (!__SoftwareTransformPatch_SetTransform(rkTPRS, akTransVertex, *pTerrainPatchProxy, wCoordX, wCoordY, isFogEnable, isDynamicShadow))

  000d4	50		 push	 eax
  000d5	51		 push	 ecx
  000d6	57		 push	 edi
  000d7	8d 85 c4 c0 ff
	ff		 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  000dd	8b ce		 mov	 ecx, esi
  000df	50		 push	 eax
  000e0	ff b5 b0 c0 ff
	ff		 push	 DWORD PTR _rkTPRS$GSCopy$1$[ebp]
  000e6	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z ; CMapOutdoor::__SoftwareTransformPatch_SetTransform
  000eb	84 c0		 test	 al, al
  000ed	0f 84 43 03 00
	00		 je	 $LN94@SoftwareTr

; 167  : 		return;
; 168  : 
; 169  : 	if (!__SoftwareTransformPatch_SetSplatStream(akTransVertex))

  000f3	8d 85 c4 c0 ff
	ff		 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  000f9	8b ce		 mov	 ecx, esi
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream
  00101	84 c0		 test	 al, al
  00103	0f 84 2d 03 00
	00		 je	 $LN94@SoftwareTr

; 170  : 		return;
; 171  : 
; 172  : 	if (isFogEnable)

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0010f	6a 02		 push	 2
  00111	6a 02		 push	 2
  00113	6a 00		 push	 0
  00115	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
  0011a	80 7d 18 00	 cmp	 BYTE PTR _isFogEnable$[ebp], 0
  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00124	74 0f		 je	 SHORT $LN12@SoftwareTr

; 173  : 	{
; 174  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
; 175  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TFACTOR);

  00126	6a 03		 push	 3
  00128	6a 03		 push	 3
  0012a	6a 00		 push	 0
  0012c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 176  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_BLENDDIFFUSEALPHA);

  00131	6a 0c		 push	 12			; 0000000cH

; 177  : 	}

  00133	eb 0d		 jmp	 SHORT $LN95@SoftwareTr
$LN12@SoftwareTr:

; 178  : 	else
; 179  : 	{
; 180  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
; 181  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  00135	6a 00		 push	 0
  00137	6a 03		 push	 3
  00139	6a 00		 push	 0
  0013b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 182  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00140	6a 02		 push	 2
$LN95@SoftwareTr:

; 185  : 	int iPrevRenderedSplatNum=m_iRenderedSplatNum;

  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00148	6a 01		 push	 1
  0014a	6a 00		 push	 0
  0014c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
  00151	8b 86 88 09 00
	00		 mov	 eax, DWORD PTR [esi+2440]

; 188  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  00157	bf 01 00 00 00	 mov	 edi, 1
; File C:\DS Project\DS Files\Source\ClientSource\Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  0015c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A ; CTerrainImpl::ms_pTextureSet
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 185  : 	int iPrevRenderedSplatNum=m_iRenderedSplatNum;

  00162	89 85 a0 c0 ff
	ff		 mov	 DWORD PTR _iPrevRenderedSplatNum$1$[ebp], eax

; 186  : 
; 187  : 	bool isFirst=true;

  00168	c6 85 c3 c0 ff
	ff 01		 mov	 BYTE PTR _isFirst$1$[ebp], 1
; File C:\DS Project\DS Files\Source\ClientSource\Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  0016f	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 188  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  00174	3b c7		 cmp	 eax, edi
  00176	0f 86 90 01 00
	00		 jbe	 $LN93@SoftwareTr

; 185  : 	int iPrevRenderedSplatNum=m_iRenderedSplatNum;

  0017c	8d 8b 50 95 04
	00		 lea	 ecx, DWORD PTR [ebx+300368]
  00182	89 8d bc c0 ff
	ff		 mov	 DWORD PTR tv833[ebp], ecx
  00188	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@SoftwareTr:

; 189  : 	{
; 190  : 		TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 191  : 
; 192  : 		if (!rSplat.Active)

  00190	83 79 f8 00	 cmp	 DWORD PTR [ecx-8], 0
  00194	0f 84 4f 01 00
	00		 je	 $LN2@SoftwareTr

; 193  : 			continue;
; 194  : 
; 195  : 		if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)

  0019a	8b 85 ac c0 ff
	ff		 mov	 eax, DWORD PTR _sPatchNum$1$[ebp]
  001a0	40		 inc	 eax
  001a1	c1 e0 08	 shl	 eax, 8
  001a4	03 c7		 add	 eax, edi
  001a6	83 bc 83 3c 91
	03 00 00	 cmp	 DWORD PTR [ebx+eax*4+233788], 0
  001ae	0f 84 35 01 00
	00		 je	 $LN2@SoftwareTr

; 196  : 			continue;
; 197  : 
; 198  : 		const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);

  001b4	57		 push	 edi
  001b5	8d 8e 7c 02 00
	00		 lea	 ecx, DWORD PTR [esi+636]
  001bb	e8 00 00 00 00	 call	 ?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z ; CTextureSet::GetTexture

; 199  : 
; 200  : 		if (isFirst)

  001c0	80 bd c3 c0 ff
	ff 00		 cmp	 BYTE PTR _isFirst$1$[ebp], 0
  001c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001cd	8d 58 18	 lea	 ebx, DWORD PTR [eax+24]
  001d0	74 66		 je	 SHORT $LN16@SoftwareTr

; 201  : 		{
; 202  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG2);

  001d2	6a 03		 push	 3
  001d4	6a 04		 push	 4
  001d6	6a 01		 push	 1
  001d8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 203  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  001dd	ff 33		 push	 DWORD PTR [ebx]
  001df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e5	6a 00		 push	 0
  001e7	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 204  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  001ec	8b 85 bc c0 ff
	ff		 mov	 eax, DWORD PTR tv833[ebp]
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f8	ff 30		 push	 DWORD PTR [eax]
  001fa	6a 01		 push	 1
  001fc	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 205  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  00201	0f b7 45 10	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  00205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020b	50		 push	 eax
  0020c	6a 00		 push	 0
  0020e	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  00214	6a 00		 push	 0
  00216	ff 75 14	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00219	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 206  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0021e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00224	6a 02		 push	 2
  00226	6a 04		 push	 4
  00228	6a 01		 push	 1
  0022a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 207  : 			isFirst=false;

  0022f	c6 85 c3 c0 ff
	ff 00		 mov	 BYTE PTR _isFirst$1$[ebp], 0

; 208  : 		}

  00236	eb 3b		 jmp	 SHORT $LN17@SoftwareTr
$LN16@SoftwareTr:

; 209  : 		else
; 210  : 		{
; 211  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  00238	ff 33		 push	 DWORD PTR [ebx]
  0023a	6a 00		 push	 0
  0023c	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 212  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  00241	8b 85 bc c0 ff
	ff		 mov	 eax, DWORD PTR tv833[ebp]
  00247	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0024d	ff 30		 push	 DWORD PTR [eax]
  0024f	6a 01		 push	 1
  00251	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 213  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  00256	0f b7 45 10	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  0025a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00260	50		 push	 eax
  00261	6a 00		 push	 0
  00263	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  00269	6a 00		 push	 0
  0026b	ff 75 14	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0026e	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN17@SoftwareTr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00273	8b 9e 94 09 00
	00		 mov	 ebx, DWORD PTR [esi+2452]
  00279	8b 86 90 09 00
	00		 mov	 eax, DWORD PTR [esi+2448]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5132 :     for (; _First != _Last; ++_First) {

  0027f	3b c3		 cmp	 eax, ebx
  00281	74 0b		 je	 SHORT $LN92@SoftwareTr
$LL55@SoftwareTr:

; 5133 :         if (*_First == _Val) {

  00283	39 38		 cmp	 DWORD PTR [eax], edi
  00285	74 07		 je	 SHORT $LN92@SoftwareTr

; 5132 :     for (; _First != _Last; ++_First) {

  00287	83 c0 04	 add	 eax, 4
  0028a	3b c3		 cmp	 eax, ebx
  0028c	75 f5		 jne	 SHORT $LL55@SoftwareTr
$LN92@SoftwareTr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  0028e	50		 push	 eax
  0028f	e8 00 00 00 00	 call	 ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ; std::_Refancy<int *,0>
  00294	83 c4 04	 add	 esp, 4
  00297	3b c3		 cmp	 eax, ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 217  : 		if (aIterator == m_RenderedTextureNumVector.end())

  00299	75 2e		 jne	 SHORT $LN72@SoftwareTr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0029b	8b cb		 mov	 ecx, ebx
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 218  : 			m_RenderedTextureNumVector.push_back(j);

  0029d	89 bd b4 c0 ff
	ff		 mov	 DWORD PTR $T1[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  002a3	3b 8e 98 09 00
	00		 cmp	 ecx, DWORD PTR [esi+2456]
  002a9	74 0b		 je	 SHORT $LN73@SoftwareTr

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  002ab	89 39		 mov	 DWORD PTR [ecx], edi

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  002ad	83 86 94 09 00
	00 04		 add	 DWORD PTR [esi+2452], 4

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  002b4	eb 13		 jmp	 SHORT $LN72@SoftwareTr
$LN73@SoftwareTr:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  002b6	8d 95 b4 c0 ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  002bc	52		 push	 edx
  002bd	51		 push	 ecx
  002be	8d 8e 90 09 00
	00		 lea	 ecx, DWORD PTR [esi+2448]
  002c4	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
$LN72@SoftwareTr:
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 219  : 		++m_iRenderedSplatNum;

  002c9	ff 86 88 09 00
	00		 inc	 DWORD PTR [esi+2440]
  002cf	8b 86 88 09 00
	00		 mov	 eax, DWORD PTR [esi+2440]

; 220  : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  002d5	3b 86 9c 09 00
	00		 cmp	 eax, DWORD PTR [esi+2460]
  002db	7d 2f		 jge	 SHORT $LN93@SoftwareTr
  002dd	8b 8d bc c0 ff
	ff		 mov	 ecx, DWORD PTR tv833[ebp]
  002e3	8b 9d a8 c0 ff
	ff		 mov	 ebx, DWORD PTR _pTerrain$1$[ebp]
$LN2@SoftwareTr:

; 188  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  002e9	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002ec	47		 inc	 edi
  002ed	89 8d bc c0 ff
	ff		 mov	 DWORD PTR tv833[ebp], ecx
; File C:\DS Project\DS Files\Source\ClientSource\Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  002f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A ; CTerrainImpl::ms_pTextureSet
  002f9	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 188  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  002fe	8b 8d bc c0 ff
	ff		 mov	 ecx, DWORD PTR tv833[ebp]
  00304	3b f8		 cmp	 edi, eax
  00306	0f 82 84 fe ff
	ff		 jb	 $LL4@SoftwareTr
$LN93@SoftwareTr:

; 221  : 			break;
; 222  : 	}
; 223  : 
; 224  : 	if (m_bDrawShadow)

  0030c	80 be 31 01 00
	00 00		 cmp	 BYTE PTR [esi+305], 0
  00313	0f 84 02 01 00
	00		 je	 $LN20@SoftwareTr

; 225  : 	{
; 226  : 		__SoftwareTransformPatch_SetShadowStream(akTransVertex);

  00319	8d 85 c4 c0 ff
	ff		 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  0031f	8b ce		 mov	 ecx, esi
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream

; 227  : 		__SoftwareTransformPatch_ApplyStaticShadowRenderState();

  00327	8b ce		 mov	 ecx, esi
  00329	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState

; 228  : 
; 229  : 		if (isDynamicShadow)

  0032e	8b 9d a4 c0 ff
	ff		 mov	 ebx, DWORD PTR tv801[ebp]
  00334	8b ce		 mov	 ecx, esi
  00336	84 db		 test	 bl, bl
  00338	74 07		 je	 SHORT $LN21@SoftwareTr

; 230  : 			__SoftwareTransformPatch_ApplyDynamicShadowRenderState();

  0033a	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState
  0033f	eb 05		 jmp	 SHORT $LN22@SoftwareTr
$LN21@SoftwareTr:

; 231  : 		else
; 232  : 			__SoftwareTransformPatch_ApplyFogShadowRenderState();

  00341	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState
$LN22@SoftwareTr:

; 233  : 
; 234  : 		if (isFogEnable)

  00346	80 7d 18 00	 cmp	 BYTE PTR _isFogEnable$[ebp], 0
  0034a	0f b7 7d 10	 movzx	 edi, WORD PTR _wPrimitiveCount$[ebp]
  0034e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00354	74 74		 je	 SHORT $LN23@SoftwareTr

; 235  : 		{
; 236  : 			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, TRUE);

  00356	6a 01		 push	 1
  00358	6a 1c		 push	 28			; 0000001cH
  0035a	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 237  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, 0xFFFFFFFF);

  0035f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00365	6a ff		 push	 -1
  00367	6a 22		 push	 34			; 00000022H
  00369	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 238  : 			STATEMANAGER.SetTexture(0, pTerrain->GetShadowTexture());

  0036e	8b 85 b8 c0 ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00374	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0037a	ff b0 44 a5 04
	00		 push	 DWORD PTR [eax+304452]
  00380	6a 00		 push	 0
  00382	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 239  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  00387	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0038d	57		 push	 edi
  0038e	6a 00		 push	 0
  00390	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  00396	6a 00		 push	 0
  00398	ff 75 14	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0039b	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 240  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, rkTPRS.m_dwFogColor);

  003a0	8b 85 b0 c0 ff
	ff		 mov	 eax, DWORD PTR _rkTPRS$GSCopy$1$[ebp]
  003a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ac	ff b0 78 01 00
	00		 push	 DWORD PTR [eax+376]
  003b2	6a 22		 push	 34			; 00000022H
  003b4	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 241  : 			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  003b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003bf	6a 00		 push	 0
  003c1	6a 1c		 push	 28			; 0000001cH
  003c3	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 242  : 		}

  003c8	eb 2c		 jmp	 SHORT $LN24@SoftwareTr
$LN23@SoftwareTr:

; 243  : 		else
; 244  : 		{
; 245  : 			STATEMANAGER.SetTexture(0, pTerrain->GetShadowTexture());

  003ca	8b 85 b8 c0 ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  003d0	ff b0 44 a5 04
	00		 push	 DWORD PTR [eax+304452]
  003d6	6a 00		 push	 0
  003d8	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 246  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  003dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003e3	57		 push	 edi
  003e4	6a 00		 push	 0
  003e6	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  003ec	6a 00		 push	 0
  003ee	ff 75 14	 push	 DWORD PTR _ePrimitiveType$[ebp]
  003f1	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN24@SoftwareTr:

; 247  : 		}
; 248  : 
; 249  : 		if (isDynamicShadow)

  003f6	8b ce		 mov	 ecx, esi
  003f8	84 db		 test	 bl, bl
  003fa	74 07		 je	 SHORT $LN25@SoftwareTr

; 250  : 			__SoftwareTransformPatch_RestoreDynamicShadowRenderState();

  003fc	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState
  00401	eb 05		 jmp	 SHORT $LN26@SoftwareTr
$LN25@SoftwareTr:

; 251  : 		else
; 252  : 			__SoftwareTransformPatch_RestoreFogShadowRenderState();

  00403	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState
$LN26@SoftwareTr:

; 253  : 
; 254  : 		ms_faceCount += wPrimitiveCount;

  00408	01 3d 00 00 00
	00		 add	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, edi ; CGraphicBase::ms_faceCount

; 255  :   		++m_iRenderedSplatNum;
; 256  : 
; 257  : 
; 258  : 
; 259  : 		__SoftwareTransformPatch_RestoreStaticShadowRenderState();

  0040e	8b ce		 mov	 ecx, esi
  00410	ff 86 88 09 00
	00		 inc	 DWORD PTR [esi+2440]
  00416	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState
$LN20@SoftwareTr:

; 260  : 	}
; 261  : 
; 262  : 	++m_iRenderedPatchNum;
; 263  : 
; 264  : 	int iCurRenderedSplatNum=m_iRenderedSplatNum-iPrevRenderedSplatNum;

  0041b	8b 86 88 09 00
	00		 mov	 eax, DWORD PTR [esi+2440]
  00421	2b 85 a0 c0 ff
	ff		 sub	 eax, DWORD PTR _iPrevRenderedSplatNum$1$[ebp]
  00427	ff 86 8c 09 00
	00		 inc	 DWORD PTR [esi+2444]

; 265  : 
; 266  : 	m_iRenderedSplatNumSqSum+=iCurRenderedSplatNum*iCurRenderedSplatNum;

  0042d	0f af c0	 imul	 eax, eax
  00430	01 86 84 09 00
	00		 add	 DWORD PTR [esi+2436], eax
$LN94@SoftwareTr:
  00436	5b		 pop	 ebx
$LN1@SoftwareTr:

; 267  : }

  00437	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0043a	5f		 pop	 edi
  0043b	33 cd		 xor	 ecx, ebp
  0043d	5e		 pop	 esi
  0043e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00443	8b e5		 mov	 esp, ebp
  00445	5d		 pop	 ebp
  00446	c2 14 00	 ret	 20			; 00000014H
?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState, COMDAT
; _this$ = ecx

; 390  : 	STATEMANAGER.SetTexture(1, NULL);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00006	6a 00		 push	 0
  00008	6a 01		 push	 1
  0000a	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 391  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00015	6a 01		 push	 1
  00017	6a 02		 push	 2
  00019	6a 01		 push	 1
  0001b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 392  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00026	6a 02		 push	 2
  00028	6a 01		 push	 1
  0002a	6a 01		 push	 1
  0002c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 393  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00037	6a 02		 push	 2
  00039	6a 05		 push	 5
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 394  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00048	6a 02		 push	 2
  0004a	6a 04		 push	 4
  0004c	6a 01		 push	 1
  0004e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 395  : 
; 396  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00059	6a 03		 push	 3
  0005b	6a 0d		 push	 13			; 0000000dH
  0005d	6a 01		 push	 1
  0005f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 397  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006a	6a 03		 push	 3
  0006c	6a 0e		 push	 14			; 0000000eH
  0006e	6a 01		 push	 1
  00070	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 398  : }

  00075	c3		 ret	 0
?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState, COMDAT
; _this$ = ecx

; 354  :  	STATEMANAGER.SetTexture(1, m_lpCharacterShadowMapTexture);

  00000	ff b1 d4 01 00
	00		 push	 DWORD PTR [ecx+468]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0000c	6a 01		 push	 1
  0000e	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 355  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00019	6a 02		 push	 2
  0001b	6a 02		 push	 2
  0001d	6a 01		 push	 1
  0001f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 356  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0002a	6a 01		 push	 1
  0002c	6a 03		 push	 3
  0002e	6a 01		 push	 1
  00030	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 357  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0003b	6a 04		 push	 4
  0003d	6a 01		 push	 1
  0003f	6a 01		 push	 1
  00041	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 358  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_CURRENT);

  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004c	6a 01		 push	 1
  0004e	6a 05		 push	 5
  00050	6a 01		 push	 1
  00052	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 359  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005d	6a 02		 push	 2
  0005f	6a 04		 push	 4
  00061	6a 01		 push	 1
  00063	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 360  : 
; 361  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006e	6a 03		 push	 3
  00070	6a 0d		 push	 13			; 0000000dH
  00072	6a 01		 push	 1
  00074	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 362  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007f	6a 03		 push	 3
  00081	6a 0e		 push	 14			; 0000000eH
  00083	6a 01		 push	 1
  00085	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 363  : }

  0008a	c3		 ret	 0
?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState, COMDAT
; _this$ = ecx

; 404  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00006	6a 00		 push	 0
  00008	6a 1c		 push	 28			; 0000001cH
  0000a	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 405  : 
; 406  : 	STATEMANAGER.SetTexture(1, NULL);

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00015	6a 00		 push	 0
  00017	6a 01		 push	 1
  00019	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 407  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00024	6a 01		 push	 1
  00026	6a 02		 push	 2
  00028	6a 01		 push	 1
  0002a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 408  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00035	6a 02		 push	 2
  00037	6a 01		 push	 1
  00039	6a 01		 push	 1
  0003b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 409  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00046	6a 02		 push	 2
  00048	6a 05		 push	 5
  0004a	6a 01		 push	 1
  0004c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 410  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00057	6a 02		 push	 2
  00059	6a 04		 push	 4
  0005b	6a 01		 push	 1
  0005d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 411  : }

  00062	c3		 ret	 0
?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState, COMDAT
; _this$ = ecx

; 367  : 	STATEMANAGER.SetTexture(1, NULL);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00006	6a 00		 push	 0
  00008	6a 01		 push	 1
  0000a	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 368  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00015	6a 01		 push	 1
  00017	6a 02		 push	 2
  00019	6a 01		 push	 1
  0001b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 369  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00026	6a 02		 push	 2
  00028	6a 01		 push	 1
  0002a	6a 01		 push	 1
  0002c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 370  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_CURRENT);

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00037	6a 01		 push	 1
  00039	6a 05		 push	 5
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 371  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00048	6a 02		 push	 2
  0004a	6a 04		 push	 4
  0004c	6a 01		 push	 1
  0004e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 372  : }

  00053	c3		 ret	 0
?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState, COMDAT
; _this$ = ecx

; 375  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00006	6a 02		 push	 2
  00008	6a 02		 push	 2
  0000a	6a 00		 push	 0
  0000c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 376  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00017	6a 02		 push	 2
  00019	6a 01		 push	 1
  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 377  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00028	6a 02		 push	 2
  0002a	6a 05		 push	 5
  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 378  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00039	6a 02		 push	 2
  0003b	6a 04		 push	 4
  0003d	6a 00		 push	 0
  0003f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 379  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004a	6a 01		 push	 1
  0004c	6a 0d		 push	 13			; 0000000dH
  0004e	6a 00		 push	 0
  00050	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 380  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005b	6a 01		 push	 1
  0005d	6a 0e		 push	 14			; 0000000eH
  0005f	6a 00		 push	 0
  00061	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 381  : 
; 382  : 	STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006c	6a 05		 push	 5
  0006e	6a 13		 push	 19			; 00000013H
  00070	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 383  : 	STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007b	6a 06		 push	 6
  0007d	6a 14		 push	 20			; 00000014H
  0007f	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 384  : }

  00084	c3		 ret	 0
?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState, COMDAT
; _this$ = ecx

; 339  : 	STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00006	6a 01		 push	 1
  00008	6a 13		 push	 19			; 00000013H
  0000a	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 340  : 	STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_SRCCOLOR);

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00015	6a 03		 push	 3
  00017	6a 14		 push	 20			; 00000014H
  00019	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 341  : 
; 342  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00024	6a 02		 push	 2
  00026	6a 02		 push	 2
  00028	6a 00		 push	 0
  0002a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 343  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00035	6a 00		 push	 0
  00037	6a 03		 push	 3
  00039	6a 00		 push	 0
  0003b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 344  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00046	6a 04		 push	 4
  00048	6a 01		 push	 1
  0004a	6a 00		 push	 0
  0004c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 345  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00057	6a 02		 push	 2
  00059	6a 05		 push	 5
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 346  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00068	6a 02		 push	 2
  0006a	6a 04		 push	 4
  0006c	6a 00		 push	 0
  0006e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 347  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00079	6a 03		 push	 3
  0007b	6a 0d		 push	 13			; 0000000dH
  0007d	6a 00		 push	 0
  0007f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 348  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);

  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008a	6a 03		 push	 3
  0008c	6a 0e		 push	 14			; 0000000eH
  0008e	6a 00		 push	 0
  00090	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 349  : 
; 350  : }

  00095	c3		 ret	 0
?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z
_TEXT	SEGMENT
_akDstVertex$ = -4					; size = 4
_akSrcVertex$ = 8					; size = 4
?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream, COMDAT
; _this$ = ecx

; 700  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 701  : 	IDirect3DVertexBuffer8* pkVB=m_kSTPD.m_pkVBSplat[m_kSTPD.m_dwSplatPos++];

  00004	8b 81 00 0a 00
	00		 mov	 eax, DWORD PTR [ecx+2560]
  0000a	56		 push	 esi
  0000b	8b b4 81 c0 09
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+2496]
  00012	40		 inc	 eax

; 702  : 	m_kSTPD.m_dwSplatPos%=SoftwareTransformPatch_SData::SPLAT_VB_NUM;

  00013	83 e0 07	 and	 eax, 7
  00016	89 81 00 0a 00
	00		 mov	 DWORD PTR [ecx+2560], eax

; 703  : 	if (!pkVB)

  0001c	85 f6		 test	 esi, esi
  0001e	0f 84 81 00 00
	00		 je	 $LN12@SoftwareTr

; 704  : 		return false;
; 705  : 
; 706  : 	DWORD dwVBSize=sizeof(SoftwareTransformPatch_SSplatVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT;
; 707  : 	SoftwareTransformPatch_SSplatVertex* akDstVertex;
; 708  : 	if (FAILED(

  00024	8b 06		 mov	 eax, DWORD PTR [esi]
  00026	8d 4d fc	 lea	 ecx, DWORD PTR _akDstVertex$[ebp]
  00029	6a 00		 push	 0
  0002b	51		 push	 ecx
  0002c	68 28 2d 00 00	 push	 11560			; 00002d28H
  00031	6a 00		 push	 0
  00033	56		 push	 esi
  00034	ff 50 2c	 call	 DWORD PTR [eax+44]
  00037	85 c0		 test	 eax, eax
  00039	78 6a		 js	 SHORT $LN12@SoftwareTr

; 711  : 
; 712  : 	SoftwareTransformPatch_STLVertex* pkSrcVertex;
; 713  : 	SoftwareTransformPatch_SSplatVertex* pkDstVertex;
; 714  : 	for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  0003b	8b 55 08	 mov	 edx, DWORD PTR _akSrcVertex$[ebp]
  0003e	57		 push	 edi
  0003f	33 ff		 xor	 edi, edi
  00041	83 c2 14	 add	 edx, 20			; 00000014H
$LL4@SoftwareTr:

; 715  : 	{
; 716  : 		pkSrcVertex=akSrcVertex+uIndex;
; 717  : 		pkDstVertex=akDstVertex+uIndex;

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _akDstVertex$[ebp]
  00047	8d 52 38	 lea	 edx, DWORD PTR [edx+56]

; 718  : 		pkDstVertex->kPosition=pkSrcVertex->kPosition;

  0004a	0f 10 42 b4	 movups	 xmm0, XMMWORD PTR [edx-76]
  0004e	03 cf		 add	 ecx, edi
  00050	83 c7 28	 add	 edi, 40			; 00000028H
  00053	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 719  : 		pkDstVertex->dwDiffuse=pkSrcVertex->dwDiffuse;

  00056	8b 42 c4	 mov	 eax, DWORD PTR [edx-60]
  00059	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 720  : 		pkDstVertex->dwSpecular=pkSrcVertex->dwFog;

  0005c	8b 42 c8	 mov	 eax, DWORD PTR [edx-56]
  0005f	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 721  : 		pkDstVertex->kTex1=pkSrcVertex->kTexStaticShadow;

  00062	8b 42 dc	 mov	 eax, DWORD PTR [edx-36]
  00065	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00068	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0006b	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 722  : 		pkDstVertex->kTex2=pkSrcVertex->kTexDynamicShadow;

  0006e	8b 42 e4	 mov	 eax, DWORD PTR [edx-28]
  00071	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00074	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00077	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  0007a	81 ff 28 2d 00
	00		 cmp	 edi, 11560		; 00002d28H
  00080	75 c2		 jne	 SHORT $LL4@SoftwareTr

; 723  : 	}
; 724  : 	pkVB->Unlock();

  00082	8b 06		 mov	 eax, DWORD PTR [esi]
  00084	56		 push	 esi
  00085	ff 50 30	 call	 DWORD PTR [eax+48]

; 725  : 
; 726  : 
; 727  : 	ms_lpd3dDevice->SetStreamSource(0, pkVB, sizeof(SoftwareTransformPatch_SSplatVertex));

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0008d	6a 28		 push	 40			; 00000028H
  0008f	56		 push	 esi
  00090	6a 00		 push	 0
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	50		 push	 eax
  00095	ff 91 4c 01 00
	00		 call	 DWORD PTR [ecx+332]

; 728  : 	return true;

  0009b	5f		 pop	 edi
  0009c	b0 01		 mov	 al, 1
  0009e	5e		 pop	 esi

; 729  : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
$LN12@SoftwareTr:

; 709  : 		pkVB->Lock(0, dwVBSize, (BYTE**)&akDstVertex, 0)//D3DLOCK_DISCARD)
; 710  : 	)) return false;

  000a5	32 c0		 xor	 al, al
  000a7	5e		 pop	 esi

; 729  : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z
_TEXT	SEGMENT
_akDstVertex$ = -4					; size = 4
_akSrcVertex$ = 8					; size = 4
?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream, COMDAT
; _this$ = ecx

; 678  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 679  : 	IDirect3DVertexBuffer8* pkVB=m_kSTPD.m_pkVBSplat[m_kSTPD.m_dwSplatPos++];

  00004	8b 81 00 0a 00
	00		 mov	 eax, DWORD PTR [ecx+2560]
  0000a	56		 push	 esi
  0000b	8b b4 81 c0 09
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+2496]
  00012	40		 inc	 eax

; 680  : 	m_kSTPD.m_dwSplatPos%=SoftwareTransformPatch_SData::SPLAT_VB_NUM;

  00013	83 e0 07	 and	 eax, 7
  00016	89 81 00 0a 00
	00		 mov	 DWORD PTR [ecx+2560], eax

; 681  : 	if (!pkVB)

  0001c	85 f6		 test	 esi, esi
  0001e	74 6b		 je	 SHORT $LN12@SoftwareTr

; 682  : 		return false;
; 683  : 
; 684  : 	DWORD dwVBSize=sizeof(SoftwareTransformPatch_SSplatVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT;
; 685  : 	SoftwareTransformPatch_SSplatVertex* akDstVertex;
; 686  : 	if (FAILED(

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8d 4d fc	 lea	 ecx, DWORD PTR _akDstVertex$[ebp]
  00025	6a 00		 push	 0
  00027	51		 push	 ecx
  00028	68 28 2d 00 00	 push	 11560			; 00002d28H
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	ff 50 2c	 call	 DWORD PTR [eax+44]
  00033	85 c0		 test	 eax, eax
  00035	78 54		 js	 SHORT $LN12@SoftwareTr

; 689  : 
; 690  : 	for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _akSrcVertex$[ebp]
  0003a	33 d2		 xor	 edx, edx
  0003c	0f 1f 40 00	 npad	 4
$LL4@SoftwareTr:

; 691  : 		*(akDstVertex+uIndex)=*((SoftwareTransformPatch_SSplatVertex*)(akSrcVertex+uIndex));

  00040	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00043	8b 45 fc	 mov	 eax, DWORD PTR _akDstVertex$[ebp]
  00046	8d 49 38	 lea	 ecx, DWORD PTR [ecx+56]
  00049	0f 11 04 02	 movups	 XMMWORD PTR [edx+eax], xmm0
  0004d	0f 10 41 d8	 movups	 xmm0, XMMWORD PTR [ecx-40]
  00051	0f 11 44 02 10	 movups	 XMMWORD PTR [edx+eax+16], xmm0
  00056	f3 0f 7e 41 e8	 movq	 xmm0, QWORD PTR [ecx-24]
  0005b	66 0f d6 44 02
	20		 movq	 QWORD PTR [edx+eax+32], xmm0
  00061	83 c2 28	 add	 edx, 40			; 00000028H
  00064	81 fa 28 2d 00
	00		 cmp	 edx, 11560		; 00002d28H
  0006a	75 d4		 jne	 SHORT $LL4@SoftwareTr

; 692  : 
; 693  : 	pkVB->Unlock();

  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	56		 push	 esi
  0006f	ff 50 30	 call	 DWORD PTR [eax+48]

; 694  : 
; 695  : 	STATEMANAGER.SetStreamSource(0, pkVB, sizeof(SoftwareTransformPatch_SSplatVertex));

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00078	6a 28		 push	 40			; 00000028H
  0007a	56		 push	 esi
  0007b	6a 00		 push	 0
  0007d	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 696  : 	return true;

  00082	b0 01		 mov	 al, 1
  00084	5e		 pop	 esi

; 697  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
$LN12@SoftwareTr:

; 687  : 		pkVB->Lock(0, dwVBSize, (BYTE**)&akDstVertex, 0)//D3DLOCK_DISCARD)
; 688  : 	)) return false;

  0008b	32 c0		 xor	 al, al
  0008d	5e		 pop	 esi

; 697  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z
_TEXT	SEGMENT
tv951 = -212						; size = 4
tv977 = -208						; size = 4
_akSrcVertex$1$ = -204					; size = 4
_fShadowPatternX$1$ = -200				; size = 4
_fAlphaBiasY$1$ = -196					; size = 4
_fAlphaPatternY$1$ = -192				; size = 4
_fAlphaBiasX$1$ = -188					; size = 4
_fAlphaPatternX$1$ = -184				; size = 4
_fScreenHalfHeight$1$ = -180				; size = 4
_fScreenHalfWidth$1$ = -176				; size = 4
_fTerrainBaseY$1$ = -172				; size = 4
_fTerrainBaseX$1$ = -168				; size = 4
_fFogLenInv$1$ = -164					; size = 4
tv974 = -164						; size = 4
_akTransVertex$GSCopy$1$ = -160				; size = 4
_fShadowPatternY$1$ = -156				; size = 4
_rkTerrainPatchProxy$GSCopy$1$ = -156			; size = 4
_rkTPRS$GSCopy$1$ = -152				; size = 4
tv979 = -152						; size = 4
_this$GSCopy$1$ = -148					; size = 4
tv981 = -148						; size = 4
tv980 = -148						; size = 4
_m4Frustum$ = -144					; size = 64
_v3Shadow$1 = -80					; size = 12
_m4DynamicShadow$2 = -68				; size = 64
_kWorkVertex$3 = -60					; size = 56
_kWorkVertex$4 = -60					; size = 56
__$ArrayPad$ = -4					; size = 4
_rkTPRS$ = 8						; size = 4
_akTransVertex$ = 12					; size = 4
_rkTerrainPatchProxy$ = 16				; size = 4
_uTerrainX$ = 20					; size = 4
_uTerrainY$ = 24					; size = 4
_isFogEnable$ = 28					; size = 1
_isDynamicShadow$ = 32					; size = 1
?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_SetTransform, COMDAT
; _this$ = ecx

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _akTransVertex$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _rkTPRS$[ebp]
  0001a	89 85 60 ff ff
	ff		 mov	 DWORD PTR _akTransVertex$GSCopy$1$[ebp], eax
  00020	8b 45 10	 mov	 eax, DWORD PTR _rkTerrainPatchProxy$[ebp]
  00023	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx

; 557  : 	SoftwareTransformPatch_SSourceVertex* akSrcVertex=rkTerrainPatchProxy.SoftwareTransformPatch_GetTerrainVertexDataPtr();

  00029	8b c8		 mov	 ecx, eax
  0002b	57		 push	 edi
  0002c	89 b5 68 ff ff
	ff		 mov	 DWORD PTR _rkTPRS$GSCopy$1$[ebp], esi
  00032	89 85 64 ff ff
	ff		 mov	 DWORD PTR _rkTerrainPatchProxy$GSCopy$1$[ebp], eax
  00038	e8 00 00 00 00	 call	 ?SoftwareTransformPatch_GetTerrainVertexDataPtr@CTerrainPatchProxy@@QAEPAUSoftwareTransformPatch_SSourceVertex@@XZ ; CTerrainPatchProxy::SoftwareTransformPatch_GetTerrainVertexDataPtr
  0003d	8b f8		 mov	 edi, eax
  0003f	89 bd 34 ff ff
	ff		 mov	 DWORD PTR _akSrcVertex$1$[ebp], edi

; 558  : 	if (!akSrcVertex)

  00045	85 ff		 test	 edi, edi
  00047	75 14		 jne	 SHORT $LN11@SoftwareTr

; 559  : 		return false;

  00049	5f		 pop	 edi
  0004a	32 c0		 xor	 al, al

; 671  : 		}
; 672  : 	}
; 673  : 
; 674  : 	return true;
; 675  : }

  0004c	5e		 pop	 esi
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00050	33 cd		 xor	 ecx, ebp
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 1c 00	 ret	 28			; 0000001cH
$LN11@SoftwareTr:

; 560  : 
; 561  : 	rkTerrainPatchProxy.SoftwareTransformPatch_UpdateTerrainLighting(

  0005d	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _rkTerrainPatchProxy$GSCopy$1$[ebp]
  00063	8d 86 28 01 00
	00		 lea	 eax, DWORD PTR [esi+296]
  00069	50		 push	 eax
  0006a	8d 86 c0 00 00
	00		 lea	 eax, DWORD PTR [esi+192]
  00070	50		 push	 eax
  00071	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00077	ff b0 08 0a 00
	00		 push	 DWORD PTR [eax+2568]
  0007d	e8 00 00 00 00	 call	 ?SoftwareTransformPatch_UpdateTerrainLighting@CTerrainPatchProxy@@QAEXKABU_D3DLIGHT8@@ABU_D3DMATERIAL8@@@Z ; CTerrainPatchProxy::SoftwareTransformPatch_UpdateTerrainLighting

; 562  : 		m_kSTPD.m_dwLightVersion,
; 563  : 		rkTPRS.m_kLight, rkTPRS.m_kMtrl);
; 564  : 
; 565  : 	D3DXVECTOR3* pkSrcPosition;
; 566  : 
; 567  : 	float fTilePatternX=+1/640.0f;
; 568  : 	float fTilePatternY=-1/640.0f;
; 569  : 
; 570  : 	float fTerrainBaseX=-(float) (uTerrainX * CTerrainImpl::TERRAIN_XSIZE)+m_fTerrainTexCoordBase * 12.30769f;

  00082	69 45 14 00 64
	00 00		 imul	 eax, DWORD PTR _uTerrainX$[ebp], 25600
  00089	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0008f	f3 0f 10 91 08
	09 00 00	 movss	 xmm2, DWORD PTR [ecx+2312]
  00097	0f 28 ca	 movaps	 xmm1, xmm2
  0009a	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@4144ec4c
  000a2	66 0f 6e c0	 movd	 xmm0, eax
  000a6	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000aa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ad	0f 28 d9	 movaps	 xmm3, xmm1
  000b0	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 571  : 	float fTerrainBaseY=+(float) (uTerrainY * CTerrainImpl::TERRAIN_YSIZE)+m_fTerrainTexCoordBase * 12.30769f;

  000b9	69 45 18 00 64
	00 00		 imul	 eax, DWORD PTR _uTerrainY$[ebp], 25600
  000c0	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000c4	f3 0f 5c d8	 subss	 xmm3, xmm0
  000c8	66 0f 6e c0	 movd	 xmm0, eax
  000cc	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000d0	c1 e8 1f	 shr	 eax, 31			; 0000001fH

; 572  : 
; 573  : 	float fScreenHalfWidth=rkTPRS.m_fScreenHalfWidth;
; 574  : 	float fScreenHalfHeight=rkTPRS.m_fScreenHalfHeight;
; 575  : 
; 576  : 	float fAlphaPatternX=m_matSplatAlpha._11;
; 577  : 	float fAlphaPatternY=m_matSplatAlpha._22;
; 578  : 	float fAlphaBiasX=m_matSplatAlpha._41;
; 579  : 	float fAlphaBiasY=m_matSplatAlpha._42;
; 580  : 	float fShadowPatternX=+m_fTerrainTexCoordBase * ((float) CTerrainImpl::PATCH_XSIZE / (CTerrainImpl::XSIZE));
; 581  : 	float fShadowPatternY=-m_fTerrainTexCoordBase * ((float) CTerrainImpl::PATCH_YSIZE / (CTerrainImpl::YSIZE));
; 582  : 
; 583  : 	D3DXMATRIX m4Frustum=rkTPRS.m_m4Frustum;
; 584  : 
; 585  : 	if (isFogEnable)

  000d3	80 7d 1c 00	 cmp	 BYTE PTR _isFogEnable$[ebp], 0
  000d7	f3 0f 11 9d 58
	ff ff ff	 movss	 DWORD PTR _fTerrainBaseX$1$[ebp], xmm3
  000df	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000e8	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000ec	f3 0f 58 c1	 addss	 xmm0, xmm1
  000f0	0f 28 ca	 movaps	 xmm1, xmm2
  000f3	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
  000fa	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3e000000
  00102	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@3e000000
  0010a	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _fTerrainBaseY$1$[ebp], xmm0
  00112	f3 0f 10 86 7c
	01 00 00	 movss	 xmm0, DWORD PTR [esi+380]
  0011a	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _fScreenHalfWidth$1$[ebp], xmm0
  00122	f3 0f 10 86 80
	01 00 00	 movss	 xmm0, DWORD PTR [esi+384]
  0012a	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _fScreenHalfHeight$1$[ebp], xmm0
  00132	f3 0f 10 81 c8
	07 00 00	 movss	 xmm0, DWORD PTR [ecx+1992]
  0013a	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _fAlphaPatternX$1$[ebp], xmm0
  00142	f3 0f 10 81 dc
	07 00 00	 movss	 xmm0, DWORD PTR [ecx+2012]
  0014a	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _fAlphaPatternY$1$[ebp], xmm0
  00152	f3 0f 10 81 f8
	07 00 00	 movss	 xmm0, DWORD PTR [ecx+2040]
  0015a	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fAlphaBiasX$1$[ebp], xmm0
  00162	f3 0f 10 81 fc
	07 00 00	 movss	 xmm0, DWORD PTR [ecx+2044]
  0016a	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fAlphaBiasY$1$[ebp], xmm0
  00172	0f 10 46 40	 movups	 xmm0, XMMWORD PTR [esi+64]
  00176	f3 0f 11 8d 38
	ff ff ff	 movss	 DWORD PTR _fShadowPatternX$1$[ebp], xmm1
  0017e	0f 11 85 70 ff
	ff ff		 movups	 XMMWORD PTR _m4Frustum$[ebp], xmm0
  00185	0f 10 46 50	 movups	 xmm0, XMMWORD PTR [esi+80]
  00189	f3 0f 11 95 64
	ff ff ff	 movss	 DWORD PTR _fShadowPatternY$1$[ebp], xmm2
  00191	0f 11 45 80	 movups	 XMMWORD PTR _m4Frustum$[ebp+16], xmm0
  00195	0f 10 46 60	 movups	 xmm0, XMMWORD PTR [esi+96]
  00199	0f 11 45 90	 movups	 XMMWORD PTR _m4Frustum$[ebp+32], xmm0
  0019d	0f 10 46 70	 movups	 xmm0, XMMWORD PTR [esi+112]
  001a1	0f 11 45 a0	 movups	 XMMWORD PTR _m4Frustum$[ebp+48], xmm0
  001a5	0f 84 c1 01 00
	00		 je	 $LN12@SoftwareTr

; 586  : 	{
; 587  : 		float fFogCur;
; 588  : 		float fFogFar=rkTPRS.m_fFogFarTransZ;

  001ab	f3 0f 10 86 90
	01 00 00	 movss	 xmm0, DWORD PTR [esi+400]
  001b3	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR tv951[ebp], xmm0

; 589  : 		float fFogLenInv=rkTPRS.m_fFogLenInv;

  001bb	f3 0f 10 86 94
	01 00 00	 movss	 xmm0, DWORD PTR [esi+404]
  001c3	8b b5 60 ff ff
	ff		 mov	 esi, DWORD PTR _akTransVertex$GSCopy$1$[ebp]
  001c9	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _fFogLenInv$1$[ebp], xmm0
  001d1	c7 85 6c ff ff
	ff 21 01 00 00	 mov	 DWORD PTR tv980[ebp], 289 ; 00000121H
  001db	0f 1f 44 00 00	 npad	 5
$LL4@SoftwareTr:

; 590  : 
; 591  : 		float fLocalX;
; 592  : 		float fLocalY;
; 593  : 
; 594  : 		SoftwareTransformPatch_STLVertex kWorkVertex;
; 595  : 		for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)
; 596  : 		{
; 597  : 			pkSrcPosition=&akSrcVertex[uIndex].kPosition;
; 598  : 			D3DXVec3Transform(&kWorkVertex.kPosition, pkSrcPosition, &m4Frustum);

  001e0	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _m4Frustum$[ebp]
  001e6	50		 push	 eax
  001e7	57		 push	 edi
  001e8	8d 45 c4	 lea	 eax, DWORD PTR _kWorkVertex$4[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _D3DXVec3Transform@12

; 599  : 			fLocalX=pkSrcPosition->x+fTerrainBaseX;
; 600  : 			fLocalY=pkSrcPosition->y+fTerrainBaseY;
; 601  : 			kWorkVertex.kPosition.w=1.0f/kWorkVertex.kPosition.w;

  001f1	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f800000
  001f9	0f 28 cf	 movaps	 xmm1, xmm7
  001fc	f3 0f 10 1f	 movss	 xmm3, DWORD PTR [edi]
  00200	f3 0f 5e 4d d0	 divss	 xmm1, DWORD PTR _kWorkVertex$4[ebp+12]

; 602  : 			kWorkVertex.kPosition.x*=kWorkVertex.kPosition.w;
; 603  : 			kWorkVertex.kPosition.y*=kWorkVertex.kPosition.w;
; 604  : 			kWorkVertex.kPosition.z*=kWorkVertex.kPosition.w;
; 605  : 			kWorkVertex.kPosition.x=(kWorkVertex.kPosition.x+1.0f)*fScreenHalfWidth;
; 606  : 			kWorkVertex.kPosition.y=(kWorkVertex.kPosition.y-1.0f)*fScreenHalfHeight;
; 607  : 			kWorkVertex.dwDiffuse=akSrcVertex[uIndex].dwDiffuse;

  00205	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]

; 608  : 			kWorkVertex.kTexTile.x=pkSrcPosition->x*fTilePatternX;
; 609  : 			kWorkVertex.kTexTile.y=pkSrcPosition->y*fTilePatternY;
; 610  : 			kWorkVertex.kTexAlpha.x=fLocalX*fAlphaPatternX+fAlphaBiasX;
; 611  : 			kWorkVertex.kTexAlpha.y=fLocalY*fAlphaPatternY+fAlphaBiasY;
; 612  : 			kWorkVertex.kTexStaticShadow.x=fLocalX*fShadowPatternX;
; 613  : 			kWorkVertex.kTexStaticShadow.y=fLocalY*fShadowPatternY;
; 614  : 			kWorkVertex.kTexDynamicShadow.x=0.0f;

  00208	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _kWorkVertex$4[ebp+48], 0

; 615  : 			kWorkVertex.kTexDynamicShadow.y=0.0f;

  0020f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _kWorkVertex$4[ebp+52], 0
  00216	f3 0f 10 57 04	 movss	 xmm2, DWORD PTR [edi+4]
  0021b	0f 28 f3	 movaps	 xmm6, xmm3
  0021e	f3 0f 58 b5 58
	ff ff ff	 addss	 xmm6, DWORD PTR _fTerrainBaseX$1$[ebp]
  00226	0f 28 c1	 movaps	 xmm0, xmm1
  00229	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@3acccccd
  00231	f3 0f 59 45 c4	 mulss	 xmm0, DWORD PTR _kWorkVertex$4[ebp]
  00236	0f 28 ea	 movaps	 xmm5, xmm2
  00239	f3 0f 58 ad 54
	ff ff ff	 addss	 xmm5, DWORD PTR _fTerrainBaseY$1$[ebp]
  00241	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@bacccccd
  00249	0f 28 e1	 movaps	 xmm4, xmm1
  0024c	f3 0f 58 c7	 addss	 xmm0, xmm7
  00250	f3 0f 59 65 cc	 mulss	 xmm4, DWORD PTR _kWorkVertex$4[ebp+8]
  00255	f3 0f 11 4d d0	 movss	 DWORD PTR _kWorkVertex$4[ebp+12], xmm1
  0025a	f3 0f 59 4d c8	 mulss	 xmm1, DWORD PTR _kWorkVertex$4[ebp+4]
  0025f	f3 0f 59 85 50
	ff ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfWidth$1$[ebp]
  00267	f3 0f 5c cf	 subss	 xmm1, xmm7
  0026b	f3 0f 11 65 cc	 movss	 DWORD PTR _kWorkVertex$4[ebp+8], xmm4
  00270	f3 0f 11 5d dc	 movss	 DWORD PTR _kWorkVertex$4[ebp+24], xmm3
  00275	f3 0f 11 45 c4	 movss	 DWORD PTR _kWorkVertex$4[ebp], xmm0
  0027a	0f 28 c6	 movaps	 xmm0, xmm6
  0027d	f3 0f 59 85 48
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternX$1$[ebp]
  00285	f3 0f 59 8d 4c
	ff ff ff	 mulss	 xmm1, DWORD PTR _fScreenHalfHeight$1$[ebp]
  0028d	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasX$1$[ebp]
  00295	f3 0f 59 b5 38
	ff ff ff	 mulss	 xmm6, DWORD PTR _fShadowPatternX$1$[ebp]
  0029d	f3 0f 11 4d c8	 movss	 DWORD PTR _kWorkVertex$4[ebp+4], xmm1
  002a2	0f 57 c9	 xorps	 xmm1, xmm1
  002a5	f3 0f 11 55 e0	 movss	 DWORD PTR _kWorkVertex$4[ebp+28], xmm2
  002aa	f3 0f 11 45 e4	 movss	 DWORD PTR _kWorkVertex$4[ebp+32], xmm0
  002af	0f 28 c5	 movaps	 xmm0, xmm5
  002b2	f3 0f 59 85 40
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternY$1$[ebp]
  002ba	f3 0f 59 ad 64
	ff ff ff	 mulss	 xmm5, DWORD PTR _fShadowPatternY$1$[ebp]
  002c2	f3 0f 58 85 3c
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasY$1$[ebp]
  002ca	f3 0f 11 75 ec	 movss	 DWORD PTR _kWorkVertex$4[ebp+40], xmm6
  002cf	f3 0f 11 6d f0	 movss	 DWORD PTR _kWorkVertex$4[ebp+44], xmm5
  002d4	f3 0f 11 45 e8	 movss	 DWORD PTR _kWorkVertex$4[ebp+36], xmm0
  002d9	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR tv951[ebp]
  002e1	f3 0f 5c c4	 subss	 xmm0, xmm4

; 616  : 
; 617  : 			fFogCur=(fFogFar-kWorkVertex.kPosition.z)*fFogLenInv;

  002e5	f3 0f 59 85 5c
	ff ff ff	 mulss	 xmm0, DWORD PTR _fFogLenInv$1$[ebp]

; 618  : 			if (fFogCur<0.0f)

  002ed	0f 2f c8	 comiss	 xmm1, xmm0
  002f0	76 0e		 jbe	 SHORT $LN14@SoftwareTr

; 619  : 				kWorkVertex.dwFog=kWorkVertex.dwDiffuse=0x0000000|(kWorkVertex.dwDiffuse&0xffffff);

  002f2	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  002f8	89 4d d4	 mov	 DWORD PTR _kWorkVertex$4[ebp+16], ecx
  002fb	89 4d d8	 mov	 DWORD PTR _kWorkVertex$4[ebp+20], ecx
  002fe	eb 33		 jmp	 SHORT $LN17@SoftwareTr
$LN14@SoftwareTr:

; 620  : 			else if (fFogCur>1.0f)

  00300	0f 2f c7	 comiss	 xmm0, xmm7
  00303	76 0e		 jbe	 SHORT $LN16@SoftwareTr

; 621  : 				kWorkVertex.dwFog=kWorkVertex.dwDiffuse=0xFF000000|(kWorkVertex.dwDiffuse&0xffffff);

  00305	81 c9 00 00 00
	ff		 or	 ecx, -16777216		; ff000000H
  0030b	89 4d d4	 mov	 DWORD PTR _kWorkVertex$4[ebp+16], ecx
  0030e	89 4d d8	 mov	 DWORD PTR _kWorkVertex$4[ebp+20], ecx
  00311	eb 20		 jmp	 SHORT $LN17@SoftwareTr
$LN16@SoftwareTr:

; 622  : 			else
; 623  : 				kWorkVertex.dwFog=kWorkVertex.dwDiffuse=BYTE(255.0f*fFogCur)<<24|(kWorkVertex.dwDiffuse&0xffffff);

  00313	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0031b	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00321	f3 0f 2c c0	 cvttss2si eax, xmm0
  00325	0f b6 c0	 movzx	 eax, al
  00328	c1 e0 18	 shl	 eax, 24			; 00000018H
  0032b	0b c1		 or	 eax, ecx
  0032d	89 45 d4	 mov	 DWORD PTR _kWorkVertex$4[ebp+16], eax
  00330	89 45 d8	 mov	 DWORD PTR _kWorkVertex$4[ebp+20], eax
$LN17@SoftwareTr:

; 624  : 
; 625  : 			*(akTransVertex+uIndex)=kWorkVertex;

  00333	0f 10 45 c4	 movups	 xmm0, XMMWORD PTR _kWorkVertex$4[ebp]
  00337	83 c7 1c	 add	 edi, 28			; 0000001cH
  0033a	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0033d	0f 10 45 d4	 movups	 xmm0, XMMWORD PTR _kWorkVertex$4[ebp+16]
  00341	0f 11 46 10	 movups	 XMMWORD PTR [esi+16], xmm0
  00345	0f 10 45 e4	 movups	 xmm0, XMMWORD PTR _kWorkVertex$4[ebp+32]
  00349	0f 11 46 20	 movups	 XMMWORD PTR [esi+32], xmm0
  0034d	f3 0f 7e 45 f4	 movq	 xmm0, QWORD PTR _kWorkVertex$4[ebp+48]
  00352	66 0f d6 46 30	 movq	 QWORD PTR [esi+48], xmm0
  00357	83 c6 38	 add	 esi, 56			; 00000038H
  0035a	83 ad 6c ff ff
	ff 01		 sub	 DWORD PTR tv980[ebp], 1
  00361	0f 85 79 fe ff
	ff		 jne	 $LL4@SoftwareTr

; 626  : 		}
; 627  : 	}

  00367	e9 48 01 00 00	 jmp	 $LN32@SoftwareTr
$LN12@SoftwareTr:

; 628  : 	else
; 629  : 	{
; 630  : 		float fLocalX;
; 631  : 		float fLocalY;
; 632  : 
; 633  : 		SoftwareTransformPatch_STLVertex kWorkVertex;
; 634  : 		for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  0036c	8b f7		 mov	 esi, edi
  0036e	c7 85 6c ff ff
	ff 21 01 00 00	 mov	 DWORD PTR tv981[ebp], 289 ; 00000121H
  00378	8b bd 60 ff ff
	ff		 mov	 edi, DWORD PTR _akTransVertex$GSCopy$1$[ebp]
  0037e	66 90		 npad	 2
$LL7@SoftwareTr:

; 635  : 		{
; 636  : 			pkSrcPosition=&akSrcVertex[uIndex].kPosition;
; 637  : 			D3DXVec3Transform(&kWorkVertex.kPosition, pkSrcPosition, &m4Frustum);

  00380	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _m4Frustum$[ebp]
  00386	50		 push	 eax
  00387	56		 push	 esi
  00388	8d 45 c4	 lea	 eax, DWORD PTR _kWorkVertex$3[ebp]
  0038b	50		 push	 eax
  0038c	e8 00 00 00 00	 call	 _D3DXVec3Transform@12

; 638  : 			fLocalX=pkSrcPosition->x+fTerrainBaseX;
; 639  : 			fLocalY=pkSrcPosition->y+fTerrainBaseY;
; 640  : 			kWorkVertex.kPosition.w=1.0f/kWorkVertex.kPosition.w;

  00391	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f800000
  00399	0f 28 ce	 movaps	 xmm1, xmm6

; 641  : 			kWorkVertex.kPosition.x*=kWorkVertex.kPosition.w;
; 642  : 			kWorkVertex.kPosition.y*=kWorkVertex.kPosition.w;

  0039c	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _kWorkVertex$3[ebp+8]
  003a1	f3 0f 5e 4d d0	 divss	 xmm1, DWORD PTR _kWorkVertex$3[ebp+12]

; 643  : 			kWorkVertex.kPosition.z*=kWorkVertex.kPosition.w;
; 644  : 			kWorkVertex.kPosition.x=(kWorkVertex.kPosition.x+1.0f)*fScreenHalfWidth;
; 645  : 			kWorkVertex.kPosition.y=(kWorkVertex.kPosition.y-1.0f)*fScreenHalfHeight;
; 646  : 			kWorkVertex.dwDiffuse=akSrcVertex[uIndex].dwDiffuse;

  003a6	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  003a9	89 45 d4	 mov	 DWORD PTR _kWorkVertex$3[ebp+16], eax

; 647  : 			kWorkVertex.dwFog=0xffffffff;

  003ac	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _kWorkVertex$3[ebp+20], -1
  003b3	f3 0f 10 1e	 movss	 xmm3, DWORD PTR [esi]
  003b7	f3 0f 59 c1	 mulss	 xmm0, xmm1
  003bb	0f 28 eb	 movaps	 xmm5, xmm3
  003be	f3 0f 58 ad 58
	ff ff ff	 addss	 xmm5, DWORD PTR _fTerrainBaseX$1$[ebp]
  003c6	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
  003cb	83 c6 1c	 add	 esi, 28			; 0000001cH
  003ce	f3 0f 11 45 cc	 movss	 DWORD PTR _kWorkVertex$3[ebp+8], xmm0
  003d3	0f 28 e2	 movaps	 xmm4, xmm2
  003d6	0f 28 c1	 movaps	 xmm0, xmm1

; 648  : 			kWorkVertex.kTexTile.x=pkSrcPosition->x*fTilePatternX;

  003d9	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@3acccccd
  003e1	f3 0f 59 45 c4	 mulss	 xmm0, DWORD PTR _kWorkVertex$3[ebp]
  003e6	f3 0f 58 a5 54
	ff ff ff	 addss	 xmm4, DWORD PTR _fTerrainBaseY$1$[ebp]

; 649  : 			kWorkVertex.kTexTile.y=pkSrcPosition->y*fTilePatternY;

  003ee	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@bacccccd
  003f6	f3 0f 58 c6	 addss	 xmm0, xmm6
  003fa	f3 0f 11 4d d0	 movss	 DWORD PTR _kWorkVertex$3[ebp+12], xmm1
  003ff	f3 0f 11 5d dc	 movss	 DWORD PTR _kWorkVertex$3[ebp+24], xmm3
  00404	f3 0f 11 55 e0	 movss	 DWORD PTR _kWorkVertex$3[ebp+28], xmm2
  00409	f3 0f 59 85 50
	ff ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfWidth$1$[ebp]
  00411	f3 0f 11 45 c4	 movss	 DWORD PTR _kWorkVertex$3[ebp], xmm0
  00416	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _kWorkVertex$3[ebp+4]
  0041b	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0041f	0f 57 c9	 xorps	 xmm1, xmm1
  00422	f3 0f 5c c6	 subss	 xmm0, xmm6
  00426	f3 0f 59 85 4c
	ff ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfHeight$1$[ebp]
  0042e	f3 0f 11 45 c8	 movss	 DWORD PTR _kWorkVertex$3[ebp+4], xmm0

; 650  : 			kWorkVertex.kTexAlpha.x=fLocalX*fAlphaPatternX+fAlphaBiasX;

  00433	0f 28 c5	 movaps	 xmm0, xmm5
  00436	f3 0f 59 85 48
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternX$1$[ebp]

; 651  : 			kWorkVertex.kTexAlpha.y=fLocalY*fAlphaPatternY+fAlphaBiasY;
; 652  : 			kWorkVertex.kTexStaticShadow.x=fLocalX*fShadowPatternX;

  0043e	f3 0f 59 ad 38
	ff ff ff	 mulss	 xmm5, DWORD PTR _fShadowPatternX$1$[ebp]
  00446	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasX$1$[ebp]
  0044e	f3 0f 11 6d ec	 movss	 DWORD PTR _kWorkVertex$3[ebp+40], xmm5
  00453	f3 0f 11 45 e4	 movss	 DWORD PTR _kWorkVertex$3[ebp+32], xmm0
  00458	0f 28 c4	 movaps	 xmm0, xmm4
  0045b	f3 0f 59 85 40
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternY$1$[ebp]

; 653  : 			kWorkVertex.kTexStaticShadow.y=fLocalY*fShadowPatternY;

  00463	f3 0f 59 a5 64
	ff ff ff	 mulss	 xmm4, DWORD PTR _fShadowPatternY$1$[ebp]
  0046b	f3 0f 58 85 3c
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasY$1$[ebp]
  00473	f3 0f 11 65 f0	 movss	 DWORD PTR _kWorkVertex$3[ebp+44], xmm4
  00478	f3 0f 11 45 e8	 movss	 DWORD PTR _kWorkVertex$3[ebp+36], xmm0

; 654  : 			kWorkVertex.kTexDynamicShadow.x=0.0f;
; 655  : 			kWorkVertex.kTexDynamicShadow.y=0.0f;
; 656  : 
; 657  : 			*(akTransVertex+uIndex)=kWorkVertex;

  0047d	0f 10 45 c4	 movups	 xmm0, XMMWORD PTR _kWorkVertex$3[ebp]
  00481	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  00484	0f 10 45 d4	 movups	 xmm0, XMMWORD PTR _kWorkVertex$3[ebp+16]
  00488	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  0048c	0f 10 45 e4	 movups	 xmm0, XMMWORD PTR _kWorkVertex$3[ebp+32]
  00490	0f 11 47 20	 movups	 XMMWORD PTR [edi+32], xmm0
  00494	0f 57 c0	 xorps	 xmm0, xmm0
  00497	0f 14 c1	 unpcklps xmm0, xmm1
  0049a	66 0f d6 47 30	 movq	 QWORD PTR [edi+48], xmm0
  0049f	83 c7 38	 add	 edi, 56			; 00000038H
  004a2	83 ad 6c ff ff
	ff 01		 sub	 DWORD PTR tv981[ebp], 1
  004a9	66 0f d6 45 f4	 movq	 QWORD PTR _kWorkVertex$3[ebp+48], xmm0
  004ae	0f 85 cc fe ff
	ff		 jne	 $LL7@SoftwareTr
$LN32@SoftwareTr:

; 658  : 		}
; 659  : 	}
; 660  : 
; 661  : 	if (isDynamicShadow)

  004b4	80 7d 20 00	 cmp	 BYTE PTR _isDynamicShadow$[ebp], 0
  004b8	8b b5 68 ff ff
	ff		 mov	 esi, DWORD PTR _rkTPRS$GSCopy$1$[ebp]
  004be	8b bd 34 ff ff
	ff		 mov	 edi, DWORD PTR _akSrcVertex$1$[ebp]
  004c4	74 70		 je	 SHORT $LN9@SoftwareTr

; 662  : 	{
; 663  : 		D3DXMATRIX m4DynamicShadow=rkTPRS.m_m4DynamicShadow;

  004c6	0f 10 86 80 00
	00 00		 movups	 xmm0, XMMWORD PTR [esi+128]
  004cd	c7 85 68 ff ff
	ff 21 01 00 00	 mov	 DWORD PTR tv979[ebp], 289 ; 00000121H
  004d7	0f 11 45 bc	 movups	 XMMWORD PTR _m4DynamicShadow$2[ebp], xmm0
  004db	0f 10 86 90 00
	00 00		 movups	 xmm0, XMMWORD PTR [esi+144]
  004e2	0f 11 45 cc	 movups	 XMMWORD PTR _m4DynamicShadow$2[ebp+16], xmm0
  004e6	0f 10 86 a0 00
	00 00		 movups	 xmm0, XMMWORD PTR [esi+160]
  004ed	0f 11 45 dc	 movups	 XMMWORD PTR _m4DynamicShadow$2[ebp+32], xmm0
  004f1	0f 10 86 b0 00
	00 00		 movups	 xmm0, XMMWORD PTR [esi+176]
  004f8	8b b5 60 ff ff
	ff		 mov	 esi, DWORD PTR _akTransVertex$GSCopy$1$[ebp]
  004fe	83 c6 34	 add	 esi, 52			; 00000034H
  00501	0f 11 45 ec	 movups	 XMMWORD PTR _m4DynamicShadow$2[ebp+48], xmm0
$LL10@SoftwareTr:

; 664  : 
; 665  : 		D3DXVECTOR3 v3Shadow;
; 666  : 		for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)
; 667  : 		{
; 668  : 			D3DXVec3TransformCoord(&v3Shadow, &akSrcVertex[uIndex].kPosition, &m4DynamicShadow);

  00505	8d 45 bc	 lea	 eax, DWORD PTR _m4DynamicShadow$2[ebp]
  00508	50		 push	 eax
  00509	57		 push	 edi
  0050a	8d 45 b0	 lea	 eax, DWORD PTR _v3Shadow$1[ebp]
  0050d	50		 push	 eax
  0050e	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 669  : 			akTransVertex[uIndex].kTexDynamicShadow.x=v3Shadow.x;

  00513	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _v3Shadow$1[ebp]
  00518	8d 76 38	 lea	 esi, DWORD PTR [esi+56]
  0051b	f3 0f 11 46 c4	 movss	 DWORD PTR [esi-60], xmm0
  00520	83 c7 1c	 add	 edi, 28			; 0000001cH
  00523	83 ad 68 ff ff
	ff 01		 sub	 DWORD PTR tv979[ebp], 1

; 670  : 			akTransVertex[uIndex].kTexDynamicShadow.y=v3Shadow.y;

  0052a	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _v3Shadow$1[ebp+4]
  0052f	f3 0f 11 46 c8	 movss	 DWORD PTR [esi-56], xmm0
  00534	75 cf		 jne	 SHORT $LL10@SoftwareTr
$LN9@SoftwareTr:

; 671  : 		}
; 672  : 	}
; 673  : 
; 674  : 	return true;
; 675  : }

  00536	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00539	b0 01		 mov	 al, 1
  0053b	5f		 pop	 edi
  0053c	33 cd		 xor	 ecx, ebp
  0053e	5e		 pop	 esi
  0053f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00544	8b e5		 mov	 esp, ebp
  00546	5d		 pop	 ebp
  00547	c2 1c 00	 ret	 28			; 0000001cH
?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_SetTransform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z
_TEXT	SEGMENT
_dwR$1$ = -248						; size = 4
_this$GSCopy$1$ = -244					; size = 4
$T1 = -244						; size = 4
_dwB$1$ = -240						; size = 4
_uScreenWidth$ = -240					; size = 4
_dwG$1$ = -236						; size = 4
_uScreenHeight$ = -236					; size = 4
_m4View$ = -232						; size = 64
$T2 = -168						; size = 64
_m4Proj$ = -104						; size = 64
_kFogFarVector$ = -40					; size = 12
_kFogNearVector$ = -28					; size = 12
$T3 = -16						; size = 12
$T4 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_rkTPRS$ = 8						; size = 4
?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline, COMDAT
; _this$ = ecx

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _rkTPRS$[ebp]
  00017	57		 push	 edi

; 502  : 	memset(&rkTPRS, 0, sizeof(rkTPRS));

  00018	68 98 01 00 00	 push	 408			; 00000198H
  0001d	8b f9		 mov	 edi, ecx
  0001f	6a 00		 push	 0
  00021	56		 push	 esi
  00022	89 bd 0c ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00028	e8 00 00 00 00	 call	 _memset

; 503  : 
; 504  : 	if (mc_pEnvironmentData)

  0002d	8b 7f 3c	 mov	 edi, DWORD PTR [edi+60]
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0003b	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  00043	85 ff		 test	 edi, edi
  00045	0f 84 6e 01 00
	00		 je	 $LN2@SoftwareTr
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0004b	f3 0f 10 87 2c
	01 00 00	 movss	 xmm0, DWORD PTR [edi+300]
  00053	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  0005b	0f 2f c1	 comiss	 xmm0, xmm1
  0005e	0f 57 c9	 xorps	 xmm1, xmm1
  00061	72 0c		 jb	 SHORT $LN9@SoftwareTr
  00063	c7 85 08 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR _dwR$1$[ebp], 255 ; 000000ffH
  0006d	eb 37		 jmp	 SHORT $LN8@SoftwareTr
$LN9@SoftwareTr:
  0006f	0f 2f c8	 comiss	 xmm1, xmm0
  00072	72 0c		 jb	 SHORT $LN7@SoftwareTr
  00074	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwR$1$[ebp], 0
  0007e	eb 26		 jmp	 SHORT $LN8@SoftwareTr
$LN7@SoftwareTr:
  00080	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00084	f3 0f 58 c2	 addss	 xmm0, xmm2
  00088	e8 00 00 00 00	 call	 __ftoui3
  0008d	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  00095	0f 57 c9	 xorps	 xmm1, xmm1
  00098	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  000a0	89 85 08 ff ff
	ff		 mov	 DWORD PTR _dwR$1$[ebp], eax
$LN8@SoftwareTr:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  000a6	f3 0f 10 87 30
	01 00 00	 movss	 xmm0, DWORD PTR [edi+304]
  000ae	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000b5	72 0c		 jb	 SHORT $LN13@SoftwareTr
  000b7	c7 85 14 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR _dwG$1$[ebp], 255 ; 000000ffH
  000c1	eb 24		 jmp	 SHORT $LN12@SoftwareTr
$LN13@SoftwareTr:
  000c3	0f 2f c8	 comiss	 xmm1, xmm0
  000c6	72 0c		 jb	 SHORT $LN11@SoftwareTr
  000c8	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwG$1$[ebp], 0
  000d2	eb 13		 jmp	 SHORT $LN12@SoftwareTr
$LN11@SoftwareTr:
  000d4	f3 0f 59 c3	 mulss	 xmm0, xmm3
  000d8	f3 0f 58 c2	 addss	 xmm0, xmm2
  000dc	e8 00 00 00 00	 call	 __ftoui3
  000e1	89 85 14 ff ff
	ff		 mov	 DWORD PTR _dwG$1$[ebp], eax
$LN12@SoftwareTr:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  000e7	f3 0f 10 87 34
	01 00 00	 movss	 xmm0, DWORD PTR [edi+308]
  000ef	0f 57 c9	 xorps	 xmm1, xmm1
  000f2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000f9	72 0c		 jb	 SHORT $LN17@SoftwareTr
  000fb	c7 85 10 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR _dwB$1$[ebp], 255 ; 000000ffH
  00105	eb 2f		 jmp	 SHORT $LN16@SoftwareTr
$LN17@SoftwareTr:
  00107	0f 2f c8	 comiss	 xmm1, xmm0
  0010a	72 0c		 jb	 SHORT $LN15@SoftwareTr
  0010c	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwB$1$[ebp], 0
  00116	eb 1e		 jmp	 SHORT $LN16@SoftwareTr
$LN15@SoftwareTr:
  00118	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00120	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00128	e8 00 00 00 00	 call	 __ftoui3
  0012d	89 85 10 ff ff
	ff		 mov	 DWORD PTR _dwB$1$[ebp], eax
  00133	0f 57 c9	 xorps	 xmm1, xmm1
$LN16@SoftwareTr:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00136	f3 0f 10 87 38
	01 00 00	 movss	 xmm0, DWORD PTR [edi+312]
  0013e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00145	72 07		 jb	 SHORT $LN21@SoftwareTr
  00147	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0014c	eb 1e		 jmp	 SHORT $LN20@SoftwareTr
$LN21@SoftwareTr:
  0014e	0f 2f c8	 comiss	 xmm1, xmm0
  00151	72 04		 jb	 SHORT $LN19@SoftwareTr
  00153	33 c0		 xor	 eax, eax
  00155	eb 15		 jmp	 SHORT $LN20@SoftwareTr
$LN19@SoftwareTr:
  00157	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0015f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00167	e8 00 00 00 00	 call	 __ftoui3
$LN20@SoftwareTr:
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 507  : 		rkTPRS.m_fFogNearDistance = mc_pEnvironmentData->GetFogNearDistance();

  0016c	8b bd 0c ff ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00172	c1 e0 08	 shl	 eax, 8
  00175	0b 85 08 ff ff
	ff		 or	 eax, DWORD PTR _dwR$1$[ebp]
  0017b	c1 e0 08	 shl	 eax, 8
  0017e	0b 85 14 ff ff
	ff		 or	 eax, DWORD PTR _dwG$1$[ebp]
  00184	c1 e0 08	 shl	 eax, 8
  00187	0b 85 10 ff ff
	ff		 or	 eax, DWORD PTR _dwB$1$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 506  : 		rkTPRS.m_dwFogColor = mc_pEnvironmentData->FogColor;

  0018d	89 86 78 01 00
	00		 mov	 DWORD PTR [esi+376], eax

; 507  : 		rkTPRS.m_fFogNearDistance = mc_pEnvironmentData->GetFogNearDistance();

  00193	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  00196	e8 00 00 00 00	 call	 ?GetFogNearDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogNearDistance
  0019b	d9 9e 84 01 00
	00		 fstp	 DWORD PTR [esi+388]

; 508  : 		rkTPRS.m_fFogFarDistance = mc_pEnvironmentData->GetFogFarDistance();

  001a1	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  001a4	e8 00 00 00 00	 call	 ?GetFogFarDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogFarDistance
  001a9	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR $T1[ebp]

; 509  : 	}

  001af	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR $T1[ebp]
  001b7	eb 22		 jmp	 SHORT $LN3@SoftwareTr
$LN2@SoftwareTr:

; 510  : 	else
; 511  : 	{
; 512  : 		rkTPRS.m_dwFogColor = 0xffffffff;
; 513  : 		rkTPRS.m_fFogNearDistance = 5000.0f;
; 514  : 		rkTPRS.m_fFogFarDistance = 10000.0f;

  001b9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@461c4000
  001c1	8b bd 0c ff ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  001c7	c7 86 78 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+376], -1
  001d1	c7 86 84 01 00
	00 00 40 9c 45	 mov	 DWORD PTR [esi+388], 1167867904 ; 459c4000H
$LN3@SoftwareTr:

; 515  : 	}
; 516  : 
; 517  : 	UINT uScreenWidth;
; 518  : 	UINT uScreenHeight;
; 519  : 	CScreen::GetBackBufferSize(&uScreenWidth, &uScreenHeight);

  001db	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _uScreenHeight$[ebp]
  001e1	f3 0f 11 86 88
	01 00 00	 movss	 DWORD PTR [esi+392], xmm0
  001e9	50		 push	 eax
  001ea	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _uScreenWidth$[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?GetBackBufferSize@CGraphicBase@@SAXPAI0@Z ; CGraphicBase::GetBackBufferSize

; 520  : 
; 521  : 	rkTPRS.m_fScreenHalfWidth = +float(uScreenWidth) / 2.0f;

  001f6	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _uScreenWidth$[ebp]
  001fc	83 c4 08	 add	 esp, 8
  001ff	66 0f 6e c0	 movd	 xmm0, eax
  00203	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00207	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0020a	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 522  : 	rkTPRS.m_fScreenHalfHeight = -float(uScreenHeight) / 2.0f;

  00213	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _uScreenHeight$[ebp]
  00219	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0021d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00225	f3 0f 11 86 7c
	01 00 00	 movss	 DWORD PTR [esi+380], xmm0
  0022d	66 0f 6e c0	 movd	 xmm0, eax
  00231	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00235	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00238	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 523  : 
; 524  : 	STATEMANAGER.GetLight(0, &rkTPRS.m_kLight);

  00241	8d 86 c0 00 00
	00		 lea	 eax, DWORD PTR [esi+192]
  00247	50		 push	 eax
  00248	6a 00		 push	 0
  0024a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0024e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00255	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0025d	f3 0f 11 86 80
	01 00 00	 movss	 DWORD PTR [esi+384], xmm0
  00265	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0026b	e8 00 00 00 00	 call	 ?GetLight@CStateManager@@QAEXKPAU_D3DLIGHT8@@@Z ; CStateManager::GetLight

; 525  : 	STATEMANAGER.GetMaterial(&rkTPRS.m_kMtrl);

  00270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00276	8d 86 28 01 00
	00		 lea	 eax, DWORD PTR [esi+296]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?GetMaterial@CStateManager@@QAEXPAU_D3DMATERIAL8@@@Z ; CStateManager::GetMaterial

; 526  : 
; 527  : 	D3DXMATRIX m4View;STATEMANAGER.GetTransform(D3DTS_VIEW, &m4View);

  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00288	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _m4View$[ebp]
  0028e	50		 push	 eax
  0028f	6a 02		 push	 2
  00291	e8 00 00 00 00	 call	 ?GetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PAU_D3DMATRIX@@@Z ; CStateManager::GetTransform

; 528  : 	D3DXMATRIX m4Proj;STATEMANAGER.GetTransform(D3DTS_PROJECTION, &m4Proj);

  00296	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0029c	8d 45 98	 lea	 eax, DWORD PTR _m4Proj$[ebp]
  0029f	50		 push	 eax
  002a0	6a 03		 push	 3
  002a2	e8 00 00 00 00	 call	 ?GetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PAU_D3DMATRIX@@@Z ; CStateManager::GetTransform

; 529  : 
; 530  : 	D3DXMatrixMultiply(&rkTPRS.m_m4Frustum, &m4View, &m4Proj);

  002a7	8d 45 98	 lea	 eax, DWORD PTR _m4Proj$[ebp]
  002aa	50		 push	 eax
  002ab	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _m4View$[ebp]
  002b1	50		 push	 eax
  002b2	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 531  : 
; 532  : 	rkTPRS.m_v3Player.x = +m_v3Player.x;

  002bb	8b 87 a8 0e 00
	00		 mov	 eax, DWORD PTR [edi+3752]
  002c1	89 86 6c 01 00
	00		 mov	 DWORD PTR [esi+364], eax

; 533  : 	rkTPRS.m_v3Player.y = -m_v3Player.y;

  002c7	f3 0f 10 87 ac
	0e 00 00	 movss	 xmm0, DWORD PTR [edi+3756]
  002cf	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002d6	f3 0f 11 86 70
	01 00 00	 movss	 DWORD PTR [esi+368], xmm0

; 534  : 	rkTPRS.m_v3Player.z = +m_v3Player.z;

  002de	8b 87 b0 0e 00
	00		 mov	 eax, DWORD PTR [edi+3760]

; 536  : 	rkTPRS.m_m4Proj = m4Proj;

  002e4	0f 10 45 98	 movups	 xmm0, XMMWORD PTR _m4Proj$[ebp]
  002e8	89 86 74 01 00
	00		 mov	 DWORD PTR [esi+372], eax

; 537  : 	rkTPRS.m_m4DynamicShadow = m_matLightView * m_matDynamicShadowScale;

  002ee	8d 87 88 08 00
	00		 lea	 eax, DWORD PTR [edi+2184]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  002f4	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 536  : 	rkTPRS.m_m4Proj = m4Proj;

  002f5	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 537  : 	rkTPRS.m_m4DynamicShadow = m_matLightView * m_matDynamicShadowScale;

  002f8	8d 87 c8 08 00
	00		 lea	 eax, DWORD PTR [edi+2248]
  002fe	0f 10 45 a8	 movups	 xmm0, XMMWORD PTR _m4Proj$[ebp+16]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00302	50		 push	 eax
  00303	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 536  : 	rkTPRS.m_m4Proj = m4Proj;

  00309	0f 11 46 10	 movups	 XMMWORD PTR [esi+16], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  0030d	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 536  : 	rkTPRS.m_m4Proj = m4Proj;

  0030e	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR _m4Proj$[ebp+32]
  00312	0f 11 46 20	 movups	 XMMWORD PTR [esi+32], xmm0
  00316	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR _m4Proj$[ebp+48]
  0031a	0f 11 46 30	 movups	 XMMWORD PTR [esi+48], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  0031e	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 537  : 	rkTPRS.m_m4DynamicShadow = m_matLightView * m_matDynamicShadowScale;

  00323	0f 10 85 58 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0032a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 537  : 	rkTPRS.m_m4DynamicShadow = m_matLightView * m_matDynamicShadowScale;

  00331	0f 11 86 80 00
	00 00		 movups	 XMMWORD PTR [esi+128], xmm0
  00338	0f 10 85 68 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp+16]
  0033f	0f 11 86 90 00
	00 00		 movups	 XMMWORD PTR [esi+144], xmm0
  00346	0f 10 85 78 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp+32]
  0034d	0f 11 86 a0 00
	00 00		 movups	 XMMWORD PTR [esi+160], xmm0
  00354	0f 10 45 88	 movups	 xmm0, XMMWORD PTR $T2[ebp+48]
  00358	0f 11 86 b0 00
	00 00		 movups	 XMMWORD PTR [esi+176], xmm0

; 540  : 	D3DXVec3TransformCoord(&kFogNearVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogNearDistance), &rkTPRS.m_m4Proj);

  0035f	f3 0f 10 86 84
	01 00 00	 movss	 xmm0, DWORD PTR [esi+388]
  00367	8d 45 f0	 lea	 eax, DWORD PTR $T4[ebp]
  0036a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00371	56		 push	 esi
  00372	50		 push	 eax
  00373	8d 45 e4	 lea	 eax, DWORD PTR _kFogNearVector$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00376	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 540  : 	D3DXVec3TransformCoord(&kFogNearVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogNearDistance), &rkTPRS.m_m4Proj);

  0037d	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0037e	f3 0f 11 45 f8	 movss	 DWORD PTR $T4[ebp+8], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 540  : 	D3DXVec3TransformCoord(&kFogNearVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogNearDistance), &rkTPRS.m_m4Proj);

  00383	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 543  : 	D3DXVec3TransformCoord(&kFogFarVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogFarDistance), &rkTPRS.m_m4Proj);

  00388	f3 0f 10 86 88
	01 00 00	 movss	 xmm0, DWORD PTR [esi+392]
  00390	8d 45 f0	 lea	 eax, DWORD PTR $T3[ebp]
  00393	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0039a	56		 push	 esi
  0039b	50		 push	 eax
  0039c	8d 45 d8	 lea	 eax, DWORD PTR _kFogFarVector$[ebp]
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0039f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 543  : 	D3DXVec3TransformCoord(&kFogFarVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogFarDistance), &rkTPRS.m_m4Proj);

  003a6	50		 push	 eax
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 181  :     y = fy;

  003a7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0

; 182  :     z = fz;

  003ae	f3 0f 11 45 f8	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 543  : 	D3DXVec3TransformCoord(&kFogFarVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogFarDistance), &rkTPRS.m_m4Proj);

  003b3	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 544  : 
; 545  : 	float fFogNear = kFogNearVector.z;
; 546  : 	float fFogFar = kFogFarVector.z;
; 547  : 	float fFogLenInv = 1.0f / (fFogFar-fFogNear);
; 548  : 
; 549  : 	rkTPRS.m_fFogNearTransZ = fFogNear;

  003b8	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _kFogNearVector$[ebp+8]

; 550  : 	rkTPRS.m_fFogFarTransZ = fFogFar;

  003bd	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _kFogFarVector$[ebp+8]
  003c2	f3 0f 11 86 90
	01 00 00	 movss	 DWORD PTR [esi+400], xmm0
  003ca	f3 0f 5c c1	 subss	 xmm0, xmm1
  003ce	f3 0f 11 8e 8c
	01 00 00	 movss	 DWORD PTR [esi+396], xmm1
  003d6	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000

; 551  : 	rkTPRS.m_fFogLenInv = fFogLenInv;
; 552  : 
; 553  : }

  003de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e1	5f		 pop	 edi
  003e2	f3 0f 5e c8	 divss	 xmm1, xmm0
  003e6	33 cd		 xor	 ecx, ebp
  003e8	f3 0f 11 8e 94
	01 00 00	 movss	 DWORD PTR [esi+404], xmm1
  003f0	5e		 pop	 esi
  003f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f6	8b e5		 mov	 esp, ebp
  003f8	5d		 pop	 ebp
  003f9	c2 04 00	 ret	 4
?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_Destroy, COMDAT
; _this$ = ecx

; 784  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 785  : 	{
; 786  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  00005	bf 08 00 00 00	 mov	 edi, 8
  0000a	8d b3 c0 09 00
	00		 lea	 esi, DWORD PTR [ebx+2496]
$LL4@SoftwareTr:

; 787  : 		{
; 788  : 			if (m_kSTPD.m_pkVBSplat[uIndex])

  00010	8b 16		 mov	 edx, DWORD PTR [esi]
  00012	85 d2		 test	 edx, edx
  00014	74 06		 je	 SHORT $LN2@SoftwareTr

; 789  : 				m_kSTPD.m_pkVBSplat[uIndex]->Release();

  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	52		 push	 edx
  00019	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@SoftwareTr:

; 785  : 	{
; 786  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  0001c	83 c6 04	 add	 esi, 4
  0001f	83 ef 01	 sub	 edi, 1
  00022	75 ec		 jne	 SHORT $LL4@SoftwareTr

; 790  : 		}
; 791  : 	}
; 792  : 
; 793  : 	{
; 794  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)

  00024	8d b3 e0 09 00
	00		 lea	 esi, DWORD PTR [ebx+2528]
  0002a	bf 08 00 00 00	 mov	 edi, 8
  0002f	90		 npad	 1
$LL7@SoftwareTr:

; 795  : 		{
; 796  : 			if (m_kSTPD.m_pkVBNone[uIndex])

  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00032	85 c9		 test	 ecx, ecx
  00034	74 06		 je	 SHORT $LN5@SoftwareTr

; 797  : 				m_kSTPD.m_pkVBNone[uIndex]->Release();

  00036	8b 01		 mov	 eax, DWORD PTR [ecx]
  00038	51		 push	 ecx
  00039	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@SoftwareTr:

; 790  : 		}
; 791  : 	}
; 792  : 
; 793  : 	{
; 794  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)

  0003c	83 c6 04	 add	 esi, 4
  0003f	83 ef 01	 sub	 edi, 1
  00042	75 ec		 jne	 SHORT $LL7@SoftwareTr

; 798  : 		}
; 799  : 	}
; 800  : 	__SoftwareTransformPatch_Initialize();

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	8b cb		 mov	 ecx, ebx
  00048	5b		 pop	 ebx
  00049	e9 00 00 00 00	 jmp	 ?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Initialize
?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_Create, COMDAT
; _this$ = ecx

; 748  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 749  : 	{
; 750  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  00005	33 f6		 xor	 esi, esi
  00007	8d bb c0 09 00
	00		 lea	 edi, DWORD PTR [ebx+2496]
  0000d	0f 1f 00	 npad	 3
$LL4@SoftwareTr:

; 751  : 		{
; 752  : 			assert(NULL==m_kSTPD.m_pkVBSplat[uIndex]);
; 753  : 			if (FAILED(

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00015	57		 push	 edi
  00016	6a 02		 push	 2
  00018	68 c4 02 00 00	 push	 708			; 000002c4H
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	68 08 02 00 00	 push	 520			; 00000208H
  00024	68 28 2d 00 00	 push	 11560			; 00002d28H
  00029	50		 push	 eax
  0002a	ff 52 5c	 call	 DWORD PTR [edx+92]
  0002d	85 c0		 test	 eax, eax
  0002f	78 3e		 js	 SHORT $LN14@SoftwareTr

; 749  : 	{
; 750  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  00031	46		 inc	 esi
  00032	83 c7 04	 add	 edi, 4
  00035	83 fe 08	 cmp	 esi, 8
  00038	75 d6		 jne	 SHORT $LL4@SoftwareTr

; 754  : 				ms_lpd3dDevice->CreateVertexBuffer(
; 755  : 					sizeof(SoftwareTransformPatch_SSplatVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT,
; 756  : 					D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY,
; 757  : 					D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX2,
; 758  : 					D3DPOOL_SYSTEMMEM,
; 759  : 					&m_kSTPD.m_pkVBSplat[uIndex]
; 760  : 				)
; 761  : 			)) return false;
; 762  : 		}
; 763  : 	}
; 764  : 
; 765  : 	{
; 766  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)

  0003a	33 f6		 xor	 esi, esi
  0003c	8d bb e0 09 00
	00		 lea	 edi, DWORD PTR [ebx+2528]
$LL7@SoftwareTr:

; 767  : 		{
; 768  : 			assert(NULL==m_kSTPD.m_pkVBNone[uIndex]);
; 769  : 			if (FAILED(

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00047	57		 push	 edi
  00048	6a 02		 push	 2
  0004a	6a 04		 push	 4
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	68 08 02 00 00	 push	 520			; 00000208H
  00053	68 10 12 00 00	 push	 4624			; 00001210H
  00058	50		 push	 eax
  00059	ff 51 5c	 call	 DWORD PTR [ecx+92]
  0005c	85 c0		 test	 eax, eax
  0005e	78 0f		 js	 SHORT $LN14@SoftwareTr

; 754  : 				ms_lpd3dDevice->CreateVertexBuffer(
; 755  : 					sizeof(SoftwareTransformPatch_SSplatVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT,
; 756  : 					D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY,
; 757  : 					D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX2,
; 758  : 					D3DPOOL_SYSTEMMEM,
; 759  : 					&m_kSTPD.m_pkVBSplat[uIndex]
; 760  : 				)
; 761  : 			)) return false;
; 762  : 		}
; 763  : 	}
; 764  : 
; 765  : 	{
; 766  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)

  00060	46		 inc	 esi
  00061	83 c7 04	 add	 edi, 4
  00064	83 fe 08	 cmp	 esi, 8
  00067	75 d9		 jne	 SHORT $LL7@SoftwareTr

; 770  : 				ms_lpd3dDevice->CreateVertexBuffer(
; 771  : 					sizeof(SoftwareTransformPatch_STVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT,
; 772  : 					D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY,
; 773  : 					D3DFVF_XYZRHW,
; 774  : 					D3DPOOL_SYSTEMMEM,
; 775  : 					&m_kSTPD.m_pkVBNone[uIndex]
; 776  : 				)
; 777  : 			)) return false;
; 778  : 		}
; 779  : 	}
; 780  : 	return true;
; 781  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	b0 01		 mov	 al, 1
  0006d	5b		 pop	 ebx
  0006e	c3		 ret	 0
$LN14@SoftwareTr:
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	32 c0		 xor	 al, al
  00073	5b		 pop	 ebx
  00074	c3		 ret	 0
?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_Initialize, COMDAT
; _this$ = ecx

; 732  : {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 733  : 	{
; 734  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  00003	0f 11 81 c0 09
	00 00		 movups	 XMMWORD PTR [ecx+2496], xmm0
  0000a	0f 11 81 d0 09
	00 00		 movups	 XMMWORD PTR [ecx+2512], xmm0

; 735  : 			m_kSTPD.m_pkVBSplat[uIndex]=NULL;
; 736  : 		m_kSTPD.m_dwSplatPos=0;

  00011	c7 81 00 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2560], 0
  0001b	0f 11 81 e0 09
	00 00		 movups	 XMMWORD PTR [ecx+2528], xmm0
  00022	0f 11 81 f0 09
	00 00		 movups	 XMMWORD PTR [ecx+2544], xmm0

; 737  : 	}
; 738  : 
; 739  : 	{
; 740  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)
; 741  : 			m_kSTPD.m_pkVBNone[uIndex]=NULL;
; 742  : 		m_kSTPD.m_dwNonePos=0;

  00029	c7 81 04 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2564], 0

; 743  : 	}
; 744  : }

  00033	c3		 ret	 0
?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
_dwFogEnable$ = 8					; size = 4
?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 470  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  00004	6a 01		 push	 1
  00006	8b f1		 mov	 esi, ecx
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0000e	68 89 00 00 00	 push	 137			; 00000089H
  00013	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 471  : 
; 472  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0001e	6a 02		 push	 2
  00020	6a 02		 push	 2
  00022	6a 00		 push	 0
  00024	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 473  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0002f	6a 01		 push	 1
  00031	6a 03		 push	 3
  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 474  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00040	6a 04		 push	 4
  00042	6a 01		 push	 1
  00044	6a 00		 push	 0
  00046	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 475  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00051	6a 02		 push	 2
  00053	6a 05		 push	 5
  00055	6a 00		 push	 0
  00057	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 476  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00062	6a 02		 push	 2
  00064	6a 04		 push	 4
  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 477  : 
; 478  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00073	6a 01		 push	 1
  00075	6a 02		 push	 2
  00077	6a 01		 push	 1
  00079	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 479  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00084	6a 02		 push	 2
  00086	6a 01		 push	 1
  00088	6a 01		 push	 1
  0008a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 480  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00095	6a 02		 push	 2
  00097	6a 05		 push	 5
  00099	6a 01		 push	 1
  0009b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 481  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000a6	6a 02		 push	 2
  000a8	6a 04		 push	 4
  000aa	6a 01		 push	 1
  000ac	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 482  : 
; 483  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  000b1	ff 75 08	 push	 DWORD PTR _dwFogEnable$[ebp]
  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ba	6a 1c		 push	 28			; 0000001cH
  000bc	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000c1	8b 8e 94 09 00
	00		 mov	 ecx, DWORD PTR [esi+2452]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4138 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  000c7	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000c9	8b 96 90 09 00
	00		 mov	 edx, DWORD PTR [esi+2448]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4138 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  000cf	2b c2		 sub	 eax, edx
  000d1	ff 75 08	 push	 DWORD PTR $T1[ebp]
  000d4	c1 f8 02	 sar	 eax, 2
  000d7	50		 push	 eax
  000d8	51		 push	 ecx
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 487  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 4138 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  000e5	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 487  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  000e8	6a 3c		 push	 60			; 0000003cH
  000ea	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 488  : 
; 489  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f5	6a 1b		 push	 27			; 0000001bH
  000f7	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 490  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);

  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00102	6a 0f		 push	 15			; 0000000fH
  00104	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 491  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAREF);

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0010f	6a 18		 push	 24			; 00000018H
  00111	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 492  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAFUNC);

  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0011c	6a 19		 push	 25			; 00000019H
  0011e	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 493  : 
; 494  : 	STATEMANAGER.RestoreRenderState(D3DRS_SOFTWAREVERTEXPROCESSING);

  00123	5e		 pop	 esi
  00124	c7 45 08 99 00
	00 00		 mov	 DWORD PTR _dwFogEnable$[ebp], 153 ; 00000099H
  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 495  : 
; 496  : 	// Render State & TextureStageState
; 497  : 	//////////////////////////////////////////////////////////////////////////
; 498  : }

  00131	5d		 pop	 ebp

; 493  : 
; 494  : 	STATEMANAGER.RestoreRenderState(D3DRS_SOFTWAREVERTEXPROCESSING);

  00132	e9 00 00 00 00	 jmp	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState
?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
_dwG$1$ = -8						; size = 4
_dwR$1$ = -4						; size = 4
?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 415  : 	DWORD dwFogColor=0xffffffff;

  0000b	83 cf ff	 or	 edi, -1
  0000e	89 5d f4	 mov	 DWORD PTR _this$1$[ebp], ebx

; 416  : 	if (mc_pEnvironmentData)

  00011	8b 73 3c	 mov	 esi, DWORD PTR [ebx+60]
  00014	85 f6		 test	 esi, esi
  00016	0f 84 20 01 00
	00		 je	 $LN2@SoftwareTr
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0001c	f3 0f 10 86 2c
	01 00 00	 movss	 xmm0, DWORD PTR [esi+300]
  00024	0f 57 c9	 xorps	 xmm1, xmm1
  00027	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0002e	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00036	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  0003e	72 09		 jb	 SHORT $LN9@SoftwareTr
  00040	c7 45 fc ff 00
	00 00		 mov	 DWORD PTR _dwR$1$[ebp], 255 ; 000000ffH
  00047	eb 31		 jmp	 SHORT $LN8@SoftwareTr
$LN9@SoftwareTr:
  00049	0f 2f c8	 comiss	 xmm1, xmm0
  0004c	72 09		 jb	 SHORT $LN7@SoftwareTr
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwR$1$[ebp], 0
  00055	eb 23		 jmp	 SHORT $LN8@SoftwareTr
$LN7@SoftwareTr:
  00057	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0005b	f3 0f 58 c4	 addss	 xmm0, xmm4
  0005f	e8 00 00 00 00	 call	 __ftoui3
  00064	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  0006c	0f 57 c9	 xorps	 xmm1, xmm1
  0006f	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00077	89 45 fc	 mov	 DWORD PTR _dwR$1$[ebp], eax
$LN8@SoftwareTr:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0007a	f3 0f 10 86 30
	01 00 00	 movss	 xmm0, DWORD PTR [esi+304]
  00082	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00089	72 09		 jb	 SHORT $LN13@SoftwareTr
  0008b	c7 45 f8 ff 00
	00 00		 mov	 DWORD PTR _dwG$1$[ebp], 255 ; 000000ffH
  00092	eb 1e		 jmp	 SHORT $LN12@SoftwareTr
$LN13@SoftwareTr:
  00094	0f 2f c8	 comiss	 xmm1, xmm0
  00097	72 09		 jb	 SHORT $LN11@SoftwareTr
  00099	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwG$1$[ebp], 0
  000a0	eb 10		 jmp	 SHORT $LN12@SoftwareTr
$LN11@SoftwareTr:
  000a2	f3 0f 59 c3	 mulss	 xmm0, xmm3
  000a6	f3 0f 58 c4	 addss	 xmm0, xmm4
  000aa	e8 00 00 00 00	 call	 __ftoui3
  000af	89 45 f8	 mov	 DWORD PTR _dwG$1$[ebp], eax
$LN12@SoftwareTr:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  000b2	f3 0f 10 86 34
	01 00 00	 movss	 xmm0, DWORD PTR [esi+308]
  000ba	0f 57 c9	 xorps	 xmm1, xmm1
  000bd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000c4	72 07		 jb	 SHORT $LN17@SoftwareTr
  000c6	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  000cb	eb 23		 jmp	 SHORT $LN16@SoftwareTr
$LN17@SoftwareTr:
  000cd	0f 2f c8	 comiss	 xmm1, xmm0
  000d0	72 04		 jb	 SHORT $LN15@SoftwareTr
  000d2	33 db		 xor	 ebx, ebx
  000d4	eb 1a		 jmp	 SHORT $LN16@SoftwareTr
$LN15@SoftwareTr:
  000d6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000de	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000e6	e8 00 00 00 00	 call	 __ftoui3
  000eb	8b d8		 mov	 ebx, eax
  000ed	0f 57 c9	 xorps	 xmm1, xmm1
$LN16@SoftwareTr:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  000f0	f3 0f 10 86 38
	01 00 00	 movss	 xmm0, DWORD PTR [esi+312]
  000f8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000ff	72 07		 jb	 SHORT $LN21@SoftwareTr
  00101	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  00106	eb 20		 jmp	 SHORT $LN20@SoftwareTr
$LN21@SoftwareTr:
  00108	0f 2f c8	 comiss	 xmm1, xmm0
  0010b	72 04		 jb	 SHORT $LN19@SoftwareTr
  0010d	33 ff		 xor	 edi, edi
  0010f	eb 17		 jmp	 SHORT $LN20@SoftwareTr
$LN19@SoftwareTr:
  00111	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00119	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00121	e8 00 00 00 00	 call	 __ftoui3
  00126	8b f8		 mov	 edi, eax
$LN20@SoftwareTr:

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00128	c1 e7 08	 shl	 edi, 8
  0012b	0b 7d fc	 or	 edi, DWORD PTR _dwR$1$[ebp]
  0012e	c1 e7 08	 shl	 edi, 8
  00131	0b 7d f8	 or	 edi, DWORD PTR _dwG$1$[ebp]
  00134	c1 e7 08	 shl	 edi, 8
  00137	0b fb		 or	 edi, ebx
  00139	8b 5d f4	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN2@SoftwareTr:
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 419  : 	BOOL isSoftwareVertexClipping=FALSE;

  0013c	33 f6		 xor	 esi, esi

; 420  : 	if (!IsTLVertexClipping())

  0013e	e8 00 00 00 00	 call	 ?IsTLVertexClipping@CGraphicBase@@SA_NXZ ; CGraphicBase::IsTLVertexClipping
  00143	84 c0		 test	 al, al
  00145	b9 01 00 00 00	 mov	 ecx, 1
  0014a	0f 44 f1	 cmove	 esi, ecx

; 421  : 		isSoftwareVertexClipping=TRUE;
; 422  : 
; 423  : 	STATEMANAGER.SaveRenderState(D3DRS_SOFTWAREVERTEXPROCESSING, isSoftwareVertexClipping);

  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00153	56		 push	 esi
  00154	68 99 00 00 00	 push	 153			; 00000099H
  00159	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 424  : 
; 425  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00164	6a 01		 push	 1
  00166	6a 1b		 push	 27			; 0000001bH
  00168	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 426  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, TRUE);

  0016d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00173	6a 01		 push	 1
  00175	6a 0f		 push	 15			; 0000000fH
  00177	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 427  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAREF, 0x00000000);

  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00182	6a 00		 push	 0
  00184	6a 18		 push	 24			; 00000018H
  00186	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 428  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

  0018b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00191	6a 05		 push	 5
  00193	6a 19		 push	 25			; 00000019H
  00195	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 429  : 
; 430  : 	STATEMANAGER.SaveRenderState(D3DRS_TEXTUREFACTOR, dwFogColor);

  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a0	57		 push	 edi
  001a1	6a 3c		 push	 60			; 0000003cH
  001a3	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 431  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ae	6a 00		 push	 0
  001b0	68 89 00 00 00	 push	 137			; 00000089H
  001b5	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 432  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c0	6a 00		 push	 0
  001c2	6a 1c		 push	 28			; 0000001cH
  001c4	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 433  : 
; 434  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001cf	6a 02		 push	 2
  001d1	6a 02		 push	 2
  001d3	6a 00		 push	 0
  001d5	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 435  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  001da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e0	6a 00		 push	 0
  001e2	6a 03		 push	 3
  001e4	6a 00		 push	 0
  001e6	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 436  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  001eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f1	6a 02		 push	 2
  001f3	6a 01		 push	 1
  001f5	6a 00		 push	 0
  001f7	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 437  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  001fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00202	6a 02		 push	 2
  00204	6a 05		 push	 5
  00206	6a 00		 push	 0
  00208	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 438  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00213	6a 02		 push	 2
  00215	6a 04		 push	 4
  00217	6a 00		 push	 0
  00219	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 439  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  0021e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00224	6a 01		 push	 1
  00226	6a 0d		 push	 13			; 0000000dH
  00228	6a 00		 push	 0
  0022a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 440  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  0022f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00235	6a 01		 push	 1
  00237	6a 0e		 push	 14			; 0000000eH
  00239	6a 00		 push	 0
  0023b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 441  : 	STATEMANAGER.SetBestFiltering(0);

  00240	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00246	6a 00		 push	 0
  00248	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 442  : 
; 443  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0024d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00253	6a 01		 push	 1
  00255	6a 02		 push	 2
  00257	6a 01		 push	 1
  00259	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 444  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_TEXTURE);

  0025e	6a 02		 push	 2
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00266	6a 03		 push	 3
  00268	6a 01		 push	 1
  0026a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 445  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00275	6a 02		 push	 2
  00277	6a 01		 push	 1
  00279	6a 01		 push	 1
  0027b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 446  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00286	6a 02		 push	 2
  00288	6a 05		 push	 5
  0028a	6a 01		 push	 1
  0028c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 447  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);

  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00297	6a 01		 push	 1
  00299	6a 06		 push	 6
  0029b	6a 01		 push	 1
  0029d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 448  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  002a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002a8	6a 02		 push	 2
  002aa	6a 04		 push	 4
  002ac	6a 01		 push	 1
  002ae	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 449  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP);

  002b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002b9	6a 03		 push	 3
  002bb	6a 0d		 push	 13			; 0000000dH
  002bd	6a 01		 push	 1
  002bf	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 450  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP);

  002c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ca	6a 03		 push	 3
  002cc	6a 0e		 push	 14			; 0000000eH
  002ce	6a 01		 push	 1
  002d0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 451  : 	STATEMANAGER.SetBestFiltering(1);

  002d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002db	6a 01		 push	 1
  002dd	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 452  : 
; 453  : 	CSpeedTreeWrapper::ms_bSelfShadowOn = true;

  002e2	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA, 1 ; CSpeedTreeWrapper::ms_bSelfShadowOn

; 454  : 
; 455  : 	// Render State & TextureStageState
; 456  : 	//////////////////////////////////////////////////////////////////////////
; 457  : 
; 458  : 	m_iRenderedSplatNumSqSum = 0;
; 459  : 	m_iRenderedPatchNum = 0;
; 460  : 	m_iRenderedSplatNum = 0;
; 461  : 	m_RenderedTextureNumVector.clear();

  002e9	8b 83 90 09 00
	00		 mov	 eax, DWORD PTR [ebx+2448]
  002ef	89 83 94 09 00
	00		 mov	 DWORD PTR [ebx+2452], eax

; 462  : 
; 463  : 	m_matWorldForCommonUse._41 = 0.0f;
; 464  : 	m_matWorldForCommonUse._42 = 0.0f;
; 465  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorldForCommonUse);

  002f5	8d 83 48 07 00
	00		 lea	 eax, DWORD PTR [ebx+1864]
  002fb	50		 push	 eax
  002fc	c7 83 84 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+2436], 0
  00306	c7 83 8c 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+2444], 0
  00310	c7 83 88 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+2440], 0
  0031a	c7 83 78 07 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+1912], 0
  00324	c7 83 7c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+1916], 0
  0032e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00334	68 00 01 00 00	 push	 256			; 00000100H
  00339	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform
  0033e	5f		 pop	 edi
  0033f	5e		 pop	 esi
  00340	5b		 pop	 ebx

; 466  : }

  00341	8b e5		 mov	 esp, ebp
  00343	5d		 pop	 ebp
  00344	c3		 ret	 0
?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SoftwareTransformPatch_STLVertex@CMapOutdoor@@QAE@XZ
_TEXT	SEGMENT
??0SoftwareTransformPatch_STLVertex@CMapOutdoor@@QAE@XZ PROC ; CMapOutdoor::SoftwareTransformPatch_STLVertex::SoftwareTransformPatch_STLVertex, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SoftwareTransformPatch_STLVertex@CMapOutdoor@@QAE@XZ ENDP ; CMapOutdoor::SoftwareTransformPatch_STLVertex::SoftwareTransformPatch_STLVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SoftwareTransformPatch_STVertex@CMapOutdoor@@QAE@XZ
_TEXT	SEGMENT
??0SoftwareTransformPatch_STVertex@CMapOutdoor@@QAE@XZ PROC ; CMapOutdoor::SoftwareTransformPatch_STVertex::SoftwareTransformPatch_STVertex, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SoftwareTransformPatch_STVertex@CMapOutdoor@@QAE@XZ ENDP ; CMapOutdoor::SoftwareTransformPatch_STVertex::SoftwareTransformPatch_STVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_dwFogEnable$1$ = -452					; size = 4
_far_it$ = -448						; size = 4
_fog_far$ = -444					; size = 8
_near_it$ = -440					; size = 4
_fog_near$ = -436					; size = 8
_fLODLevel2Distance$ = -432				; size = 4
_fLODLevel1Distance$ = -428				; size = 4
_wPrimitiveCount$ = -424				; size = 2
_ePrimitiveType$ = -420					; size = 4
_byCUrrentLODLevel$1$ = -413				; size = 1
_kTPRS$ = -412						; size = 408
__$ArrayPad$ = -4					; size = 4
?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 01 00
	00		 sub	 esp, 452		; 000001c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b d9		 mov	 ebx, ecx

; 22   : 	SoftwareTransformPatch_SRenderState kTPRS;
; 23   : 
; 24   : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0001e	6a 1c		 push	 28			; 0000001cH
  00020	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 25   : 
; 26   : 	__SoftwareTransformPatch_ApplyRenderState();

  00025	8b cb		 mov	 ecx, ebx
  00027	89 85 3c fe ff
	ff		 mov	 DWORD PTR _dwFogEnable$1$[ebp], eax
  0002d	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState

; 27   : 
; 28   : 	__SoftwareTransformPatch_BuildPipeline(kTPRS);

  00032	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  00038	8b cb		 mov	 ecx, ebx
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline

; 29   : 
; 30   : 	std::pair<float, long> fog_far(kTPRS.m_fFogFarDistance+800.0f, 0);

  00040	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _kTPRS$[ebp+392]

; 33   : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  00045	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR _fog_far$[ebp]
  0004b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@44480000
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00053	8b bb 1c 01 00
	00		 mov	 edi, DWORD PTR [ebx+284]
  00059	8b b3 18 01 00
	00		 mov	 esi, DWORD PTR [ebx+280]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 33   : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  0005f	50		 push	 eax
  00060	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00061	f3 0f 11 85 44
	fe ff ff	 movss	 DWORD PTR _fog_far$[ebp], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 33   : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  00069	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR _far_it$[ebp]
  0006f	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _kTPRS$[ebp+388]
  00074	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@45480000
  0007c	56		 push	 esi
  0007d	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0007e	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _fog_far$[ebp+4], 0
  00088	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _fog_near$[ebp+4], 0
  00092	f3 0f 11 85 4c
	fe ff ff	 movss	 DWORD PTR _fog_near$[ebp], xmm0
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 33   : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  0009a	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >

; 34   : 	std::vector<std::pair<float ,long> >::iterator near_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_near);

  0009f	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _fog_near$[ebp]
  000a5	50		 push	 eax
  000a6	57		 push	 edi
  000a7	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR _near_it$[ebp]
  000ad	56		 push	 esi
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >
  000b4	83 c4 20	 add	 esp, 32			; 00000020H

; 35   : 
; 36   : 	WORD wPrimitiveCount;
; 37   : 	D3DPRIMITIVETYPE ePrimitiveType;
; 38   : 
; 39   : 	BYTE byCUrrentLODLevel = 0;

  000b7	c6 85 63 fe ff
	ff 00		 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 0

; 40   : 
; 41   : 	float fLODLevel1Distance = __GetNoFogDistance();

  000be	8b cb		 mov	 ecx, ebx
  000c0	e8 00 00 00 00	 call	 ?__GetNoFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetNoFogDistance
  000c5	d9 9d 54 fe ff
	ff		 fstp	 DWORD PTR _fLODLevel1Distance$[ebp]

; 42   : 	float fLODLevel2Distance = __GetFogDistance();

  000cb	8b cb		 mov	 ecx, ebx
  000cd	e8 00 00 00 00	 call	 ?__GetFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetFogDistance

; 43   : 
; 44   : 	SelectIndexBuffer(0, &wPrimitiveCount, &ePrimitiveType);

  000d2	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  000d8	8b cb		 mov	 ecx, ebx
  000da	50		 push	 eax
  000db	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  000e1	50		 push	 eax
  000e2	6a 00		 push	 0
  000e4	d9 9d 50 fe ff
	ff		 fstp	 DWORD PTR _fLODLevel2Distance$[ebp]
  000ea	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 45   : 
; 46   : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX2);

  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f5	68 c4 02 00 00	 push	 708			; 000002c4H
  000fa	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000ff	8b bb 18 01 00
	00		 mov	 edi, DWORD PTR [ebx+280]

; 149  :         return _Ptr == _Right._Ptr;

  00105	8b b5 48 fe ff
	ff		 mov	 esi, DWORD PTR _near_it$[ebp]
  0010b	3b fe		 cmp	 edi, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 50   : 	for( ; it != near_it; ++it)

  0010d	0f 84 b3 00 00
	00		 je	 $LN120@RenderTerr
$LL4@RenderTerr:

; 52   : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00113	8a 85 63 fe ff
	ff		 mov	 al, BYTE PTR _byCUrrentLODLevel$1$[ebp]
  00119	84 c0		 test	 al, al
  0011b	75 2f		 jne	 SHORT $LN115@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  0011d	57		 push	 edi
  0011e	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00123	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 52   : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00126	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0012a	0f 2f 85 54 fe
	ff ff		 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  00131	72 51		 jb	 SHORT $LN13@RenderTerr

; 53   : 		{
; 54   : 			byCUrrentLODLevel = 1;
; 55   : 			SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  00133	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00139	c6 85 63 fe ff
	ff 01		 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 1
  00140	50		 push	 eax
  00141	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00147	50		 push	 eax
  00148	6a 01		 push	 1

; 56   : 		}

  0014a	eb 31		 jmp	 SHORT $LN123@RenderTerr
$LN115@RenderTerr:

; 57   : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  0014c	3c 01		 cmp	 al, 1
  0014e	75 34		 jne	 SHORT $LN13@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00150	57		 push	 edi
  00151	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00156	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 57   : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  00159	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0015d	0f 2f 85 50 fe
	ff ff		 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  00164	72 1e		 jb	 SHORT $LN13@RenderTerr

; 58   : 		{
; 59   : 			byCUrrentLODLevel = 2;
; 60   : 			SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00166	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  0016c	c6 85 63 fe ff
	ff 02		 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 2
  00173	50		 push	 eax
  00174	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0017a	50		 push	 eax
  0017b	6a 02		 push	 2
$LN123@RenderTerr:

; 63   : 		__SoftwareTransformPatch_RenderPatchSplat(kTPRS, it->second, wPrimitiveCount, ePrimitiveType, false);

  0017d	8b cb		 mov	 ecx, ebx
  0017f	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN13@RenderTerr:
  00184	6a 00		 push	 0
  00186	ff b5 5c fe ff
	ff		 push	 DWORD PTR _ePrimitiveType$[ebp]
  0018c	ff b5 58 fe ff
	ff		 push	 DWORD PTR _wPrimitiveCount$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00192	57		 push	 edi
  00193	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00198	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 63   : 		__SoftwareTransformPatch_RenderPatchSplat(kTPRS, it->second, wPrimitiveCount, ePrimitiveType, false);

  0019b	8b cb		 mov	 ecx, ebx
  0019d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a0	50		 push	 eax
  001a1	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat

; 64   : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  001ad	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  001b3	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  001b9	7d 0b		 jge	 SHORT $LN120@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 75   :         ++_Ptr;

  001bb	83 c7 08	 add	 edi, 8

; 149  :         return _Ptr == _Right._Ptr;

  001be	3b fe		 cmp	 edi, esi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 50   : 	for( ; it != near_it; ++it)

  001c0	0f 85 4d ff ff
	ff		 jne	 $LL4@RenderTerr
$LN120@RenderTerr:

; 65   : 			break;
; 66   : 
; 67   : 	}
; 68   : 
; 69   : 	if (m_iRenderedSplatNum < m_iSplatLimit)

  001c6	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  001cc	8b bd 40 fe ff
	ff		 mov	 edi, DWORD PTR _far_it$[ebp]
  001d2	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  001d8	0f 8d bb 00 00
	00		 jge	 $LN121@RenderTerr

; 71   : 		for(it = near_it; it != far_it; ++it)

  001de	3b f7		 cmp	 esi, edi
  001e0	0f 84 b3 00 00
	00		 je	 $LN121@RenderTerr
$LL7@RenderTerr:

; 73   : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  001e6	8a 85 63 fe ff
	ff		 mov	 al, BYTE PTR _byCUrrentLODLevel$1$[ebp]
  001ec	84 c0		 test	 al, al
  001ee	75 2f		 jne	 SHORT $LN116@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  001f0	56		 push	 esi
  001f1	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  001f6	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 73   : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  001f9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001fd	0f 2f 85 54 fe
	ff ff		 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  00204	72 51		 jb	 SHORT $LN18@RenderTerr

; 74   : 			{
; 75   : 				byCUrrentLODLevel = 1;
; 76   : 				SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  00206	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  0020c	c6 85 63 fe ff
	ff 01		 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 1
  00213	50		 push	 eax
  00214	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0021a	50		 push	 eax
  0021b	6a 01		 push	 1

; 77   : 			}

  0021d	eb 31		 jmp	 SHORT $LN124@RenderTerr
$LN116@RenderTerr:

; 78   : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  0021f	3c 01		 cmp	 al, 1
  00221	75 34		 jne	 SHORT $LN18@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00223	56		 push	 esi
  00224	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00229	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 78   : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  0022c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00230	0f 2f 85 50 fe
	ff ff		 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  00237	72 1e		 jb	 SHORT $LN18@RenderTerr

; 79   : 			{
; 80   : 				byCUrrentLODLevel = 2;
; 81   : 				SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00239	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  0023f	c6 85 63 fe ff
	ff 02		 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 2
  00246	50		 push	 eax
  00247	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0024d	50		 push	 eax
  0024e	6a 02		 push	 2
$LN124@RenderTerr:

; 84   : 			__SoftwareTransformPatch_RenderPatchSplat(kTPRS, it->second, wPrimitiveCount, ePrimitiveType, true);

  00250	8b cb		 mov	 ecx, ebx
  00252	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN18@RenderTerr:
  00257	6a 01		 push	 1
  00259	ff b5 5c fe ff
	ff		 push	 DWORD PTR _ePrimitiveType$[ebp]
  0025f	ff b5 58 fe ff
	ff		 push	 DWORD PTR _wPrimitiveCount$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00265	56		 push	 esi
  00266	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0026b	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 84   : 			__SoftwareTransformPatch_RenderPatchSplat(kTPRS, it->second, wPrimitiveCount, ePrimitiveType, true);

  0026e	8b cb		 mov	 ecx, ebx
  00270	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00273	50		 push	 eax
  00274	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat

; 85   : 
; 86   : 			if (m_iRenderedSplatNum >= m_iSplatLimit)

  00280	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  00286	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  0028c	7d 0b		 jge	 SHORT $LN121@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 75   :         ++_Ptr;

  0028e	83 c6 08	 add	 esi, 8

; 149  :         return _Ptr == _Right._Ptr;

  00291	3b f7		 cmp	 esi, edi
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 71   : 		for(it = near_it; it != far_it; ++it)

  00293	0f 85 4d ff ff
	ff		 jne	 $LL7@RenderTerr
$LN121@RenderTerr:

; 87   : 				break;
; 88   : 
; 89   : 		}
; 90   : 	}
; 91   : 
; 92   : 
; 93   : 	STATEMANAGER.SetTexture(0, NULL);

  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0029f	6a 00		 push	 0
  002a1	6a 00		 push	 0
  002a3	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 94   : 	STATEMANAGER.SetTexture(1, NULL);

  002a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ae	6a 00		 push	 0
  002b0	6a 01		 push	 1
  002b2	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 95   : 
; 96   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  002b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002bd	6a 03		 push	 3
  002bf	6a 02		 push	 2
  002c1	6a 00		 push	 0
  002c3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 97   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ce	6a 02		 push	 2
  002d0	6a 01		 push	 1
  002d2	6a 00		 push	 0
  002d4	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 98   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  002d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002df	6a 01		 push	 1
  002e1	6a 04		 push	 4
  002e3	6a 00		 push	 0
  002e5	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 99   : 
; 100  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_DISABLE);

  002ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002f0	6a 01		 push	 1
  002f2	6a 01		 push	 1
  002f4	6a 01		 push	 1
  002f6	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 101  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00301	6a 01		 push	 1
  00303	6a 04		 push	 4
  00305	6a 01		 push	 1
  00307	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 102  : 
; 103  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZRHW);

  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00312	6a 04		 push	 4
  00314	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 104  : 
; 105  : 	if (IsFastTNL())

  00319	e8 00 00 00 00	 call	 ?IsFastTNL@CGraphicBase@@SA_NXZ ; CGraphicBase::IsFastTNL
  0031e	84 c0		 test	 al, al
  00320	0f 84 7a 00 00
	00		 je	 $LN122@RenderTerr

; 106  : 	{
; 107  : 		if (byCUrrentLODLevel != 2)

  00326	80 bd 63 fe ff
	ff 02		 cmp	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 2
  0032d	74 17		 je	 SHORT $LN21@RenderTerr

; 108  : 		{
; 109  : 			byCUrrentLODLevel = 2;
; 110  : 			SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  0032f	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00335	8b cb		 mov	 ecx, ebx
  00337	50		 push	 eax
  00338	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0033e	50		 push	 eax
  0033f	6a 02		 push	 2
  00341	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN21@RenderTerr:

; 111  : 		}
; 112  : 
; 113  : 		if (m_iRenderedSplatNum < m_iSplatLimit)

  00346	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  0034c	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  00352	7d 4c		 jge	 SHORT $LN122@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00354	3b bb 1c 01 00
	00		 cmp	 edi, DWORD PTR [ebx+284]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 115  : 			for(it = far_it; it != m_PatchVector.end(); ++it)

  0035a	74 44		 je	 SHORT $LN122@RenderTerr
  0035c	0f 1f 40 00	 npad	 4
$LL10@RenderTerr:

; 117  : 				__SoftwareTransformPatch_RenderPatchNone(kTPRS, it->second, wPrimitiveCount, ePrimitiveType);

  00360	ff b5 5c fe ff
	ff		 push	 DWORD PTR _ePrimitiveType$[ebp]
  00366	ff b5 58 fe ff
	ff		 push	 DWORD PTR _wPrimitiveCount$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  0036c	57		 push	 edi
  0036d	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00372	83 c4 04	 add	 esp, 4
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 117  : 				__SoftwareTransformPatch_RenderPatchNone(kTPRS, it->second, wPrimitiveCount, ePrimitiveType);

  00375	8b cb		 mov	 ecx, ebx
  00377	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0037a	50		 push	 eax
  0037b	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  00381	50		 push	 eax
  00382	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone

; 118  : 
; 119  : 				if (m_iRenderedSplatNum >= m_iSplatLimit)

  00387	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  0038d	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  00393	7d 0b		 jge	 SHORT $LN122@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 75   :         ++_Ptr;

  00395	83 c7 08	 add	 edi, 8

; 149  :         return _Ptr == _Right._Ptr;

  00398	3b bb 1c 01 00
	00		 cmp	 edi, DWORD PTR [ebx+284]
; File C:\DS Project\DS Files\Source\ClientSource\Client\GameLib\MapOutdoorRenderSTP.cpp

; 115  : 			for(it = far_it; it != m_PatchVector.end(); ++it)

  0039e	75 c0		 jne	 SHORT $LL10@RenderTerr
$LN122@RenderTerr:

; 120  : 					break;
; 121  : 
; 122  : 			}
; 123  : 		}
; 124  : 	}
; 125  : 
; 126  : 
; 127  : 	//////////////////////////////////////////////////////////////////////////
; 128  : 	// Render State & TextureStageState
; 129  : 	__SoftwareTransformPatch_RestoreRenderState(dwFogEnable);

  003a0	ff b5 3c fe ff
	ff		 push	 DWORD PTR _dwFogEnable$1$[ebp]
  003a6	8b cb		 mov	 ecx, ebx
  003a8	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState

; 130  : }

  003ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b0	5f		 pop	 edi
  003b1	5e		 pop	 esi
  003b2	33 cd		 xor	 ecx, ebp
  003b4	5b		 pop	 ebx
  003b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ba	8b e5		 mov	 esp, ebp
  003bc	5d		 pop	 ebp
  003bd	c3		 ret	 0
?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\DS Project\DS Files\Source\ClientSource\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR4@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR4@@QAE@XZ PROC				; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 133  :     D3DXVECTOR4() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR4@@QAE@XZ ENDP				; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
